
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vườn Cây Hạnh Phúc - Thu Hoạch & Thách Thức!</title> <!-- Thay đổi tiêu đề -->
	<link rel="stylesheet" href="style-plotlocked-popup.css">
	<link rel="stylesheet" href="style-menu-button.css"> 
	<link rel="stylesheet" href="style-confirm-hatngoctroi.css">
	 <link rel="stylesheet" href="style-progressbar-thoitiet.css">
	 <link rel="stylesheet" href="style-hatngoctroi.css">
	 <link rel="stylesheet" href="style-tuido-item-bodi.css">
	 <link rel="stylesheet" href="style-popup-confirm-restoregame.css">

    <style>
		    #toggle-effects-sound-btn {
            background-color: #ff9800; /* Màu cam (giống nút Mua) */
            color: white; /* Đảm bảo chữ dễ đọc */
        }

        #toggle-effects-sound-btn:hover:not(:disabled) {
            background-color: #f57c00; /* Cam đậm hơn khi hover */
            opacity: 0.95; /* Giữ lại hiệu ứng opacity nếu có */
        }

        #toggle-effects-sound-btn:active:not(:disabled) {
            background-color: #e65100; /* Cam đậm hơn nữa khi active */
            transform: scale(0.98); /* Hiệu ứng nhấn nhẹ */
        }

        /* Kiểu khi bị disable (nếu có) */
        #toggle-effects-sound-btn:disabled {
            background-color: #ffcc80; /* Màu cam nhạt khi disable */
            cursor: not-allowed;
            opacity: 0.7;
            transform: none; /* Bỏ hiệu ứng transform khi disable */
        }
	
		 #toggle-sound-btn {
            background-color: #4CAF50; /* Màu xanh lá (giống nút UI chính) */
            color: white; /* Đảm bảo chữ màu trắng dễ đọc */
        }

        #toggle-sound-btn:hover:not(:disabled) {
            background-color: #45a049; /* Xanh lá đậm hơn khi hover */
            opacity: 0.95; /* Giữ lại hiệu ứng opacity nếu có */
        }
        /* Kiểu khi bị disable (nếu có) */
        #toggle-sound-btn:disabled {
            background-color: #a5d6a7; /* Màu xanh lá nhạt khi disable */
            cursor: not-allowed;
            opacity: 0.7;
        }
	
	
	
	
	
	
	  @keyframes shake {
          0%, 100% { transform: translate(0, 0) rotate(0); }
          10%, 30%, 50%, 70%, 90% { transform: translate(-2px, -1px) rotate(-1deg); }
          20%, 40%, 60%, 80% { transform: translate(2px, 1px) rotate(1deg); }
        }

        @keyframes flash {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1.6); } /* Phóng to một chút khi sáng nhất */
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.5); } /* Mờ đi và nhỏ lại chút */
        }

        .plot.thunderstruck {
          /* <<<< THAY ĐỔI animation-duration thành 2s <<<< */
          animation: shake 1s cubic-bezier(.36,.07,.19,.97) both;
          position: relative;
          z-index: 2;
        }
		/* <<<< BỔ SUNG CSS CHO GIF CONTAINER VÀ IMG >>>> */
.lightning-gif-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex; /* Sử dụng flex để căn giữa */
    justify-content: center;
    align-items: center;
    opacity: 0; /* Ẩn mặc định */
    visibility: hidden; /* Ẩn hoàn toàn */
    transition: opacity 0.15s ease-out, visibility 0s 0.15s; /* Hiệu ứng mờ dần khi ẩn */
    pointer-events: none; /* Không chặn click */
    z-index: 5; /* Nằm trên nội dung plot, dưới modal */
    overflow: hidden; /* Đảm bảo GIF không tràn ra ngoài */
    border-radius: inherit; /* Kế thừa bo góc của plot */
}
   .plot.thunderstruck .lightning-gif-container {
    opacity: 1; /* Hiện khi có class thunderstruck */
    visibility: visible;
    transition: opacity 0.1s ease-in, visibility 0s; /* Hiện nhanh */
}

.lightning-gif-container img {
    display: block; /* Loại bỏ khoảng trắng thừa dưới ảnh */
    max-width: 100%; /* Hoặc điều chỉnh % nhỏ hơn nếu muốn GIF nhỏ hơn ô */
    max-height: 100%;
    object-fit: contain; /* Giữ tỷ lệ GIF */
}     
	
	
	
	
		/* --- [MỚI] Kiểu cho ô đất bị khô --- */
.plot.dry-soil-effect {
    border-style: dashed !important; /* Dùng !important để ghi đè viền infested nếu cần */
    border-color: #e67e22 !important; /* Màu cam đất */
    background-color: rgba(210, 180, 140, 0.3); /* Màu nền hơi nâu nhạt, bán trong suốt */
    box-shadow: inset 0 0 10px rgba(165, 42, 42, 0.3); /* Bóng đổ màu nâu bên trong */
}
/* Hover trên ô bị khô */
.plot.dry-soil-effect:not(.locked):hover {
    border-color: #d35400 !important; /* Cam đậm hơn khi hover */
    background-color: rgba(210, 180, 140, 0.4);
}
/* Ưu tiên màu viền infested nếu cả hai cùng active */
.plot.infested.dry-soil-effect {
     border-color: #e53935 !important; /* Giữ màu viền đỏ của infested */
}
	
	
	
        /* --- Reset & Kiểu Cơ Bản --- */
		/* --- [MỚI] Kiểu nút Tưới Nước --- */
#modal-content-Tuoinuoc {
    background-color: #64b5f6; /* Màu xanh da trời nhạt (Material Blue 300) */
    /* Thêm hiệu ứng hover nếu muốn */
}
#modal-content-Tuoinuoc:hover:not(:disabled) {
   background-color: #42a5f5; /* Xanh đậm hơn chút khi hover */
   opacity: 0.95;
}
/* Kiểu khi bị disable (giống các nút action khác) */
#modal-content-Tuoinuoc:disabled {
    background-color: #bdbdbd;
    cursor: not-allowed;
    transform: none;
    opacity: 0.7;
}
		
		
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px; /* Cỡ chữ cơ bản */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f8ff; /* AliceBlue */
            color: #333;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overscroll-behavior: none; /* Chặn kéo để làm mới trên mobile */
            touch-action: manipulation; /* Cải thiện phản hồi chạm */
            -webkit-tap-highlight-color: transparent; /* Bỏ highlight khi chạm trên mobile */
        }

        /* --- Bố Cục --- */
        #game-container {
            max-width: 900px;
            margin: 10px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        } 
		#game-container.darken-weather-effect {
    filter: brightness(0.85); /* Giảm độ sáng xuống 85% */
    transition: filter 0.8s ease-in-out; /* Hiệu ứng chuyển đổi mượt mà */
    /* Tùy chọn: Có thể thêm hiệu ứng khác như làm lạnh màu nhẹ */
    /* filter: brightness(0.85) contrast(0.95) saturate(0.9); */
}
        #header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px dashed #90ee90;
        }

        #header h1 {
            color: #2e8b57; /* SeaGreen */
            font-size: 2rem;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        #stats-bar {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: #e6f5e6;
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 1rem;
            flex-wrap: wrap;
            gap: 15px;
            border: 1px solid #c8e6c9;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.08);
            min-width: 120px;
            justify-content: center;
        }

        .stat-item span {
            font-weight: bold;
            color: #3b7554; /* Xanh đậm hơn */
            font-size: 1.05em;
        }

        /* --- Khu Vườn --- */
       #garden {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Lưới linh hoạt */
            gap: 20px;
            padding: 20px;
            background-color: #d2b48c; /* Tan - tượng trưng cho đất */
            border: 6px solid #8b4513; /* SaddleBrown - viền dày hơn */
            border-radius: 12px;
            margin-bottom: 20px;
            flex-grow: 1;
            /* min-height: 250px; */ /* Thay thế min-height bằng max-height */
            align-content: start;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23a0522d' fill-opacity='0.2' fill-rule='evenodd'%3E%3Cpath d='M0 40L40 0H20L0 20M40 40V20L20 40'/%3E%3C/g%3E%3C/svg%3E"); /* Họa tiết đất tinh tế */

            /* --- [CẬP NHẬT] --- */
            max-height: 580px; /* Giới hạn chiều cao tối đa (ước tính cho khoảng 4 hàng desktop) - Điều chỉnh nếu cần */
            overflow-y: auto; /* Cho phép cuộn dọc khi nội dung vượt quá max-height */
            /* Tùy chọn: Thêm kiểu cho thanh cuộn */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #a0522d #d2b48c; /* Firefox: màu thumb và track */
            /* --- [HẾT CẬP NHẬT BAN ĐẦU] --- */
        }
		/* Tùy chọn: Kiểu thanh cuộn cho WebKit (Chrome, Safari, Edge) */
        #garden::-webkit-scrollbar {
            width: 8px; /* Chiều rộng thanh cuộn */
        }

        #garden::-webkit-scrollbar-track {
            background: #d2b48c; /* Màu nền track (giống nền garden) */
            border-radius: 4px;
        }

        #garden::-webkit-scrollbar-thumb {
            background-color: #a0522d; /* Màu của thumb (giống màu đất) */
            border-radius: 4px;
            border: 2px solid #d2b48c; /* Tạo khoảng cách nhỏ giữa thumb và track */
        }
        #garden::-webkit-scrollbar-thumb:hover {
            background-color: #8f5a33; /* Màu thumb đậm hơn khi hover */
        }
		
		
		

        .plot {
            background-color: #a0522d; /* Sienna - đất tối hơn */
            border: 3px solid #8b4513; /* SaddleBrown */
            border-radius: 10px;
            height: 115px; /* Tăng chiều cao cho thanh máu/phì nhiêu */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.25);
            padding-top: 5px;
        }

        /* Hover ô chưa khóa & KHÔNG cằn 0% */
        .plot:not(.locked):not(.barren-soil):hover {
            background-color: #8f5a33;
            transform: scale(1.04);
            border-color: #a0522d;
        }
        /* Hover ô cằn 0% */
        .plot.barren-soil:not(.locked):hover {
             background-color: #9d9d9d !important; /* Màu xám hover */
             transform: scale(1.03);
             border-color: #666 !important;
        }

        /* Chỉ đổi màu nền tối hơn nếu đã trồng và đất KHÔNG cằn 0% */
        .plot.planted:not(.barren-soil) {
            background-color: #5f4c3a;
        }

        /* Kiểu cho đất cằn (thêm lớp .barren-soil) */
        .plot.barren-soil {
            background-color: #a9a9a9 !important; /* DarkGray - Quan trọng: màu đất 0% */
            border-color: #777 !important; /* Viền xám tối */
        }


        .plot.infested {
             /* Dùng !important để ghi đè viền khác (kể cả viền barren) */
             border-color: #e53935 !important;
             animation: infestedPulse 1.2s infinite alternate ease-in-out;
        }
        @keyframes infestedPulse {
            from { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 4px #e53935; }
            to   { box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3), 0 0 10px #ff6f60; }
        }

        /* --- Ô Đất Bị Khóa --- */
        .plot.locked {
            /* !important để chắc chắn ghi đè barren nếu có lỗi */
            background-color: #b0b0b0 !important;
            border-color: #777 !important;
            cursor: not-allowed; /* Đổi con trỏ */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        .plot.locked .plant-visual-container,
        .plot.locked .bars-container, /* Ẩn thanh bar trên ô khóa */
        .plot.locked .plot-info {
            opacity: 0.3; /* Làm mờ nội dung bên trong */
        }
        .plot.locked:hover { /* Hover ô bị khóa */
            background-color: #a0a0a0 !important;
            transform: scale(1.02);
            cursor: pointer; /* Đổi thành pointer khi có thể mua */
        }
        /* Icon khóa (Tùy chọn) */
        .plot.locked::before {
            content: '🔒';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: rgba(0, 0, 0, 0.4);
            z-index: 5;
            pointer-events: none; /* Không chặn click vào ô */
        }


        .plant-visual-container {
             position: relative;
             width: 100%;
             height: 55%; /* Điều chỉnh chiều cao */
             display: flex;
             justify-content: center;
             align-items: center;
        }

        .plant-visual {
            /* Container chứa hình ảnh */
            line-height: 1;
            text-align: center;
            user-select: none;
            transition: transform 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55), opacity 0.5s ease, filter 0.5s ease; /* Thêm filter vào transition */
            opacity: 0;
            transform: scale(0.5) rotate(-15deg);
            z-index: 1;
            display: flex; /* Dùng flex để căn giữa ảnh */
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        .plant-visual img {
            max-width: 70%; /* Điều chỉnh dựa trên tỉ lệ ảnh */
            max-height: 70%; /* Điều chỉnh dựa trên tỉ lệ ảnh */
            object-fit: contain; /* Scale ảnh đẹp */
            transition: filter 0.5s ease; /* Thêm transition cho filter của ảnh */
        }

        .plant-visual.visible {
            opacity: 1;
            transform: scale(1) rotate(0deg);
        }

        .pest-icon {
            position: absolute;
            font-size: 1.1rem;
            color: #dc143c;
            z-index: 2;
            top: 3px;
            right: 3px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            padding: 2px;
            line-height: 1;
            display: none; /* Ẩn mặc định */
            animation: wiggle 0.4s infinite ease-in-out;
            text-shadow: 0 0 2px white;
        }

        .plot.infested .pest-icon {
            display: block; /* Hiện khi có class infested */
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(-8deg) scale(1); }
            50% { transform: rotate(8deg) scale(1.1); }
        }

        /* Các Giai Đoạn Cây (Class có thể áp dụng nếu cần, nhưng chủ yếu là thay đổi src ảnh) */
        .stage-0 { /* Giai đoạn mầm nếu cần style riêng */ }
        .stage-dead { /* Hình ảnh khi chết */
            filter: grayscale(80%) brightness(0.7); /* Làm ảnh xám và tối đi */
        }
        .stage-dead.pest-death img {
            /* Có thể thêm hiệu ứng đặc biệt cho ảnh chết do sâu nếu dùng chung <img> */
            /* Ví dụ: filter: grayscale(100%) sepia(30%) brightness(0.6); */
        }

        /* --- Thanh Máu & Phì Nhiêu --- */
         .bars-container {
            width: 85%;
            margin: 3px auto 3px;
            display: flex; /* <<< QUAN TRỌNG: Luôn là flex để chứa các thanh bên trong */
            flex-direction: column;
            gap: 2px; /* Khoảng cách giữa các thanh */
        }

        .bar-wrapper { /* Wrapper cho mỗi thanh (cả máu và phì nhiêu) */
             width: 100%;
             height: 6px; /* Chiều cao thanh riêng lẻ */
             background-color: #555; /* Nền tối */
             border-radius: 3px;
             overflow: hidden; /* Giữ phần fill bên trong */
             border: 1px solid #333;
             position: relative; /* Cho nhãn tiềm năng */
        }

        /* <<< QUAN TRỌNG: Quy tắc này ẩn THANH MÁU khi ô đất KHÔNG có class .planted */
        .plot:not(.planted) .health-bar-wrapper {
            display: none;
        }
        /* <<< LƯU Ý: Không có quy tắc tương tự cho .fertility-bar-wrapper => Thanh phì nhiêu LUÔN được hiển thị bởi CSS (nếu cha nó hiển thị) */


        .bar-fill { /* Kiểu fill chung */
            height: 100%;
            width: 100%; /* Mặc định đầy, JS sẽ chỉnh width */
            border-radius: 2px;
            transition: width 0.5s ease-out, background-color 0.5s ease;
            box-shadow: inset 0 -1px 1px rgba(0, 0, 0, 0.2);
        }

         /* Chi tiết Thanh Máu */
        .health-bar-fill {
            background-color: #4CAF50; /* Xanh lá */
        }
        .health-bar-fill.medium-health {
            background-color: #ffeb3b; /* Vàng */
        }
        .health-bar-fill.low-health {
            background-color: #f44336; /* Đỏ */
        }

         /* Chi tiết Thanh Phì Nhiêu */
        .fertility-bar-fill {
            background-color: #8B4513; /* SaddleBrown */
        }
        .fertility-bar-fill.medium-fertility {
             background-color: #b8860b; /* DarkGoldenrod */
         }
        .fertility-bar-fill.low-fertility {
             background-color: #a9a9a9; /* DarkGray */
         }
         /* Thêm màu cho đất cằn 0% */
         .fertility-bar-fill.barren {
             background-color: #666 !important; /* Màu xám rất tối */
         }


        .plot-info {
            font-size: 0.65rem;
            color: #f5f5f5;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            white-space: normal;
            overflow: hidden;
            text-overflow: ellipsis;
            border-radius: 4px;
            width: 95%;
            margin: 0 auto 5px;
            line-height: 1.3;
            min-height: 2.6em; /* Cho phép khoảng 2 dòng */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        /* Chỉ áp dụng khi low nhưng chưa barren */
        .plot.low-fertility:not(.barren-soil) .plot-info {
             /* Có thể đổi màu nhẹ nếu muốn */
         }
         /* Đổi màu nền/chữ info khi đất cằn 0% */
         .plot.barren-soil .plot-info {
             background-color: rgba(40, 40, 40, 0.7) !important;
             color: #bbb !important;
             font-style: italic;
         }

        /* Ghi đè style của barren nếu đang bị sâu */
        .plot.infested .plot-info {
            background-color: rgba(180, 0, 0, 0.6) !important;
            color: white !important;
            font-style: normal !important; /* Ghi đè italic của barren nếu đang bị sâu */
        }
        /* Text thông tin cho ô cần phí dọn dẹp (sâu chết) */
        .plot-info.needs-cleanup-fee {
             color: #fff !important;
             background-color: rgba(100, 0, 0, 0.7) !important;
             font-weight: bold;
             font-style: normal !important;
         }
         /* Style cho ô đang click dọn miễn phí */
         .plot-info.free-cleanup-progress {
            color: #ffe0b2 !important; /* Vàng nhạt */
            background-color: rgba(60, 60, 0, 0.8) !important;
            font-weight: bold;
            font-style: normal !important;
         }
        /* Text thông tin cho ô bị khóa */
        .plot.locked .plot-info {
            background-color: rgba(50, 50, 50, 0.6);
            color: #ccc;
            font-weight: bold;
            font-style: normal !important;
        }


        /* --- Bảng Điều Khiển UI --- */
        #ui-panel {
            display: flex;
            justify-content: space-around;
            margin-top: auto;
            padding: 15px 10px;
            background-color: #e6f5e6;
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 15px;
            border-top: 1px solid #c8e6c9;
        }

        .ui-button {
            background-color: #4CAF50; /* Xanh lá */
            border: none;
            color: white;
            padding: 12px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease;
            flex-grow: 1;
            min-width: 110px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            font-weight: 500;
        }

        .ui-button:hover:not(:disabled) {
            background-color: #45a049;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }

        .ui-button:active:not(:disabled) {
            background-color: #367c39;
            transform: scale(0.98) translateY(0px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }
        .ui-button:disabled {
            background-color: #bdbdbd;
            cursor: not-allowed;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #757575;
        }

        /* --- Modals --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.4s ease;
            backdrop-filter: blur(3px);
        }
		 #discard-item-popup {
            z-index: 1010; /* Đặt z-index cao hơn modal chính (1000) */
        }
        @keyframes fadeIn {
            from { opacity: 0; backdrop-filter: blur(0px);}
            to { opacity: 1; backdrop-filter: blur(3px); }
        }

        .modal-content {
            background-color: #fefefe;
            margin: 8% auto;
            padding: 30px;
            border: 1px solid #ccc;
            width: 90%;
            max-width: 480px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
            position: relative;
            animation: slideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            flex-direction: column;
        }

        @keyframes slideIn {
            from { transform: translateY(-40px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }


        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .modal-header h2 {
            color: #2e8b57;
            font-size: 1.6rem;
        }

        .close-button {
            color: #999;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s ease, transform 0.2s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: #333;
            transform: rotate(90deg);
        }

        /* --- Tab Cửa Hàng / Kho Đồ --- */
        .tabs-container { /* Container chung cho các tab */
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
        }

        .tab-button { /* Kiểu nút tab chung */
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background-color: #f1f1f1;
            border-bottom: 3px solid transparent;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
            color: #555;
            flex-grow: 1;
            text-align: center;
            border-radius: 6px 6px 0 0;
            margin-right: 2px;
        }

        .tab-button:last-child {
            margin-right: 0;
        }

        .tab-button:hover {
            background-color: #e9e9e9;
        }

        .tab-button.active {
            background-color: #fff;
            border-color: #4CAF50; /* Xanh lá */
            color: #2e8b57; /* SeaGreen */
        }

        /* --- Vật Phẩm Cửa Hàng & Kho --- */
        .item-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); /* Lưới linh hoạt cho vật phẩm */
            gap: 20px;
            max-height: 60vh; /* Giới hạn chiều cao và cho phép cuộn */
            overflow-y: auto;
            padding: 15px 5px 10px 5px;
            scrollbar-width: thin;
            scrollbar-color: #aaa #eee;
            flex-grow: 1;
        }
        /* Chrome/Edge/Safari */
        .item-list::-webkit-scrollbar { width: 8px; }
        .item-list::-webkit-scrollbar-track { background: #eee; border-radius: 4px; }
        .item-list::-webkit-scrollbar-thumb { background-color: #aaa; border-radius: 4px; border: 2px solid #eee; }

        /* Ẩn danh sách vật phẩm không hoạt động */
        .item-list:not(.active-list) {
            display: none;
        }

        .item-card {
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            background-color: #fff;
            transition: box-shadow 0.3s ease, transform 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .item-card:hover:not(.no-hover) {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transform: translateY(-3px);
        }

        .item-icon {
            /* Container cho ảnh icon */
            height: 50px; /* Chiều cao cố định cho khu vực icon */
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .item-icon img {
             max-width: 100%;
             max-height: 100%;
             object-fit: contain; /* Scale ảnh đẹp */
        }

        .item-name {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1rem;
            color: #444;
            flex-grow: 1; /* Cho phép tên chiếm không gian */
            min-height: 2.4em; /* Đảm bảo không gian cho hai dòng */
            display: flex; /* Căn giữa dọc nếu ngắn */
            align-items: center;
            justify-content: center;
        }

        .item-details {
            font-size: 0.78rem; /* Hơi nhỏ hơn */
            color: #666; /* Xám hơi tối hơn */
            margin-bottom: 8px;
            line-height: 1.3;
            text-align: left; /* Căn trái chi tiết */
            padding: 0 5px; /* Thêm padding ngang */
        }
        .item-details div { /* Thêm khoảng cách giữa các dòng chi tiết */
           margin-bottom: 3px;
        }
        .item-details div:last-child {
           margin-bottom: 0;
        }

        .item-price, .item-quantity {
            font-size: 0.9rem;
            font-weight: bold;
            color: #3b7554; /* Xanh lá mặc định */
            margin-bottom: 12px;
            text-align: center; /* Căn giữa giá/số lượng */
        }
        /* Màu loại vật phẩm cụ thể (có thể tùy chỉnh) */
        .item-price.pesticide, .item-quantity.pesticide { color: #c0392b; }
        .item-price.fertilizer, .item-quantity.fertilizer { color: #8B4513; }

        /* [CẬP NHẬT] Kiểu hiển thị giá trị cho vật phẩm thu hoạch */
        .item-harvest-value {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 6px;
        }
        .item-harvest-value span {
            font-weight: bold;
            color: #d4af37; /* Màu vàng gold */
        }

        /* [CẬP NHẬT] Container bán trong kho đồ */
        .sell-container {
            display: flex;
            flex-direction: column; /* Xếp chồng lên nhau */
            gap: 8px;
            margin-top: 10px;
            align-items: center; /* Căn giữa */
        }
        .sell-quantity-selector {
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
            justify-content: center;
        }
        .sell-quantity-selector label {
            font-size: 0.75rem;
            color: #555;
            margin-right: 3px;
        }
        .sell-quantity-selector input[type="number"] {
            width: 55px; /* Rộng hơn chút */
            padding: 4px 6px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.85rem;
            -moz-appearance: textfield;
        }
        .sell-quantity-selector input::-webkit-outer-spin-button,
        .sell-quantity-selector input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .sell-button { /* Nút Bán chính */
            background-color: #2ecc71; /* Xanh ngọc */
            border: none;
            color: white;
            padding: 8px 15px; /* To hơn một chút */
            text-align: center;
            font-size: 0.8rem; /* To hơn một chút */
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            width: 80%; /* Chiếm phần lớn chiều rộng */
            max-width: 120px; /* Giới hạn */
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .sell-button:hover:not(:disabled) {
            background-color: #27ae60; /* Xanh đậm hơn */
            transform: scale(1.03);
        }
        .sell-button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            opacity: 0.7;
        }


        /* *** Kiểu Số Lượng Hạt Giống *** */
        .seed-quantity-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-bottom: 8px;
        }
        .seed-quantity-selector input[type="number"] {
            width: 50px;
            padding: 4px 6px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            -moz-appearance: textfield;
        }
        .seed-quantity-selector input::-webkit-outer-spin-button,
        .seed-quantity-selector input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .total-seed-cost {
            font-size: 0.85rem;
            color: #555;
            font-weight: normal;
            display: block;
            margin-bottom: 8px;
            min-height: 1.2em;
        }
        /* *** Kết thúc Kiểu Số Lượng Hạt Giống *** */

        .buy-button, .plant-button, .use-button, .action-button {
            background-color: #ff9800; /* Cam - Mua Mặc định */
            border: none;
            color: white;
            padding: 8px 12px;
            text-align: center;
            font-size: 0.85rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            width: 100%;
            margin-top: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .buy-button:hover:not(:disabled), .action-button:hover:not(:disabled), .use-button:hover:not(:disabled) {
            background-color: #f57c00; /* Cam đậm hơn */
            transform: scale(1.02);
        }

        /* Màu nút hành động cụ thể */
        .action-button.treat-pest { background-color: #e74c3c; } /* Đỏ cho thuốc trừ sâu */
        .action-button.treat-pest:hover:not(:disabled) { background-color: #c0392b; }
        .action-button.select-fertilizer { background-color: #8B4513; } /* Nâu cho phân bón */
        .action-button.select-fertilizer:hover:not(:disabled) { background-color: #7a3d10; }
        .action-button.clear-plant { background-color: #7f8c8d; } /* Xám cho dọn dẹp */
        .action-button.clear-plant:hover:not(:disabled) { background-color: #6c7a7b; }
        .action-button.clear-plant.costly { background-color: #c0392b; } /* Đỏ nhẹ cho dọn dẹp tốn phí */
        .action-button.clear-plant.costly:hover:not(:disabled) { background-color: #a93226; }
        /* [MỚI] Màu nút Bán Ngay */
        .action-button.sell-now { background-color: #ffb300; color:#333; font-weight: bold;} /* Vàng cam */
        .action-button.sell-now:hover:not(:disabled) { background-color: #ffa000; }

        .buy-button:disabled, .plant-button:disabled, .use-button:disabled, .action-button:disabled {
             background-color: #bdbdbd;
             cursor: not-allowed;
             transform: none;
             opacity: 0.7;
         }

        .plant-button {
             background-color: #4CAF50; /* Xanh lá cho trồng */
         }
        .plant-button:hover:not(:disabled) {
             background-color: #45a049;
             transform: scale(1.02);
         }
        .use-button { /* Kiểu cho nút 'Sử dụng' trong modal chọn */
            background-color: #2196F3; /* Xanh dương */
        }
        .use-button:hover:not(:disabled) {
            background-color: #1976D2; /* Xanh dương đậm hơn */
        }


         /* --- Kiểu Cụ Thể Modal Hành Động Cây Trồng --- */
        #plant-action-modal .modal-content {
            max-width: 450px;
            margin: 15% auto;
        }

        #plant-action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Giữ nguyên 2 cột */
            gap: 15px;
        }

        /* [CẬP NHẬT] Nút Thu Hoạch và Bán Ngay sẽ chiếm 2 cột */
        #plant-action-buttons #action-harvest-plant,
        #plant-action-buttons #action-sell-now {
            grid-column: 1 / -1; /* Chiếm từ cột 1 đến hết */
        }

        .action-button { /* Áp dụng cho tất cả các nút trong modal hành động */
            padding: 12px 15px;
            font-size: 0.9rem;
        }

        /* --- Kiểu Cụ Thể Modal Hành Động Ô Đất Trống --- */
        #empty-plot-action-modal .modal-content {
            max-width: 400px; /* Nhỏ hơn một chút */
            margin: 15% auto;
        }
        #empty-plot-action-buttons {
            display: grid;
            grid-template-columns: 1fr; /* Nút xếp chồng lên nhau */
            gap: 10px; /* Khoảng cách giữa các nút */
            margin-top: 10px;
        }
        #empty-plot-action-buttons .action-button {
            padding: 10px 15px; /* Padding nút */
            font-size: 0.95rem;
            text-transform: none; /* Không viết hoa */
            letter-spacing: normal;
            background-color: #4CAF50; /* Xanh lá mặc định */
        }
         #empty-plot-action-buttons .action-button.fertilize { background-color: #8B4513; } /* Nâu */
         #empty-plot-action-buttons .action-button.shop { background-color: #ff9800; } /* Cam */

        #empty-plot-action-buttons .action-button:hover:not(:disabled) {
            opacity: 0.9;
            transform: scale(1.01);
        }


        /* --- Khu Vực Tin Nhắn --- */
        #message-area {
            position: fixed;
    left: 50%;
    background-color: rgba(0, 0, 0, 0.75);
    color: white;
    padding: 12px 25px;
    border-radius: 25px;
    font-size: 1rem;
    z-index: 2000;
    opacity: 0;
    /* Quan trọng: Transition cho opacity, transform VÀ top/bottom */
    transition: opacity 0.5s ease, transform 0.5s ease, top 0.5s ease, bottom 0.5s ease;
    pointer-events: none;
    white-space: normal;
    text-align: center;
    box-shadow: 0 3px 10px rgba(0,0,0,0.3);
    max-width: 80%;
        }
        /* Style cho message nhiều dòng */
        #message-area.multiline {
             white-space: pre-line; /* Giữ lại các dấu xuống dòng */
        }

		#message-area.position-bottom {
    bottom: 15px; /* Vị trí ẩn ban đầu */
    top: auto;
    transform: translateX(-50%) scale(0.9); /* Hiệu ứng scale khi ẩn */
}
#message-area.position-bottom.show {
    opacity: 1;
    bottom: 30px; /* Vị trí hiện */
    transform: translateX(-50%) scale(1); /* Hiệu ứng scale khi hiện */
}

/* --- Định vị Phía Trên --- */
#message-area.position-top {
    top: 15px; /* Vị trí ẩn ban đầu (hơi lệch lên trên) */
    bottom: auto;
    transform: translateX(-50%) translateY(-60px) scale(0.9); /* Ẩn phía trên và scale nhỏ */
}
#message-area.position-top.show {
    opacity: 1;
    top: 30px; /* Vị trí hiện cuối cùng */
    transform: translateX(-50%) translateY(0) scale(1); /* Trượt xuống và scale lớn */
}


        #message-area.show {
            opacity: 1;
            bottom: 30px;
            transform: translateX(-50%) scale(1);
        }
        #message-area:not(.show) {
            transform: translateX(-50%) scale(0.9);
        }

        #message-area.success { background-color: rgba(46, 139, 87, 0.85); color: #fff; }
        #message-area.error { background-color: rgba(220, 20, 60, 0.85); color: #fff; }
        #message-area.warning { background-color: rgba(243, 156, 18, 0.9); color: #333; font-weight: 500; }
        #message-area.info { background-color: rgba(0, 0, 0, 0.75); color: white; }
         /* [MỚI] Style cho pest event */
         #message-area.pest-event { background-color: rgba(180, 0, 0, 0.88); color: white; font-weight: bold; }


        /* --- Chỉ Báo Tải --- */
        #loading-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            color: #444;
            backdrop-filter: blur(4px);
            flex-direction: column;
            gap: 15px;
            font-weight: 500;
        }
         /* Animation spinner đơn giản */
         #loading-indicator::before {
             content: '';
             display: block;
             width: 40px;
             height: 40px;
             border: 4px solid #ccc;
             border-top-color: #2e8b57;
             border-radius: 50%;
             animation: spin 1s linear infinite;
         }
         @keyframes spin {
             to { transform: rotate(360deg); }
         }


        /* --- Tooltip --- */
        .tooltip {
          position: fixed;
          background-color: rgba(0, 0, 0, 0.8);
          color: #fff;
          padding: 8px 12px;
          border-radius: 6px;
          font-size: 0.8rem;
          white-space: pre-line; /* Cho phép xuống dòng bằng \n */
          max-width: 200px;   /* Giới hạn chiều rộng */
          z-index: 1001;
          opacity: 0;
          transition: opacity 0.2s ease, top 0.2s ease, left 0.2s ease;
          pointer-events: none;
          left: -9999px;
          top: -9999px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
          line-height: 1.4;
          text-align: center; /* Căn giữa text tooltip */
        }

        .tooltip.visible {
            opacity: 1;
        }

        /* --- Điều Chỉnh Responsive --- */
       @media (max-width: 768px) { /* Tablet */
             #garden {
                 grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
                 gap: 15px;
                 /* --- [CẬP NHẬT] --- */
                 max-height: 520px; /* Giảm chiều cao tối đa cho tablet */
                 /* --- [HẾT CẬP NHẬT] --- */
             }
             .plot { height: 105px; }
             .plot.locked::before { font-size: 2rem; }
             .plant-visual img { max-height: 65%; max-width: 65%; }
             .pest-icon { font-size: 1rem; }
             .bar-wrapper { height: 5px; } /* Chiều cao thanh bar cho tablet */
             .plot-info { font-size: 0.6rem; min-height: 2.8em; }
        }

         @media (max-width: 600px) { /* Mobile Lớn */
            html { font-size: 14px; }
            #game-container { margin: 5px; padding: 15px; border-radius: 10px; }
            #header h1 { font-size: 1.8rem; }
            #stats-bar { font-size: 0.9rem; padding: 8px 10px; gap: 8px; }
            .stat-item { padding: 6px 10px; min-width: 100px; }
            #garden {
                gap: 12px;
                padding: 12px;
                grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
                /* --- [CẬP NHẬT] --- */
                max-height: 480px; /* Giảm chiều cao tối đa cho mobile lớn */
                 /* --- [HẾT CẬP NHẬT] --- */
            }
            .plot { height: 100px; border-width: 2px; }
            .plot.locked::before { font-size: 1.8rem; }
            .plant-visual img { max-height: 60%; max-width: 60%; }
             .pest-icon { font-size: 0.9rem; top: 2px; right: 2px; padding: 1px; }
             .bars-container { width: 90%; }
             .bar-wrapper { height: 4px; } /* Chiều cao thanh bar cho mobile lớn */
             .plot-info { font-size: 0.55rem; min-height: 3em; width: 95%; padding: 1px 3px; }
            .ui-button { padding: 10px 15px; font-size: 0.9rem; min-width: 95px; box-shadow: 0 3px 6px rgba(0,0,0,0.1); }
            .modal-content { width: 92%; margin: 12% auto; padding: 20px; }
            #plant-action-modal .modal-content,
            #empty-plot-action-modal .modal-content { margin: 20% auto; width: 85%; }
            .modal-header h2 { font-size: 1.4rem; }
             .tabs-container { margin-bottom: 10px; } /* Áp dụng cho cả shop và inventory tabs */
             .tab-button { padding: 8px 15px; font-size: 0.9rem; }
             .item-list { grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 15px; }
             .item-card { padding: 10px; }
             .item-icon { height: 45px; }
             .item-name { font-size: 0.9rem; min-height: 2.2em;}
             .item-details { font-size: 0.75rem; }
             .sell-button { font-size: 0.75rem; padding: 6px 10px; } /* Cập nhật sell-button */
             .sell-quantity-selector input[type="number"] { width: 45px; font-size: 0.8rem;}
             .seed-quantity-selector input[type="number"] { width: 40px; font-size: 0.8rem;}
             .total-seed-cost { font-size: 0.8rem; }
             .buy-button, .plant-button, .action-button, .use-button { font-size: 0.8rem; padding: 6px 10px;}
             #message-area { font-size: 0.9rem; padding: 10px 20px; width: auto; max-width: 90%; bottom: 10px; }
             #message-area.show { bottom: 20px; }
             .tooltip { max-width: 180px; font-size: 0.75rem; }
        }

        @media (max-width: 420px) { /* Mobile Nhỏ */
             #stats-bar { gap: 5px; }
             .stat-item { padding: 5px 8px; gap: 5px; font-size: 0.85rem; min-width: 90px; }
             .stat-item span { font-size: 1em; }
             #garden {
                 grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
                 gap: 10px;
                 padding: 10px;
                 /* --- [CẬP NHẬT] --- */
                 max-height: 450px; /* Giảm chiều cao tối đa cho mobile nhỏ */
                 /* --- [HẾT CẬP NHẬT] --- */
            }
             .plot { height: 95px; }
             .plot.locked::before { font-size: 1.6rem; }
             .plant-visual img { max-height: 55%; max-width: 55%; }
             .pest-icon { font-size: 0.8rem; }
             #ui-panel { gap: 8px; padding: 10px 5px; }
             .ui-button { padding: 8px 10px; font-size: 0.8rem; min-width: 80px; }
             .modal-content { margin: 15% auto; padding: 15px; width: 95%; }
             #plant-action-modal .modal-content,
             #empty-plot-action-modal .modal-content { margin: 25% auto; width: 90%; }
             #plant-action-buttons { grid-template-columns: 1fr; } /* Xếp chồng nút */
             /* [CẬP NHẬT] Đảm bảo nút harvest/sell now cũng xếp chồng */
             #plant-action-buttons #action-harvest-plant,
             #plant-action-buttons #action-sell-now {
                 grid-column: 1 / -1; /* Giữ nguyên nếu đã chồng */
             }
             .modal-header h2 { font-size: 1.2rem; }
             .modal-header { padding-bottom: 10px; margin-bottom: 15px; }
             .tabs-container { margin-bottom: 8px; }
             .tab-button { padding: 6px 10px; font-size: 0.8rem; }
             .item-list { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; } /* Điều chỉnh minmax */
             .item-card { padding: 8px; }
             .item-icon { height: 40px; }
             .item-name { font-size: 0.85rem; min-height: 2em; }
             .item-details { font-size: 0.7rem; }
             .item-harvest-value { font-size: 0.7rem;}
             .sell-button { font-size: 0.7rem; padding: 5px 8px; } /* Cập nhật sell-button */
             .sell-quantity-selector input[type="number"] { width: 40px; font-size: 0.75rem;}
             .sell-quantity-selector label { font-size: 0.7rem; }
             .plot-info { font-size: 0.5rem; min-height: 3.2em; }
              .seed-quantity-selector { gap: 3px; }
              .seed-quantity-selector input[type="number"] { width: 35px; font-size: 0.75rem;}
              .total-seed-cost { font-size: 0.75rem; }
              .buy-button, .plant-button, .action-button, .use-button { font-size: 0.75rem; padding: 5px 8px;}
              .tooltip { max-width: 150px; font-size: 0.7rem;}
        }

        /* --- Lớp Tiện Ích --- */
        .hidden {
            display: none;
        }
		/* --- [MỚI] Kiểu nút Bán Hết --- */
        .sell-button.sell-all-button {
            background-color: #e74c3c; /* Màu đỏ */
        }
        .sell-button.sell-all-button:hover:not(:disabled) {
            background-color: #c0392b; /* Màu đỏ đậm hơn khi hover */
        }
        .sell-button.sell-all-button:disabled {
            background-color: #f5b7b1; /* Màu đỏ nhạt khi bị vô hiệu hóa */
             opacity: 0.6;
        }
		
		#dark-overlay {
    display: none; /* Ẩn lớp phủ ban đầu */
    position: fixed; /* Định vị tuyệt đối so với cửa sổ trình duyệt */
    top: 0;
    left: 0;
    width: 100%; /* Chiếm toàn bộ chiều rộng */
    height: 100%; /* Chiếm toàn bộ chiều cao */
    background-color: rgba(0, 0, 80, 0.75); /* Màu xanh dương đen tối (RGB: 0,0,80) với 75% độ mờ đục (25% trong suốt) */
    z-index: 950; /* Đặt cao hơn nội dung game nhưng thấp hơn các modal (modal thường là 1000+) */
    pointer-events: none; /* Cho phép click xuyên qua lớp phủ (quan trọng!) */

    /* Tùy chọn: Thêm hiệu ứng mờ dần khi xuất hiện/ẩn đi */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease, visibility 0s 0.5s;
}

/* Class để hiển thị lớp phủ (dùng với JavaScript) */
#dark-overlay.visible {
    display: block; /* Thay đổi display thành block khi dùng opacity */
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease, visibility 0s;
     /* Nếu bạn MUỐN lớp phủ chặn click khi nó hiển thị, thêm dòng sau: */
     /* pointer-events: auto; */
}
		/* ---  Kiểu cho Hàng Rào Hỏng --- */
.plot-info.broken-fence-info {
    background-color: rgba(100, 0, 0, 0.7) !important; /* Nền đỏ đậm */
    color: white !important;
    font-weight: bold;
    font-style: normal !important;
}

.action-button.remove-broken-fence {
    background-color: #e74c3c; /* Màu đỏ */
}
.action-button.remove-broken-fence:hover:not(:disabled) {
    background-color: #c0392b; /* Đỏ đậm hơn */
}
.action-button.remove-broken-fence:disabled {
    background-color: #f5b7b1; /* Đỏ nhạt */
    opacity: 0.7;
}
/* --- Kết thúc Kiểu Hàng Rào Hỏng --- */
	.fence-health-bar-wrapper { /* Đã thêm style inline, đây là tùy chọn */
    /* Ví dụ: position: absolute; top: 3px; left: 15%; width: 70%; height: 4px; z-index: 3; */
}	
		
		
		
		
		
		
		
		
		
		
    </style>
</head>
<body>

    <!-- Chỉ Báo Tải -->
    <div id="loading-indicator">Đang tải khu vườn... 🌱</div>

    <!-- Container Game Chính -->
    <div id="game-container" class="hidden"> <!-- Bắt đầu ẩn, hiện sau khi tải -->

        <!-- Header -->
        <div id="header">
            <h1>Vườn Cây Hạnh Phúc</h1>
        </div>
		 <!-- ====== KHU VỰC HIỂN THỊ THỜI TIẾT (MỚI) ====== -->
        <div id="weather-section">
             <div id="weather-info">
                 <span id="weather-icon" title="Thời tiết hiện tại">❓</span>
				 <span id="weather-name">---</span>
                 <span id="weather-timer" title="Thời gian còn lại đến khi đổi thời tiết">--:--</span>
             </div>
             <div id="weather-progress-container" class="weather-progress-container"> <!-- Container cho CSS -->
                 <div id="weather-progress-bar" class="weather-progress-bar-fill"></div> <!-- Thanh fill sẽ được cập nhật -->
             </div>
        </div>
        <!-- =============================================== -->

        <!-- Thanh Chỉ Số -->
        <div id="stats-bar">
            <div class="stat-item">💰 Tiền: <span id="currency">0</span></div>
            <div class="stat-item">⏰ Giờ: <span id="game-time">--:--</span></div>
            <div class="stat-item">🏞️ Ô đất: <span id="plot-count">0</span></div> <!-- Chỉ hiển thị số ô đã mở -->
        </div>
		


        <!-- Khu Vườn -->
        <div id="garden">
            <!-- Các ô đất sẽ được tạo và cập nhật bởi JavaScript -->
            <!-- Mỗi ô đất (.plot) sẽ chứa: -->
            <!-- .plant-visual-container -> .plant-visual (chứa img), .pest-icon -->
            <!-- .bars-container -> .health-bar-wrapper (chứa .health-bar-fill), .fertility-bar-wrapper (chứa .fertility-bar-fill) -->
            <!-- .plot-info -->
        </div>

         <!-- Phần Tử Tooltip -->
        <div id="tooltip" class="tooltip">Nội dung tooltip</div>

        <!-- Bảng Điều Khiển UI (Nút Cửa Hàng, Kho) -->
        <div id="ui-panel">
            <button id="open-shop-btn" class="ui-button">🛒 Cửa Hàng</button>
            <button id="open-inventory-btn" class="ui-button">🎒 Túi Đồ</button>
          <!-- <button id="save-game-btn" class="ui-button">💾 Lưu Game</button> -->
		  <button id="open-menu-btn" class="ui-button">☰ Menu</button>
        </div>

    </div> <!-- Kết thúc Container Game -->

<!-- Popup Xác Nhận Bỏ Vật Phẩm Đã Mua -->
    <div id="discard-item-popup" class="modal" style="display: none;">
        <div class="discard-popup-content"> <!-- Class riêng để CSS tùy chỉnh -->
            <span class="close-button" onclick="closeDiscardItemPopup()">×</span>
            <h2>Xác Nhận Bỏ Vật Phẩm</h2>
            <div class="discard-item-info">
                <span id="discard-item-icon" class="item-icon">
                    <img src="" alt="Item Icon" > <!-- src sẽ được set bởi JS -->
                </span>
                <div>
                    <strong id="discard-item-name">Tên Vật Phẩm</strong>
                    <span>Hiện có: <span id="discard-current-quantity">0</span></span>
                </div>
            </div>
            <div class="discard-quantity-section">
                <label for="discard-quantity-input">Số lượng muốn bỏ:</label>
                <input type="number" id="discard-quantity-input" value="1" min="1" max="1" step="1">
                <span id="discard-quantity-error"></span> <!-- Để hiển thị lỗi -->
            </div>
            <div class="popup-buttons">
                <button id="cancel-discard-btn" class="ui-button">Hủy Bỏ</button> <!-- Có thể dùng class ui-button -->
                <button id="confirm-discard-btn" class="ui-button" data-item-id="">Xác Nhận Bỏ</button> <!-- data-item-id sẽ được set bởi JS -->
            </div>
        </div>
    </div>
    <!-- Kết thúc Popup Xác Nhận Bỏ -->





<!-- [MỚI] Popup Xác Nhận Bỏ Vật Phẩm Đã Mua -->
    <div id="discard-item-popup" class="modal" style="display: none;">
        <div class="discard-popup-content"> <!-- Class riêng để CSS tùy chỉnh -->
            <span class="close-button" onclick="closeDiscardItemPopup()">×</span>
            <h2>Xác Nhận Bỏ Vật Phẩm</h2>
            <div class="discard-item-info" style="display: flex; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
                <span id="discard-item-icon" class="item-icon" style="margin-right: 10px; flex-shrink: 0;">
                    <img src="" alt="Item Icon" style="max-width: 40px; max-height: 40px; object-fit: contain;">
                </span>
                <div>
                    <strong id="discard-item-name" style="display: block; margin-bottom: 3px;">Tên Vật Phẩm</strong>
                    <span style="font-size: 0.85em; color: #666;">Hiện có: <span id="discard-current-quantity">0</span></span>
                </div>
            </div>
            <div class="discard-quantity-section" style="margin-bottom: 20px;">
                <label for="discard-quantity-input" style="display: block; margin-bottom: 5px; font-weight: 500;">Số lượng muốn bỏ:</label>
                <input type="number" id="discard-quantity-input" value="1" min="1" max="1" step="1" style="width: 80px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; text-align: center;">
                <span id="discard-quantity-error" style="color: #e74c3c; font-size: 0.8em; margin-left: 10px; display: none;"></span>
            </div>
            <div class="popup-buttons" style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="cancel-discard-btn" class="ui-button" style="background-color: #7f8c8d;">Hủy Bỏ</button>
                <button id="confirm-discard-btn" class="ui-button" style="background-color: #e74c3c;" data-item-id="">Xác Nhận Bỏ</button>
            </div>
        </div>
    </div>
    <!-- Kết thúc Popup Xác Nhận Bỏ -->
	
	<!-- [MỚI] Modal Hành Động Cột Thu Lôi -->
    <div id="lightning-rod-action-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="rod-action-title">⚡ Cột Thu Lôi (Ô X)</h2>
                <span class="close-button" onclick="closeModal('lightning-rod-action-modal'); currentActionPlotId = null;">×</span>
            </div>
            <div id="rod-status-info" style="text-align: center; margin-bottom: 20px; font-size: 1.1em;">
                <!-- Nội dung cập nhật bởi JS -->
                Sức khỏe: <span id="rod-health-display">--/--</span>
            </div>
            <div id="rod-action-buttons" style="display: grid; gap: 15px;">
                <!-- Các nút được thêm động hoặc cập nhật -->
                <button id="action-repair-rod" class="action-button repair-rod" style="background-color:#ff9800;">🔧 Sửa Chữa (--💰)</button>
                <button id="action-remove-rod" class="action-button remove-rod" style="background-color:#e74c3c;">🗑️ Gỡ Bỏ</button>
            </div>
        </div>
    </div>

    <!-- [MỚI] Popup Xác Nhận Sửa Chữa Cột Thu Lôi -->
    <div id="confirm-repair-rod-popup" class="modal confirm-rod-popup"> <!-- Dùng class CSS riêng nếu cần -->
        <link rel="stylesheet" href="style-confirm-cotthuloi.css"> <!-- Liên kết CSS -->
        <div class="popup-content">
             <button class="close-popup-btn" onclick="closeConfirmRepairPopup()" aria-label="Đóng">×</button>
            <h2>Xác Nhận Sửa Chữa</h2>
            <p id="confirm-repair-message">Bạn có chắc muốn sửa cột thu lôi ở ô X với giá Y💰?</p>
            <div class="popup-buttons">
                <button id="cancel-repair-rod-btn">Hủy Bỏ</button>
                <button id="confirm-repair-rod-btn" data-plot-id="">Xác Nhận Sửa</button>
            </div>
        </div>
    </div>

    <!-- [MỚI] Popup Xác Nhận Gỡ Bỏ Cột Thu Lôi -->
    <div id="confirm-remove-rod-popup" class="modal confirm-rod-popup"> <!-- Dùng class CSS riêng nếu cần -->
         <link rel="stylesheet" href="style-cotthuloi-gobo.css"> <!-- Liên kết CSS -->
        <div class="popup-content">
             <button class="close-popup-btn" onclick="closeConfirmRemovePopup()" aria-label="Đóng">×</button>
            <h2>Xác Nhận Gỡ Bỏ</h2>
            <p id="confirm-remove-message">Bạn có chắc muốn gỡ bỏ cột thu lôi ở ô X không? (Không thể hoàn tác)</p>
             <div class="popup-buttons">
                <button id="cancel-remove-rod-btn">Hủy Bỏ</button>
                <button id="confirm-remove-rod-btn" data-plot-id="">Xác Nhận Gỡ</button>
            </div>
        </div>
    </div>
	
	



	<!-- [MỚI] Popup Hạt Ngọc Trời -->
<div id="hat-ngoc-troi-popup" class="modal" style="display: none;"> <!-- Dùng class modal để kế thừa logic đóng -->
    <div class="hat-ngoc-troi-content"> <!-- Class riêng cho CSS tùy chỉnh -->
        <span class="close-button" onclick="closeHatNgocTroiPopup()">×</span> <!-- Nút đóng riêng -->
        <h2>💎 Hạt Ngọc Trời 💎</h2>
        <div class="hat-ngoc-troi-icon">
            <!-- Có thể thêm icon hình ảnh hạt giống ở đây nếu muốn -->
            🌱
        </div>
        <p>Một hạt giống quý hiếm vừa rơi xuống vườn của bạn! Hãy giữ gìn cẩn thận nhé.</p>
        <div class="hat-ngoc-troi-buttons">
            <button onclick="closeHatNgocTroiPopup()">Mở hạt Ngọc Trời</button>
            <!-- Có thể thêm nút khác nếu cần, ví dụ: nhận vào kho -->
        </div>
    </div>
</div>
<!-- Kết thúc Popup Hạt Ngọc Trời -->




    <!-- Modal Cửa Hàng -->
    <div id="shop-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🛒 Cửa Hàng Vật Phẩm</h2>
                <span class="close-button" onclick="closeModal('shop-modal')">×</span>
            </div>
            <!-- Tab Cửa Hàng -->
            <div id="shop-tabs" class="tabs-container"> <!-- Sử dụng class chung -->
                <button class="tab-button shop-tab-button active" data-tab="seeds">Hạt giống 🌱</button>
                <button class="tab-button shop-tab-button" data-tab="tools">Phân Bón & Thuốc 💊</button>
            </div>
            <!-- Danh sách Vật Phẩm (Hạt giống) -->
            <div id="shop-seed-list" class="item-list active-list">
                <p id="shop-seeds-empty-message" class="hidden" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Không có hạt giống nào.</p>
            </div>
             <!-- Danh sách Vật Phẩm (Công cụ - Giờ là Phân Bón & Thuốc trừ sâu) -->
            <div id="shop-tool-list" class="item-list">
                 <p id="shop-tools-empty-message" class="hidden" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Không có vật phẩm nào.</p>
            </div>
        </div>
    </div>

    <!-- Modal Kho Đồ -->
    <div id="inventory-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="inventory-modal-title">🎒 Túi Đồ Của Bạn</h2>
                <span class="close-button" onclick="closeModal('inventory-modal')">×</span>
            </div>
            <!-- Tab Kho Đồ -->
            <div id="inventory-tabs" class="tabs-container">
                <button class="tab-button inventory-tab-button active" data-tab="harvested">Đã Thu Hoạch 🧺</button>
                <button class="tab-button inventory-tab-button" data-tab="purchased">Đã Mua 🛒</button>
            </div>
            <!-- Danh sách Vật Phẩm Đã Thu Hoạch -->
            <div id="inventory-harvested-list" class="item-list active-list">
                <p id="inventory-harvested-empty-message" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Chưa thu hoạch được gì...</p>
            </div>
            <!-- Danh sách Vật Phẩm Đã Mua -->
            <div id="inventory-purchased-list" class="item-list">
                 <p id="inventory-purchased-empty-message" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Chưa mua vật phẩm nào...</p>
            </div>
        </div>
    </div>

     <!-- Modal Chọn Hạt Giống -->
    <div id="seed-selection-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🌱 Chọn Hạt Giống Để Trồng</h2>
                 <span class="close-button" onclick="closeModal('seed-selection-modal'); currentPlantingPlotId = null;">×</span>
            </div>
            <div id="seed-selection-list" class="item-list active-list">
                <p id="seed-selection-empty-message" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Bạn không có hạt giống nào (trong kho đồ đã mua) để trồng.</p>
            </div>
        </div>
    </div>

    <!-- Modal Chọn Phân Bón -->
    <div id="fertilizer-selection-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>💩 Chọn Phân Bón Để Sử Dụng</h2>
                 <span class="close-button" onclick="closeModal('fertilizer-selection-modal'); currentActionPlotId = null;">×</span>
            </div>
            <div id="fertilizer-selection-list" class="item-list active-list">
                <p id="fertilizer-selection-empty-message" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Bạn không có phân bón nào (trong kho đồ đã mua).</p>
            </div>
        </div>
    </div>

    <!-- Modal Hành Động Cây Trồng -->
    <div id="plant-action-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="plant-action-title">Chăm Sóc Cây Trồng</h2>
                 <span class="close-button" onclick="closeModal('plant-action-modal'); currentActionPlotId = null;">×</span>
            </div>
            <div id="plant-action-buttons">
                <!-- Các nút được thêm động hoặc cập nhật -->
                <!-- Nút thu hoạch & Bán ngay được thêm động LÊN TRÊN nếu có -->
                <button id="action-treat-pest" class="action-button treat-pest">💊 Trừ Sâu</button>
                <button id="action-select-fertilizer" class="action-button select-fertilizer">💩 Bón Phân</button>
                <button id="action-clear-plant" class="action-button clear-plant">⛏️ Xới Đất (Bỏ)</button>
            </div>
            <p id="plant-action-info" style="text-align: center; color: #666; margin-top: 15px; font-size: 0.85rem;"></p>
        </div>
    </div>

    <!-- Modal Hành Động Ô Đất Trống -->
    <div id="empty-plot-action-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="empty-plot-action-title">Ô Đất Trống</h2>
                 <span class="close-button" onclick="closeModal('empty-plot-action-modal'); currentActionPlotId = null;">×</span>
            </div>
            <div id="empty-plot-action-buttons">
                <!-- Các nút hành động cho ô trống sẽ được thêm vào đây bằng JS -->
            </div>
             <p id="empty-plot-action-info" style="text-align: center; color: #666; margin-top: 15px; font-size: 0.85rem;"></p>
        </div>
    </div>


    <!-- Khu Vực Tin Nhắn -->
    <div id="message-area">Tin nhắn mẫu</div>
	<div id="locked-plot-popup" class="modal" style="display: none;"> <!-- Thêm class modal để có thể đóng bằng Escape -->
        <div class="popup-content">
            <button class="close-popup-btn" aria-label="Đóng">×</button>
            <h2>Mở Khóa Ô Đất</h2>
            <p id="locked-plot-message">Bạn có chắc muốn mở khóa ô đất này với giá ...💰?</p>
            <div class="popup-buttons">
                <button id="cancel-buy-plot-btn">Hủy Bỏ</button>
                <button id="confirm-buy-plot-btn">Mua Ngay</button>
            </div>
        </div>
    </div>
	
	<div id="confirm-sell-all-modal" class="modal confirm-sell-all-modal" style="display: none;"> <!-- Thêm class tùy chỉnh -->
        <div class="modal-content confirm-sell-all-content"> <!-- Thêm class tùy chỉnh -->
            <div class="modal-header">
                <h2>Xác Nhận Bán Hết</h2>
                <span class="close-button" onclick="closeConfirmSellAllModal()">×</span>
            </div>
            <div id="confirm-sell-all-details" style="margin-bottom: 20px; line-height: 1.6;">
                <p>Bạn có chắc muốn bán hết <strong id="confirm-sell-item-name"></strong>?</p>
                <p>Số lượng: <span id="confirm-sell-quantity"></span></p>
                <p>Tổng tiền nhận được: <strong id="confirm-sell-total-value" style="color: #d4af37;"></strong>💰</p>
            </div>
            <div class="popup-buttons" style="display: flex; justify-content: flex-end; gap: 10px;"> <!-- Tái sử dụng class hoặc tạo class mới -->
                <button id="cancel-sell-all-btn" class="ui-button" style="background-color: #7f8c8d;">Hủy Bỏ</button>
                <button id="confirm-sell-all-btn" class="ui-button" style="background-color: #e74c3c;">Xác Nhận Bán</button>
            </div>
        </div>
    </div>
	
	<!--  Popup Xác Nhận Khôi Phục Game -->
    <div id="popup-confirm-restoregame" class="modal" style="display: none;">
        <!-- Liên kết CSS riêng nếu chưa có trong <head> -->
        <!-- <link rel="stylesheet" href="style-popup-confirm-restoregame.css"> -->
        <div class="restore-popup-content"> <!-- Class riêng cho styling -->
            <span class="close-button" aria-label="Đóng">×</span>
            <h2>Xác Nhận Khôi Phục</h2>
            <p id="restore-confirm-message">
                Bạn có chắc chắn muốn khôi phục tiến trình chơi từ tệp đã chọn không? <br>
                <strong>Toàn bộ tiến trình hiện tại CHƯA LƯU sẽ bị mất vĩnh viễn.</strong>
            </p>
            <div class="popup-buttons">
                <button id="cancel-restore-btn">Hủy Bỏ</button>
                <button id="confirm-restore-btn">Xác Nhận Khôi Phục</button>
            </div>
        </div>
    </div>
    <!-- Kết thúc Popup Xác Nhận Khôi Phục Game -->
	
	
	 <!-- Popup Menu Chính -->
    <div id="menu-popup" class="modal" style="display: none;"> <!-- Dùng class modal để kế thừa logic đóng -->
        <div class="menu-popup-content"> <!-- Class riêng cho CSS tùy chỉnh -->
            <span class="close-button" onclick="closeMenuPopup()">×</span> <!-- Nút đóng riêng -->
            <h2>Menu Chính</h2>
            <div class="menu-buttons">
                
                <!-- Thêm các nút menu khác vào đây nếu cần -->
				<button id="planting-history-btn" class="menu-action-button">📜 Lịch sử trồng cây</button>
				<button id="toggle-sound-btn" class="menu-action-button">🔊 Bật Âm Thanh</button>
				<button id="toggle-effects-sound-btn" class="menu-action-button">🔊 Bật Âm Thanh Hiệu Ứng</button>
				<button id="btn-nhiemvuhangngay" class="menu-action-button" style="background-color: #8B4513;">📅 Nhiệm vụ hằng ngày</button>
              
				<button id="export-import-data-btn" class="menu-action-button" style="background-color: #2196F3;">💾 Xuất/Nhập dữ liệu game</button>
            
			</div>
        </div>
    </div>
	
	<!--  Popup Nhiệm Vụ Hằng Ngày -->
    <div id="daily-quest-popup" class="modal" style="display: none;">
        <!-- Liên kết đến tệp CSS riêng cho popup này -->
        <link rel="stylesheet" href="style-nhiemvuhangngay-popup.css">
        <div class="daily-quest-popup-content"> <!-- Class riêng cho styling -->
            <span class="close-button" onclick="closeModal('daily-quest-popup')" aria-label="Đóng">×</span>
            <h2>📅 Nhiệm vụ Hằng Ngày</h2>
            <div id="daily-quest-list">
                <!-- Nội dung nhiệm vụ sẽ được thêm vào đây bằng JavaScript hoặc HTML tĩnh -->
                <p style="text-align: center; padding: 20px; color: #666;">
                    Hiện chưa có nhiệm vụ nào.<br>
                    (Tính năng đang được phát triển!)
                </p>
            </div>
            <!-- Có thể thêm các nút khác ở đây nếu cần -->
        </div>
    </div>
    <!-- Kết thúc Popup Nhiệm Vụ Hằng Ngày -->
	
	
	
	<!-- [MỚI] Popup Phần Thưởng Hạt Ngọc Trời -->
    <div id="hat-ngoc-troi-reward-popup" class="modal reward-popup" style="display: none;">
        <div class="reward-popup-content">
            <!-- Nút đóng nếu muốn, hoặc chỉ dùng nút xác nhận -->
            <!-- <span class="close-button" onclick="closeRewardPopup()">×</span> -->
            <h2>🌟 Phần Thưởng Hạt Ngọc Trời! 🌟</h2>
            <p>Bạn đã nhận được một món quà bất ngờ:</p>
            <div class="reward-item-display">
                <span class="reward-item-icon" id="reward-item-icon">
                    <img id="reward-item-image" src="" alt="Phần thưởng" style="max-width: 60px; max-height: 60px; object-fit: contain;">
                </span>
                <strong id="reward-item-name">Tên vật phẩm</strong>
            </div>
            <p style="font-size: 0.9em; color: #555;">Vật phẩm đã được thêm vào kho "Đã Mua".</p>
            <div class="reward-popup-buttons">
                <button id="confirm-reward-btn">Tuyệt vời!</button>
            </div>
        </div>
    </div>
    <!-- Kết thúc Popup Phần Thưởng -->

	<div id="dark-overlay"></div>
	
	<!-- Popup Lưu/Nhập Game -->
<div id="menu-savegame-popup" class="modal" style="display: none;">
    <!-- Liên kết đến tệp CSS riêng cho popup này -->
    <link rel="stylesheet" href="style-savegame-popup-selectmenu.css">
    <div class="savegame-popup-content"> <!-- Class riêng cho styling -->
        <!-- Nút đóng popup -->
        <span class="close-button" onclick="closeSavegamePopup()">×</span>
        <h2>Xuất / Nhập Tiến Trình</h2>
        <div class="savegame-buttons">
            <!-- Nút Lưu -->
            <button id="btn-savegame" class="savegame-action-button">💾 Lưu tiến trình trò chơi</button>
            <!-- Nút Nhập -->
            <button id="btn-import-savegame" class="savegame-action-button">📥 Nhập tiến trình chơi</button>
        </div>
    </div>
</div>
<!-- Kết thúc Popup Lưu/Nhập Game -->




	
	 <!-- <<< THÊM THẺ AUDIO TẠI ĐÂY >>> -->
    <audio id="background-music" loop preload="auto">
        <source src="nhacnen.mp3" type="audio/mpeg">
        Trình duyệt của bạn không hỗ trợ phát âm thanh.
    </audio>
	<audio id="lightning-sound" preload="auto">
        <source src="Amthanh/tiengsamset.mp3" type="audio/mpeg">
        Trình duyệt của bạn không hỗ trợ phát âm thanh.
    </audio>
	<audio id="rain-sound" loop preload="auto">
    <source src="Amthanh/tiengmuaroi.mp3" type="audio/mpeg">
    Trình duyệt của bạn không hỗ trợ phát âm thanh.
	</audio>
	 <audio id="rainy-sunny-sound" loop preload="auto">
        <source src="Amthanh/tiengmuanang.mp3" type="audio/mpeg">
        Trình duyệt của bạn không hỗ trợ phát âm thanh.
    </audio>
    <!-- <<< KẾT THÚC THẺ AUDIO >>> -->



    <!-- JavaScript -->
    <script>
      // --- Hằng Số và Cấu Hình ---
	  // --- [MỚI] Cấu hình Nhiệm Vụ Hằng Ngày ---
    const QUEST_TYPES = {
        PLANT_SPECIFIC: 'plant_specific', // Trồng loại cây cụ thể
        PLANT_ANY: 'plant_any',           // Trồng bất kỳ loại cây nào
        HARVEST_SPECIFIC: 'harvest_specific', // Thu hoạch loại cây cụ thể
        HARVEST_ANY: 'harvest_any',         // Thu hoạch bất kỳ loại cây nào
        SELL_DIRECT_SPECIFIC: 'sell_direct_specific', // Bán trực tiếp loại cây cụ thể
        SELL_HARVESTED_SPECIFIC: 'sell_harvested_specific', // Bán từ kho loại cây cụ thể
        USE_FERTILIZER_TYPE: 'use_fertilizer_type', // Sử dụng loại phân bón cụ thể (basic, growth, premium...)
        BUY_FERTILIZER: 'buy_fertilizer', // Mua phân bón bất kỳ
        BUY_SEED: 'buy_seed',           // Mua hạt giống bất kỳ
        EARN_CURRENCY: 'earn_currency'      // Kiếm được một lượng tiền nhất định (từ bán hàng)
    };

    const QUEST_CONFIG = {
        // Cấu hình chi tiết cho từng loại quest
        [QUEST_TYPES.PLANT_SPECIFIC]: { minQty: 3, maxQty: 8, baseReward: 5 },
        [QUEST_TYPES.PLANT_ANY]: { minQty: 5, maxQty: 10, baseReward: 3 },
        [QUEST_TYPES.HARVEST_SPECIFIC]: { minQty: 4, maxQty: 10, baseReward: 6 },
        [QUEST_TYPES.HARVEST_ANY]: { minQty: 6, maxQty: 12, baseReward: 4 },
        [QUEST_TYPES.SELL_DIRECT_SPECIFIC]: { minQty: 2, maxQty: 5, baseReward: 7 },
        [QUEST_TYPES.SELL_HARVESTED_SPECIFIC]: { minQty: 5, maxQty: 15, baseReward: 8 },
        [QUEST_TYPES.USE_FERTILIZER_TYPE]: { minQty: 1, maxQty: 3, baseReward: 10 },
        [QUEST_TYPES.BUY_FERTILIZER]: { minQty: 1, maxQty: 3, baseReward: 4 },
        [QUEST_TYPES.BUY_SEED]: { minQty: 3, maxQty: 8, baseReward: 2 },
        [QUEST_TYPES.EARN_CURRENCY]: { minQty: 50, maxQty: 200, baseReward: 15 }
    };

    const NUM_DAILY_QUESTS = 10; // Số lượng nhiệm vụ mỗi ngày
	  
	  
	  
	   const LIGHTNING_ROD_MAX_HEALTH = 20; // Số lần chịu sét tối đa
      const LIGHTNING_ROD_INITIAL_REPAIR_COST = 300; // Phí sửa lần đầu
      const LIGHTNING_ROD_REPAIR_COST_MULTIPLIER = 1.3; // Hệ số nhân phí sửa
      const LIGHTNING_ROD_PROTECTION_RANGE = 4; // Số ô bảo vệ mỗi bên (tổng 4+1+4 = 9 ô)
      const LIGHTNING_ROD_ITEM_ID = 'cotthuloi'; // ID vật phẩm cột thu lôi

	  const INITIAL_MAX_INVENTORY_CAPACITY = 50; // <<< GIỚI HẠN MỚI CHO TỔNG SỐ LƯỢNG KHO ĐỒ
      
               const DRY_HEALTH_DRAIN_PER_TICK = 0.3; // Lượng máu cây mất mỗi giây khi khô (có thể điều chỉnh)
        const DRY_FERTILITY_DRAIN_PER_TICK = 0.02; // Lượng % phì nhiêu đất trống mất mỗi giây khi khô (0.02% = 1.2%/phút)
		// Cấu hình Sét Đánh (Thunderstorm - CÓ SÁT THƯƠNG)
const THUNDERSTORM_STRIKE_CHANCE_PER_TICK = 0.03; // 3% mỗi giây KHI CÓ MƯA SÉT
const STRIKE_DURATION_MS = 1000;   // 2 giây hiệu ứng
const PLANT_HEALTH_DAMAGE = 40;    // Sát thương máu cây (Thunderstorm)
const SOIL_FERTILITY_DAMAGE = 20;  // Sát thương độ phì đất trống (Thunderstorm)
	  // [MỚI] Cấu hình Sét Đánh Hình Ảnh (Lightning - KHÔNG SÁT THƯƠNG)
const LIGHTNING_VISUAL_STRIKE_CHANCE_PER_TICK = 0.025; // 2.5% mỗi giây KHI CHỈ CÓ SÉT (có thể chỉnh)
 const LIGHTNING_PLANT_DAMAGE = 30; // <<< THÊM: Sát thương máu cây (Lightning) >>>
        const LIGHTNING_SOIL_DAMAGE = 20;  // <<< THÊM: Sát thương độ phì đất trống (Lightning) >>>
		
		
		// Định nghĩa khoảng thời gian ngẫu nhiên cho Hạt Ngọc Trời
		const MIN_HAT_NGOC_TROI_DELAY_MS = 3 * 60 * 1000; // 3 phút
      const MAX_HAT_NGOC_TROI_DELAY_MS = 10 * 60 * 1000; // 10 phút

		// Cấu hình Gió Lốc (Windy) - ĐÃ CẬP NHẬT TÊN
const TORNADO_EVENT_MIN_INTERVAL_MS_WINDY = 120 * 1000; // Ít nhất 120 giây (2 phút) <<< SỬA LỖI MIN/MAX
        const TORNADO_EVENT_MAX_INTERVAL_MS_WINDY = 180 * 1000; // Nhiều nhất 180 giây (3 phút) <<< SỬA LỖI MIN/MAX
        const TORNADO_EFFECT_DURATION_MS_WINDY = 8 * 1000;       // Thời gian hiệu ứng hình ảnh VÀ gây sát thương: 8 giây <<< TĂNG THỜI GIAN
        const TORNADO_DESTRUCTION_CHANCE = 0.25;                 // 25% khả năng phá hủy hoàn toàn (100% damage) <<< XÁC SUẤT MỚI
        const TORNADO_PARTIAL_DAMAGE_FACTOR = 0.80;              // 80% sát thương nếu không bị phá hủy hoàn toàn <<< SÁT THƯƠNG MỘT PHẦN


        // ============================
		// --- Hằng Số Chất Lượng Thu Hoạch ---
const QUALITY_TIERS = {
    PERFECT: 'perfect', // 95-100% HP
    GOOD: 'good',       // 70-94% HP
    FAIR: 'fair',       // 30-69% HP
    POOR: 'poor'        // 1-29% HP
};

const QUALITY_THRESHOLDS = {
    [QUALITY_TIERS.PERFECT]: 95,
    [QUALITY_TIERS.GOOD]: 70,
    [QUALITY_TIERS.FAIR]: 30,
    [QUALITY_TIERS.POOR]: 1 // Chỉ cần > 0
};

const QUALITY_VALUE_MULTIPLIERS = {
    [QUALITY_TIERS.PERFECT]: 1.0,
    [QUALITY_TIERS.GOOD]: 0.85, // Điều chỉnh nếu muốn (VD: 0.85)
    [QUALITY_TIERS.FAIR]: 0.65,  // Điều chỉnh nếu muốn (VD: 0.65)
    [QUALITY_TIERS.POOR]: 0.4   // Điều chỉnh nếu muốn (VD: 0.4)
};

const QUALITY_DISPLAY_NAMES = {
    [QUALITY_TIERS.PERFECT]: '✨Hoàn hảo',
    [QUALITY_TIERS.GOOD]: '👍Tốt',
    [QUALITY_TIERS.FAIR]: '👌Thường',
    [QUALITY_TIERS.POOR]: '❌Kém'
};
// --- Kết thúc Hằng Số Chất Lượng ---
		
		
		
		
		
		
		
		// Định nghĩa dữ liệu thời tiết với ID, icon và tên
const WEATHER_DATA = [
    { id: 'sunny',       icon: '☀️', name: 'Nắng gắt' },
    { id: 'rainy',       icon: '🌧️', name: 'Có mưa' },
    { id: 'thunderstorm',icon: '⛈️', name: 'Mưa và sấm sét' },
    { id: 'rainy_sunny', icon: '🌦️', name: 'Có mưa và nắng' },
    { id: 'lightning',   icon: '🌩️', name: 'Có sấm sét' },
    { id: 'cloudy',      icon: '☁️', name: 'Có mây' },
    { id: 'windy',       icon: '🌪️', name: 'Có gió lốc' } // Giả sử icon cuối là gió lốc/tornado
];
		// Cấu hình Gió Lốc (Windy)
const TORNADO_EVENT_MIN_INTERVAL_MS = 60 * 1000; // 60 giây
const TORNADO_EVENT_MAX_INTERVAL_MS = 120 * 1000; // 120 giây
const TORNADO_MIN_DURATION_MS = 5 * 1000;       // 5 giây
const TORNADO_MAX_DURATION_MS = 10 * 1000;      // 10 giây
const TORNADO_MAX_SPAWN_COUNT = 2;              // Số lượng lốc tối đa xuất hiện mỗi lần
const TORNADO_HEALTH_DAMAGE_PER_TICK = 0.05;    // 5% máu cây mỗi giây
const TORNADO_FERTILITY_DAMAGE_PER_TICK = 0.05; // 5% độ phì đất trống mỗi giây
		
		
		
		
		
		
		 const WEATHER_CHANGE_INTERVAL_MS = 5 * 60 * 1000; // 5 phút (300,000 ms)
       const WEATHER_ICONS = ['☀️ Nắng gắt', '🌧️ Có mưa', '⛈️ Mưa và sấm sét', '🌦️ Có mưa và nắng', '🌩️ Có sấm sét', '☁️ Có mây', '🌪️']; // [PHIÊN BẢN CẬP NHẬT V9.3 - Random Pest Per Plot (Online/Offline)]
        console.log("Đang tải Script Vườn Cây (v9.3 - Random Pest)...");

        // Cấu hình Game
        const INITIAL_PLOT_COUNT = 6;       // Số ô bắt đầu
        const INITIAL_CURRENCY = 10;        // Tiền khởi điểm
        const BASE_PLOT_COST_FOR_7TH = 300;         // Giá ô đất thứ 7 (index 6)
		
        const PLOT_COST_MULTIPLIER = 2;     // Hệ số nhân giá ô đất tiếp theo (GẤP ĐÔI)
        const INITIAL_PESTICIDE = 1;        // Số thuốc trừ sâu ban đầu
        const INITIAL_PLANT_HEALTH = 100;   // Máu cây tối đa
        const BASE_FERTILITY = 100;         // Độ phì nhiêu đất tối đa %
        const LOW_FERTILITY_THRESHOLD = 25; // Dưới mức này, hiện cảnh báo UI (thanh bar)
        const BARREN_HARVEST_PENALTY_MULTIPLIER = 1.3; // Hệ số nhân thời gian khi thu hoạch trên đất cằn
        const GAME_SAVE_KEY = 'vuonCayHanhPhuc_v9.3_RandomPest'; // <<<KHÓA LƯU
        const TICK_INTERVAL = 1000;         // 1 giây một tick (1000ms)
        const PLANT_GROWTH_STAGES = 4;      // Số giai đoạn hình ảnh cây
        const MESSAGE_DISPLAY_TIME = 3800;  // Thời gian hiển thị tin nhắn (ms)
        const TOOLTIP_DELAY = 350;          // Độ trễ hiển thị tooltip (ms)
        const AUTO_SAVE_INTERVAL_TICKS = 60;// Tự động lưu mỗi 60 tick (60 giây)
        const HEALTH_REGEN_PER_TICK = 0.2;  // Lượng máu hồi mỗi tick
        const DEAD_PEST_CLEANUP_COST = 2;  // Phí dọn cây chết do sâu
        const DEAD_PEST_FREE_CLEANUP_CLICKS = 20; // Số lần click để dọn miễn phí
        const PEST_DAMAGE_PER_TICK = 0.5;   // Sát thương sâu mỗi tick (cho cây đang lớn)
        const PEST_DAMAGE_MATURE_REDUCTION_FACTOR = 0.5; // Hệ số giảm sát thương sâu cho cây trưởng thành
        const HISTORY_SAVE_KEY = 'vuonCayHanhPhuc_v9.3_History'; // Cập nhật cả khóa lịch sử nếu muốn tách biệt
		const MAX_HISTORY_ENTRIES = 150; // Giới hạn số lượng mục lịch sử
		const MUSIC_ENABLED_KEY = 'vuonCayHanhPhuc_v9.3_musicEnabled'; // <<< KHÓA LƯU TRẠNG THÁI NHẠC NỀN
		
const EFFECTS_ENABLED_KEY = 'vuonCayHanhPhuc_v9.3_effectsEnabled' // <<< KHÓA LƯU TRẠNG THÁI HIỆU ỨNG
        // --- [MỚI Req - Random Pest] Cấu hình Sâu Bệnh Ngẫu Nhiên ---
        const PEST_APPEARANCE_CHANCE_PER_TICK_PER_PLOT = 0.0002; // Tỉ lệ sâu xuất hiện mỗi giây TRÊN MỖI Ô ĐẤT HỢP LỆ (0.02%) - Cần điều chỉnh!
        const FERTILIZER_GROWTH_MAX_USES = 3; // Giới hạn sử dụng Phân Bón Tăng Trưởng mỗi cây
		

        // --- Dữ Liệu Vật Phẩm (Hạt Giống & Phân Bón) ---
        // =======================================================================
        // (Giữ nguyên như v9.2, không cần thay đổi ITEM_DATA cho yêu cầu này)
       const ITEM_DATA = {
            // Hạt giống (id, type, name, imageFolder, price, harvestYield(GIÁ TRỊ BÁN MỖI ĐƠN VỊ!), growthTime(giây!), fertilityCost(0-1!))
            'hanhla':   { id: 'hanhla', type: 'seed', name: 'Hành lá', imageFolder: 'Hanhla', price: 1, harvestYield: 2, growthTime: 60, fertilityCost: 0.05 },         // 1p, PPM 1.00, Hao 5% (Giữ nguyên)
            'namrom':   { id: 'namrom', type: 'seed', name: 'Nấm rơm', imageFolder: 'Namrom', price: 3, harvestYield: 6, growthTime: 60, fertilityCost: 0.05 },         // 1p, PPM 3.00, Hao 5% (Giữ nguyên)
            'raumuong': { id: 'raumuong', type: 'seed', name: 'Rau muống', imageFolder: 'Raumuong', price: 1, harvestYield: 4, growthTime: 120, fertilityCost: 0.06 }, // 2p, PPM 1.50, Hao 6% (Tăng yield)
            'caithia':  { id: 'caithia', type: 'seed', name: 'Cải thìa', imageFolder: 'Caithia', price: 1, harvestYield: 4, growthTime: 120, fertilityCost: 0.07 },     // 2p, PPM 1.50, Hao 7% (Giữ nguyên)
            'dualeo':   { id: 'dualeo', type: 'seed', name: 'Dưa leo', imageFolder: 'Dualeo', price: 2, harvestYield: 5, growthTime: 120, fertilityCost: 0.08 },       // 2p, PPM 1.50, Hao 8% (Giữ nguyên)
            'carot':    { id: 'carot', type: 'seed', name: 'Cà rốt', imageFolder: 'Carot', price: 1, harvestYield: 5, growthTime: 180, fertilityCost: 0.09 },         // 3p, PPM 1.33, Hao 9% (Giữ nguyên)
            'cachua':   { id: 'cachua', type: 'seed', name: 'Cà chua', imageFolder: 'Cachua', price: 1, harvestYield: 6, growthTime: 180, fertilityCost: 0.04 },     // 3p, PPM 1.67, Hao 4% (Tăng mạnh yield)
            'bapcai':   { id: 'bapcai', type: 'seed', name: 'Bắp cải', imageFolder: 'Bapcai', price: 2, harvestYield: 6, growthTime: 180, fertilityCost: 0.08 },       // 3p, PPM 1.33, Hao 8% (Giữ nguyên)
            'bap':      { id: 'bap', type: 'seed', name: 'Bắp (Ngô)', imageFolder: 'Bap', price: 4, harvestYield: 8, growthTime: 180, fertilityCost: 0.09 },         // 3p, PPM 1.33, Hao 9% (Giữ nguyên)
            'hanhtay':  { id: 'hanhtay', type: 'seed', name: 'Hành tây', imageFolder: 'Hanhtay', price: 5, harvestYield: 9, growthTime: 180, fertilityCost: 0.08 }, // 3p, PPM 1.33, Hao 8% (Tăng nhẹ hao đất)
            'bido':     { id: 'bido', type: 'seed', name: 'Bí đỏ', imageFolder: 'Bido', price: 5, harvestYield: 9, growthTime: 180, fertilityCost: 0.08 },         // 3p, PPM 1.33, Hao 8% (Giữ nguyên)
            'khoaitay': { id: 'khoaitay', type: 'seed', name: 'Khoai tây', imageFolder: 'Khoaitay', price: 2, harvestYield: 6, growthTime: 180, fertilityCost: 0.08 }, // 3p, PPM 1.33, Hao 8% (Tăng nhẹ hao đất)
            'toi':      { id: 'toi', type: 'seed', name: 'Tỏi', imageFolder: 'Toi', price: 3, harvestYield: 7, growthTime: 180, fertilityCost: 0.09 },             // 3p, PPM 1.33, Hao 9% (Giữ nguyên)
            'khoailang':{ id: 'khoailang', type: 'seed', name: 'Khoai lang', imageFolder: 'Khoailang', price: 5, harvestYield: 9, growthTime: 180, fertilityCost: 0.08 }, // 3p, PPM 1.33, Hao 8% (Giữ nguyên)
            'suplo':    { id: 'suplo', type: 'seed', name: 'Súp lơ', imageFolder: 'Suplo', price: 10, harvestYield: 20, growthTime: 240, fertilityCost: 0.10 },      // 4p, PPM 2.50, Hao 10% (Giữ nguyên)
            'othiem':   { id: 'othiem', type: 'seed', name: 'Ớt hiểm', imageFolder: 'Othiem', price: 3, harvestYield: 11, growthTime: 240, fertilityCost: 0.08 },    // 4p, PPM 2.00, Hao 8% (Tăng yield)
            'dudu':     { id: 'dudu', type: 'seed', name: 'Đu đủ', imageFolder: 'Dudu', price: 3, harvestYield: 18, growthTime: 360, fertilityCost: 0.11 },      // 6p, PPM 2.50, Hao 11% (Tăng mạnh yield)
            'chuoi':    { id: 'chuoi', type: 'seed', name: 'Chuối', imageFolder: 'Chuoi', price: 4, harvestYield: 28, growthTime: 540, fertilityCost: 0.12 },      // 9p, PPM 2.67, Hao 12% (Tăng cực mạnh yield)
            'mangtay':  { id: 'mangtay', type: 'seed', name: 'Măng tây', imageFolder: 'Mangtay', price: 12, harvestYield: 33, growthTime: 720, fertilityCost: 0.15 }, // 12p, PPM 1.75, Hao 15% (Tăng nhẹ yield)

             // Công cụ (Thuốc trừ sâu + Phân Bón + Cột thu lôi) - Giữ nguyên
             'pesticide': {
                id: 'pesticide', type: 'tool', name: 'Thuốc Trừ Sâu',
                imageFolder: 'Hinhanh/Thuoctrusau', imageFile: 'Thuoctrusau1.png',
                price: 2,
                description: 'Loại bỏ sâu bệnh khỏi một cây trồng.'
             },
            'fertilizer_basic': {
                id: 'fertilizer_basic', type: 'tool', name: 'Phân Bón Cơ Bản', imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanboncoban.png',
                price: 2,
                fertilityBoost: 0.20, description: 'Bổ sung 20% độ phì nhiêu cho đất.'
            },
            'fertilizer_growth': {
                id: 'fertilizer_growth', type: 'tool', name: 'Phân Bón Tăng Trưởng',
                imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanbontangtruong.png',
                // price: 20, // Giá cũ
                price: 15, // <<< GIÁ MỚI
                // fertilityBoost: 0.30, // <<< XÓA BỎ
                growthTimeReductionPercent: 0.05, // <<< THÊM: Giảm 5% thời gian còn lại
                healthBoostPercent: 0.20, // <<< THÊM: Tăng 20% máu (so với max)
                usageLimitPerPlant: 3, // <<< THÊM: Giới hạn sử dụng
                // description: 'Bổ sung 30% độ phì nhiêu cho đất.' // Mô tả cũ
                description: 'Giảm 5% thời gian phát triển còn lại và tăng 20% sức kho cây (Tối đa 3 lần/cây).' // <<< MÔ TẢ MỚI
            },
			
			
			
			
			
			
           'fertilizer_protect': {
                id: 'fertilizer_protect', type: 'tool', name: 'Phân Bón Bảo Vệ',
                imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanbonbaove.png',
                // --- THAY ĐỔI ---
                price: 30, // Giá mới
                fertilityBoost: 0.20, // 20% độ phì
                pestProtectionFactor: 0.5, // <<< THÊM: Giảm 50% tỉ lệ sâu xuất hiện (giá trị 0.5)
                usageLimitPerPlant: 3,     // <<< THÊM: Giới hạn 3 lần/cây
                description: 'Bổ sung 20% độ phì & giảm tỉ lệ sâu bệnh (Tối đa 3 lần/cây).' // <<< MÔ TẢ MỚI (Tiếng Việt)
                
            },
            'fertilizer_premium': {
                id: 'fertilizer_premium', type: 'tool', name: 'Phân Bón Cao Cấp', imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanboncaocap.png',
                price: 40, fertilityBoost: 0.60, description: 'Bổ sung 60% độ phì nhiêu cho đất.'
            },
            'fertilizer_special': {
                id: 'fertilizer_special', type: 'tool', name: 'Phân Bón Đặc Biệt', imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanbondacbiet.png',
                price: 60, fertilityBoost: 0.80, description: 'Bổ sung 80% độ phì nhiêu cho đất.'
            },
			 // --- Thêm Cột Thu Lôi ---
            'cotthuloi': {
                id: 'cotthuloi', type: 'tool', name: 'Cột thu lôi',
                imageFolder: 'Hinhanh', // Thư mục chứa ảnh
                imageFile: 'pic_cotthuloi.png', // Tên file ảnh
                price: 2000,
                description: 'Giảm thiểu tác hại của sét đánh vào vườn.' // Mô tả chức năng (hiện tại chỉ để hiển thị)
            },
			 // ---  Thêm Rào Bảo Vệ ---
            'raobaove': {
                id: 'raobaove', type: 'tool', name: 'Rào bảo vệ',
                imageFolder: 'Hinhanh',         // Thư mục chứa ảnh
                imageFile: 'pic_hangrao.png',    // Ảnh hàng rào bình thường
                brokenImageFile: 'pic_hangrao_bihong.png', // Ảnh hàng rào hỏng
                price: 40,                     // Giá bán
                health: 100,                    // Sức khỏe ban đầu (max health)
                removeCost: 5,                  // Phí gỡ bỏ khi hỏng
                description: 'Bảo vệ cây khỏi gió lốc. Có thể bị hỏng và cần gỡ bỏ.' // Mô tả
            },
			// --- Thêm Vật Phẩm Nâng Cấp Kho Đồ ---
    'Balocaocap': {
        id: 'Balocaocap', type: 'upgrade', name: 'Balo cao cấp',
        imageFolder: 'Hinhanh', imageFile: 'pic_balo_200.png',
        price: 300,
        upgradeCapacity: { from: 50, to: 200 }, // Nâng từ 50 lên 200
        description: 'Mở rộng kho đồ của bạn lên 200 chỗ.'
    },
    'Nhakholv1': {
        id: 'Nhakholv1', type: 'upgrade', name: 'Nhà kho level 1',
        imageFolder: 'Hinhanh', imageFile: 'pic_nangcapnongtrai.png',
        price: 5000,
        upgradeCapacity: { from: 200, to: 2000 }, // Nâng từ 200 lên 2000
        description: 'Nâng cấp nhà kho, tăng sức chứa lên 2000 chỗ.'
    }
    // --- Kết thúc thêm Vật Phẩm Nâng Cấp ---
			
            // --- Kết thúc thêm Cột Thu Lôi ---
        };

        // --- Trạng Thái Game ---
// ====================
let gameState = {
    currency: INITIAL_CURRENCY,
    plots: [], // Mảng các đối tượng ô đất { ..., fertility, causeOfDeath, pestDeathClickCount, barrenHarvestPenaltyFactor }
    maxInventoryCapacity: INITIAL_MAX_INVENTORY_CAPACITY, // <<< Sức chứa tối đa hiện tại
	maxUnlockedPlots: INITIAL_PLOT_COUNT,
	
    inventory: { // Kho đồ vật phẩm ĐÃ MUA
         pesticide: INITIAL_PESTICIDE
         // Hạt giống & Phân bón được thêm động khi mua
    },
    harvestedItems: { // Kho đồ vật phẩm ĐÃ THU HOẠCH
        // Ví dụ: 'hanhla': 5, 'cachua': 2
    },
    lastUpdateTimestamp: Date.now(),
    gameStartTime: Date.now(),
    totalPlayTime: 0,
    actionHistory: [], // <<< Giữ nguyên: Mảng lưu lịch sử hành động
    // --- KHÔNG CÒN TRẠNG THÁI PEST EVENT ---
    // isPestEventActive: false,
    // pestEventStartTime: 0
	
	 currentWeather: WEATHER_DATA[0],             // <<< THAY ĐỔI: Lưu cả object, mặc định là sunny {id, icon, name}
    nextWeatherChangeTimestamp: 0,               // Timestamp (ms) của lần đổi thời tiết kế tiếp
    currentWeatherStartTime: 0,                  // Timestamp bắt đầu chu kỳ thời tiết hiện tại
	nextDryCheckTimestamp: 0, // <<< BIẾN THEO DÕI CHECK KHÔ HẠN >>>
	 activeTornadoes: [],                // Mảng sẽ chứa { plotId, expireTimestamp, isDestruction } <-- cấu trúc mới khi sử dụng
    lightningRods: [], // <<< MỚI: Mảng chứa thông tin các cột thu lôi đã đặt
	nextTornadoEventTimestamp: 0,
	maxInventoryCapacity: INITIAL_MAX_INVENTORY_CAPACITY,
	// === NHIỆM VỤ HẰNG NGÀY ===
    dailyQuests: [],         // Mảng chứa 10 đối tượng nhiệm vụ của ngày hiện tại
    lastQuestResetDate: null // Chuỗi 'YYYY-MM-DD' của lần reset nhiệm vụ cuối
    // ========================================
	
};

		// --- Hàm Tiện Ích Mới: Ghi Lịch Sử Hành Động ---
		function compareQuests(a, b) {
    // Ưu tiên 1: Nhiệm vụ CHƯA NHẬN THƯỞNG lên trước
    if (a.isClaimed && !b.isClaimed) {
        return 1; // a (đã nhận) xuống dưới b (chưa nhận)
    }
    if (!a.isClaimed && b.isClaimed) {
        return -1; // a (chưa nhận) lên trên b (đã nhận)
    }
    // Nếu cả hai cùng trạng thái đã nhận hoặc chưa nhận...

    // Ưu tiên 2: Nếu cả hai đều CHƯA NHẬN, thì nhiệm vụ HOÀN THÀNH lên trước
    if (!a.isClaimed && !b.isClaimed) {
        if (a.isCompleted && !b.isCompleted) {
            return -1; // a (hoàn thành) lên trên b (chưa hoàn thành)
        }
        if (!a.isCompleted && b.isCompleted) {
            return 1; // a (chưa hoàn thành) xuống dưới b (hoàn thành)
        }
    }

    // Nếu cả hai đã nhận HOẶC cả hai chưa nhận và cùng trạng thái hoàn thành
    // -> giữ nguyên thứ tự tương đối (hoặc có thể thêm tiêu chí phụ như phần thưởng)
    return 0;
}
		// --- Các Hàm Mã Hóa/Giải Mã Base64 (Xử lý Unicode) ---
    /**
     * Mã hóa một chuỗi (bao gồm Unicode) thành Base64.
     * @param {string} str Chuỗi cần mã hóa.
     * @returns {string} Chuỗi Base64.
     */
    function encodeStringToBase64(str) {
        try {
            // 1. Chuyển chuỗi UTF-16 thành mảng byte UTF-8
            const utf8Bytes = new TextEncoder().encode(str);
            // 2. Chuyển mảng byte thành chuỗi nhị phân (mỗi byte là một ký tự)
            let binaryString = '';
            utf8Bytes.forEach(byte => {
                binaryString += String.fromCharCode(byte);
            });
            // 3. Mã hóa chuỗi nhị phân bằng btoa
            return btoa(binaryString);
        } catch (e) {
            console.error("Lỗi khi mã hóa Base64:", e);
            return null; // Trả về null nếu lỗi
        }
    }

    /**
     * Giải mã một chuỗi Base64 thành chuỗi gốc (xử lý Unicode).
     * @param {string} base64Str Chuỗi Base64 cần giải mã.
     * @returns {string|null} Chuỗi gốc hoặc null nếu lỗi.
     */
    function decodeBase64ToString(base64Str) {
        try {
            // 1. Giải mã Base64 thành chuỗi nhị phân
            const binaryString = atob(base64Str);
            // 2. Chuyển chuỗi nhị phân thành mảng byte (Uint8Array)
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            // 3. Giải mã mảng byte UTF-8 thành chuỗi UTF-16
            return new TextDecoder().decode(bytes);
        } catch (e) {
            console.error("Lỗi khi giải mã Base64:", e);
            // Thường lỗi nếu chuỗi đầu vào không phải Base64 hợp lệ
            return null;
        }
    }
    // --- Kết thúc Hàm Mã Hóa/Giải Mã Base64 ---

	
// ==============================================
/** Xác định bậc chất lượng dựa trên phần trăm máu */
function getQualityTier(healthPercent) {
    if (healthPercent >= QUALITY_THRESHOLDS[QUALITY_TIERS.PERFECT]) {
        return QUALITY_TIERS.PERFECT;
    } else if (healthPercent >= QUALITY_THRESHOLDS[QUALITY_TIERS.GOOD]) {
        return QUALITY_TIERS.GOOD;
    } else if (healthPercent >= QUALITY_THRESHOLDS[QUALITY_TIERS.FAIR]) {
        return QUALITY_TIERS.FAIR;
    } else if (healthPercent >= QUALITY_THRESHOLDS[QUALITY_TIERS.POOR]) {
        return QUALITY_TIERS.POOR;
    }
    // Trường hợp health <= 0 không nên xảy ra khi thu hoạch, nhưng trả về null nếu có lỗi
    return null;
}



function isPlotWithRod(plotId) {
    return gameState.lightningRods.some(rod => rod.plotId === plotId);
}

/** [MỚI] Lấy dữ liệu cột thu lôi cho một ô đất */
function getRodData(plotId) {
    return gameState.lightningRods.find(rod => rod.plotId === plotId);
}

/** [MỚI] Tìm cột thu lôi đang hoạt động trong phạm vi */
function findRodInRange(targetPlotId) {
    for (const rod of gameState.lightningRods) {
        if (rod.health > 0 && Math.abs(rod.plotId - targetPlotId) <= LIGHTNING_ROD_PROTECTION_RANGE) {
            return rod; // Trả về rod đầu tiên tìm thấy
        }
    }
    return null; // Không tìm thấy rod nào
}


function calculateTotalInventoryQuantity() {
    let total = 0;
    // Tính tổng kho đã thu hoạch
    for (const itemId in gameState.harvestedItems) {
        total += gameState.harvestedItems[itemId] || 0;
    }
    // Tính tổng kho đã mua
    for (const itemId in gameState.inventory) {
        // Ở đây đang tính tất cả vật phẩm đã mua, bao gồm cả hạt giống, thuốc, phân
        total += gameState.inventory[itemId] || 0;
    }
    return total;
}
/**
 * Ghi lại một hành động vào lịch sử game.
 * @param {string} type Loại hành động (e.g., 'plant', 'harvest', 'fertilize', 'pest', 'clear', 'sell_direct', 'buy_plot', 'buy_item')
 * @param {number|null} plotId ID ô đất liên quan (null nếu không áp dụng)
 * @param {string} details Mô tả chi tiết hành động
 * @param {string} icon Biểu tượng emoji cho hành động
 * @param {string|null} itemId ID vật phẩm liên quan (null nếu không áp dụng)
 */
function logAction(type, plotId, details, icon, itemId = null) {
    try {
        const newEntry = {
            timestamp: Date.now(),
            type: type,
            plotId: plotId, // Có thể là null
            details: details,
            icon: icon,
            itemId: itemId // Có thể là null
        };

        // Thêm vào đầu mảng (mới nhất lên trước)
        gameState.actionHistory.unshift(newEntry);

        // Giới hạn kích thước mảng lịch sử
        if (gameState.actionHistory.length > MAX_HISTORY_ENTRIES) {
            gameState.actionHistory.length = MAX_HISTORY_ENTRIES; // Cắt bỏ phần tử cũ nhất
            // Hoặc dùng splice/pop nếu muốn: gameState.actionHistory.pop();
        }

        // Lưu lịch sử vào localStorage riêng biệt
        localStorage.setItem(HISTORY_SAVE_KEY, JSON.stringify(gameState.actionHistory));
        // console.log("Đã ghi log hành động:", details); // Bật nếu cần debug
    } catch (error) {
        console.error("Lỗi khi ghi lịch sử hành động:", error, {type, plotId, details, icon, itemId});
        // Không nên dừng game chỉ vì lỗi log
    }
}





        // --- Biến Toàn Cục ---
		const backgroundMusic = document.getElementById('background-music');
		const lightningSound = document.getElementById('lightning-sound');
		let musicStarted = false; // Cờ để đảm bảo nhạc chỉ bắt đầu một lần
		const darkOverlayElement = document.getElementById('dark-overlay');
		// >>> BIẾN VÀ THAM CHIẾU NÚT ÂM THANH <<<
let isMusicManuallyEnabled = true; // Cờ theo dõi người dùng đã cố bật nhạc chưa
const toggleSoundBtn = document.getElementById('toggle-sound-btn');
const rainSound = document.getElementById('rain-sound');
const rainySunnySound = document.getElementById('rainy-sunny-sound');

// >>> KẾT THÚC THÊM <<<
		
        // =====================
        let gameLoopInterval = null;
        let messageTimeout = null;
        let currentPlantingPlotId = null;
        let currentActionPlotId = null;
        let tooltipTimeout = null;
        let currentTooltipTarget = null;
        let tooltipHideTimeout = null;
        let tickCounter = 0;
		let weatherUpdateNeeded = true; // Cờ để yêu cầu cập nhật UI thời tiết lần đầu
		let hatNgocTroiTimeout = null;
		let areEffectSoundsEnabled = true; // Mặc định bật âm thanh hiệu ứng
		let isMusicEnabled = true; // <<< ĐỔI TÊN: Trạng thái bật/tắt thực tế của nhạc nền (sẽ load từ localStorage)
        // --- Tham Chiếu Phần Tử DOM ---
        // ==============================
		
        const loadingIndicator = document.getElementById('loading-indicator');
        const gameContainer = document.getElementById('game-container');
        const gardenElement = document.getElementById('garden');
        const currencyElement = document.getElementById('currency');
        const gameTimeElement = document.getElementById('game-time');
        const plotCountElement = document.getElementById('plot-count');
        const messageArea = document.getElementById('message-area');
        const shopModal = document.getElementById('shop-modal');
        const inventoryModal = document.getElementById('inventory-modal');
        const seedSelectionModal = document.getElementById('seed-selection-modal');
        const fertilizerSelectionModal = document.getElementById('fertilizer-selection-modal');
        const plantActionModal = document.getElementById('plant-action-modal');
        const emptyPlotActionModal = document.getElementById('empty-plot-action-modal');
        const shopTabsContainer = document.getElementById('shop-tabs');
        const shopSeedList = document.getElementById('shop-seed-list');
        const shopToolList = document.getElementById('shop-tool-list');
        const shopSeedsEmptyMessage = document.getElementById('shop-seeds-empty-message');
        const shopToolsEmptyMessage = document.getElementById('shop-tools-empty-message');
        const inventoryTabsContainer = document.getElementById('inventory-tabs');
        const inventoryHarvestedList = document.getElementById('inventory-harvested-list');
        const inventoryPurchasedList = document.getElementById('inventory-purchased-list');
        const inventoryHarvestedEmptyMessage = document.getElementById('inventory-harvested-empty-message');
        const inventoryPurchasedEmptyMessage = document.getElementById('inventory-purchased-empty-message');
        const seedSelectionList = document.getElementById('seed-selection-list');
        const seedSelectionEmptyMessage = document.getElementById('seed-selection-empty-message');
        const fertilizerSelectionList = document.getElementById('fertilizer-selection-list');
        const fertilizerSelectionEmptyMessage = document.getElementById('fertilizer-selection-empty-message');
        const plantActionButtonsContainer = document.getElementById('plant-action-buttons');
        const plantActionTitle = document.getElementById('plant-action-title');
        const plantActionInfo = document.getElementById('plant-action-info');
        const emptyPlotActionButtonsContainer = document.getElementById('empty-plot-action-buttons');
        const emptyPlotActionTitle = document.getElementById('empty-plot-action-title');
        const emptyPlotActionInfo = document.getElementById('empty-plot-action-info');
        const openShopBtn = document.getElementById('open-shop-btn');
        const openInventoryBtn = document.getElementById('open-inventory-btn');
       // const saveGameBtn = document.getElementById('save-game-btn');
	    const openMenuBtn = document.getElementById('open-menu-btn'); // <<< THÊM NÚT MỚI
        const tooltipElement = document.getElementById('tooltip');
		const lockedPlotPopup = document.getElementById('locked-plot-popup');
		const menuPopup = document.getElementById('menu-popup');
			 // Tìm nút đóng bên trong menu popup - Quan trọng là tìm sau khi menuPopup đã được tham chiếu
		const closeMenuPopupBtn = menuPopup ? menuPopup.querySelector('.close-button') : null; // <<< THÊM NÚT ĐÓNG MENU
		const lockedPlotMessage = document.getElementById('locked-plot-message');
		const confirmBuyPlotBtn = document.getElementById('confirm-buy-plot-btn');
		const cancelBuyPlotBtn = document.getElementById('cancel-buy-plot-btn');
		const closePopupBtn = lockedPlotPopup.querySelector('.close-popup-btn'); // Tìm nút đóng bên trong popup
		const confirmSellAllModal = document.getElementById('confirm-sell-all-modal');
        const confirmSellItemName = document.getElementById('confirm-sell-item-name');
        const confirmSellQuantity = document.getElementById('confirm-sell-quantity');
        const confirmSellTotalValue = document.getElementById('confirm-sell-total-value');
        const confirmSellAllBtn = document.getElementById('confirm-sell-all-btn');
        const cancelSellAllBtn = document.getElementById('cancel-sell-all-btn');

		const weatherIconElement = document.getElementById('weather-icon');
        const weatherTimerElement = document.getElementById('weather-timer');
        const weatherProgressBarElement = document.getElementById('weather-progress-bar');
        const weatherProgressContainer = document.getElementById('weather-progress-container'); // Thêm container
		const weatherNameElement = document.getElementById('weather-name'); // <<< THÊM THAM CHIẾU MỚI
		const plantingHistoryBtn = document.getElementById('planting-history-btn');
		
		const hatNgocTroiPopup = document.getElementById('hat-ngoc-troi-popup'); // <<< THÊM THAM CHIẾU POPUP MỚI
		const hatNgocTroiRewardPopup = document.getElementById('hat-ngoc-troi-reward-popup');
const rewardItemImage = document.getElementById('reward-item-image');
const rewardItemName = document.getElementById('reward-item-name');
const confirmRewardBtn = document.getElementById('confirm-reward-btn');
		const discardItemPopup = document.getElementById('discard-item-popup');
const discardItemIcon = document.getElementById('discard-item-icon');
const discardItemName = document.getElementById('discard-item-name');
const discardCurrentQuantity = document.getElementById('discard-current-quantity');
const discardQuantityInput = document.getElementById('discard-quantity-input');
const discardQuantityError = document.getElementById('discard-quantity-error');
const confirmDiscardBtn = document.getElementById('confirm-discard-btn');
const cancelDiscardBtn = document.getElementById('cancel-discard-btn');
		const lightningRodActionModal = document.getElementById('lightning-rod-action-modal'); 
      const confirmRepairRodPopup = document.getElementById('confirm-repair-rod-popup'); 
      const confirmRemoveRodPopup = document.getElementById('confirm-remove-rod-popup'); 
const toggleEffectsSoundBtn = document.getElementById('toggle-effects-sound-btn');
		const exportImportBtn = document.getElementById('export-import-data-btn');
const savegamePopup = document.getElementById('menu-savegame-popup');
const btnSaveGame = document.getElementById('btn-savegame'); // Tham chiếu nút Lưu
const btnImportSaveGame = document.getElementById('btn-import-savegame'); // Tham chiếu nút Nhập
const closeSavegamePopupBtn = savegamePopup ? savegamePopup.querySelector('.close-button') : null; // Nút đóng popup lưu/nhập

const dailyQuestBtn = document.getElementById('btn-nhiemvuhangngay');
const dailyQuestPopup = document.getElementById('daily-quest-popup');

	  // --- Các Hàm Logic Game Cốt Lõi ---
	  
	   /**  Xác thực cấu trúc cơ bản của dữ liệu game đã nhập */
    function validateImportedState(data) {
        if (!data || typeof data !== 'object') return false;
        // Kiểm tra các khóa chính và kiểu dữ liệu cơ bản
        if (typeof data.currency !== 'number' || data.currency < 0) return false;
        if (typeof data.maxUnlockedPlots !== 'number' || data.maxUnlockedPlots < INITIAL_PLOT_COUNT) return false;
        if (!Array.isArray(data.plots)) return false;
        if (typeof data.inventory !== 'object' || data.inventory === null) return false;
        if (typeof data.harvestedItems !== 'object' || data.harvestedItems === null) return false;
        if (typeof data.lastUpdateTimestamp !== 'number' || data.lastUpdateTimestamp <= 0) return false;
        if (typeof data.currentWeather !== 'object' || typeof data.currentWeather.id !== 'string') return false;
        // Có thể thêm nhiều kiểm tra chi tiết hơn nếu cần (ví dụ: cấu trúc plot, ID vật phẩm hợp lệ)
        return true; // Trả về true nếu các kiểm tra cơ bản pass
    }

    /** Áp dụng dữ liệu game đã nhập và khởi động lại game */
    function applyAndRestartGame(newStateData) {
        console.log("Đang áp dụng trạng thái game đã nhập...");
        try {
            // 1. Dừng game loop và các timer/âm thanh hiện tại
            stopGameLoop(); // Dừng game loop chính và timer Hat Ngọc Trời
            if (backgroundMusic && !backgroundMusic.paused) backgroundMusic.pause();
            if (rainSound && !rainSound.paused) rainSound.pause();
            if (rainySunnySound && !rainySunnySound.paused) rainySunnySound.pause();
            if (lightningSound && !lightningSound.paused) { lightningSound.pause(); lightningSound.currentTime = 0; }
            console.log("Đã dừng vòng lặp và âm thanh hiện tại.");

            // 2. Thực hiện Deep Copy trạng thái mới vào gameState
            //    Điều này đảm bảo không có tham chiếu đối tượng cũ nào còn sót lại.
            gameState = JSON.parse(JSON.stringify(newStateData));
            console.log("Đã thực hiện deep copy trạng thái mới vào gameState.");

            // 3. [QUAN TRỌNG] Mô phỏng tiến trình offline từ thời điểm lưu trong tệp đến hiện tại
            const now = Date.now();
            const timeDiff = now - gameState.lastUpdateTimestamp;
            let stateChangedDuringSim = false;
            if (timeDiff > TICK_INTERVAL * 1.5 && gameState.lastUpdateTimestamp > 0) {
                console.log(`Áp dụng mô phỏng offline cho ${formatTime(timeDiff)} kể từ lần lưu cuối.`);
                stateChangedDuringSim = simulateOfflineProgress(gameState.lastUpdateTimestamp, now);
                gameState.totalPlayTime += timeDiff; // Cập nhật tổng thời gian chơi
                gameState.lastUpdateTimestamp = now; // Cập nhật timestamp cuối cùng về hiện tại
                console.log("Mô phỏng offline hoàn tất.");
            } else if (timeDiff > 0 && gameState.lastUpdateTimestamp > 0){ // Cập nhật thời gian chơi nếu offline ngắn
                 gameState.totalPlayTime += timeDiff;
                 gameState.lastUpdateTimestamp = now;
            } else { // Nếu timestamp lưu là tương lai hoặc không hợp lệ, đặt lại
                gameState.lastUpdateTimestamp = now;
            }

            // 4. Tải lại cài đặt âm thanh từ localStorage (không ghi đè bởi file save)
            const savedMusicEnabled = localStorage.getItem(MUSIC_ENABLED_KEY);
            const savedEffectsEnabled = localStorage.getItem(EFFECTS_ENABLED_KEY);
            isMusicEnabled = (savedMusicEnabled === null) ? true : (savedMusicEnabled === 'true');
            areEffectSoundsEnabled = (savedEffectsEnabled === null) ? true : (savedEffectsEnabled === 'true');
            console.log(`Đã tải lại cài đặt âm thanh: Music=${isMusicEnabled}, Effects=${areEffectSoundsEnabled}`);

            // 5. Khởi tạo lại dữ liệu plots dựa trên maxUnlockedPlots mới
            initializePlotsData(); // Đảm bảo mảng plots khớp với maxUnlockedPlots
            console.log("Đã khởi tạo lại dữ liệu plots.");

            // 6. Render lại toàn bộ giao diện
            renderGarden();
            renderUI();
            populateShop();
            updateShopButtons(); // Quan trọng sau khi populateShop và renderUI
            weatherUpdateNeeded = true; // Đánh dấu cần cập nhật thời tiết
            renderWeatherUI();
            updateSoundButtonText(); // Cập nhật nút âm thanh theo cài đặt đã tải
            updateEffectSoundButtonText();
            console.log("Đã render lại giao diện.");

            // 7. Xóa tooltip cũ nếu có
            hideTooltip();

            // 8. Khởi động lại game loop
            startGameLoop(); // Bao gồm cả việc khởi động lại timer Hat Ngọc Trời
            console.log("Đã khởi động lại vòng lặp game.");

            showMessage("Đã phục hồi dữ liệu game thành công!", "success", 4000);

        } catch (error) {
            console.error("Lỗi nghiêm trọng khi áp dụng trạng thái game đã nhập:", error);
            showMessage("Lỗi nghiêm trọng! Không thể phục hồi dữ liệu game. Đang tải lại game mặc định.", "error", 5000);
            // Reset về trạng thái mặc định nếu có lỗi nghiêm trọng khi áp dụng
            localStorage.removeItem(GAME_SAVE_KEY);
            localStorage.removeItem(HISTORY_SAVE_KEY);
            // Gọi lại initGame để bắt đầu lại hoàn toàn
            // Dùng setTimeout để tránh gọi đệ quy trực tiếp nếu initGame cũng lỗi
            setTimeout(() => {
                // Reset các biến trạng thái trước khi init lại
                 currentPlantingPlotId = null;
                 currentActionPlotId = null;
                 tickCounter = 0;
                 weatherUpdateNeeded = true;
                 clearTimeout(messageTimeout);
                 clearTimeout(tooltipTimeout);
                 clearTimeout(tooltipHideTimeout);
                 clearTimeout(hatNgocTroiTimeout);
                 hatNgocTroiTimeout = null;
                 // Gọi initGame để reset
                 initGame();
            }, 100);
        }
    }

	// --- biến toàn cục gần các biến trạng thái khác ---
let pendingRestoreData = null; // Dữ liệu game chờ xác nhận khôi phục


    /**  Xử lý việc chọn và nhập tệp trạng thái game */
   async function importGameStateFromFile() {
    console.log("Bắt đầu quá trình nhập game từ tệp (dự kiến Base64)...");

    // 1. Kiểm tra hỗ trợ API truy cập tệp
    if (!window.showOpenFilePicker) {
        showMessage("Trình duyệt của bạn không hỗ trợ tính năng nhập tệp này.", "error");
        console.error("File System Access API (showOpenFilePicker) is not supported.");
        return;
    }

    const savegamePopupElement = document.getElementById('menu-savegame-popup'); // Tham chiếu popup lưu/nhập

    try {
        // 2. Mở hộp thoại chọn tệp
        const [fileHandle] = await window.showOpenFilePicker({
            multiple: false, // Chỉ cho phép chọn một tệp
            types: [{
                description: 'Vườn Cây Hạnh Phúc Save File', // Mô tả loại tệp
                accept: {
                    'application/octet-stream': ['.sav'], // Ưu tiên đuôi .sav (encoded)
                    'application/json': ['.json']         // Cho phép cả .json (plain text)
                },
            }],
        });
        console.log("Người dùng đã chọn tệp:", fileHandle.name);

        // 3. Lấy đối tượng File
        const file = await fileHandle.getFile();
        console.log(`Thông tin tệp: Tên=${file.name}, Kích thước=${file.size} bytes, Loại=${file.type}`);

        // 4. Đọc nội dung tệp dưới dạng text
        const fileContent = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result); // Trả về nội dung khi đọc xong
            reader.onerror = (error) => reject(error); // Báo lỗi nếu có
            reader.readAsText(file); // Bắt đầu đọc tệp
        });
        console.log("Đã đọc nội dung tệp.");

        // 5. Giải mã Base64 (nếu cần) và Parse JSON
        let decodedJsonString = decodeBase64ToString(fileContent); // Thử giải mã Base64
        let parsedData;

        if (decodedJsonString === null) {
            // Nếu giải mã Base64 lỗi, thử parse trực tiếp như JSON (cho save cũ)
            console.warn("Giải mã Base64 thất bại. Đang thử parse trực tiếp như JSON thuần...");
            try {
                parsedData = JSON.parse(fileContent);
                console.log("Parse trực tiếp JSON thành công (có thể là tệp lưu cũ).");
            } catch (directParseError) {
                // Nếu cả hai đều lỗi
                console.error("Lỗi khi parse trực tiếp JSON:", directParseError);
                showMessage("Tệp không chứa dữ liệu hợp lệ (không phải Base64 hoặc JSON).", "error");
                return; // Dừng lại
            }
        } else {
            // Nếu giải mã Base64 thành công, parse chuỗi đã giải mã
            try {
                parsedData = JSON.parse(decodedJsonString);
                console.log("Đã giải mã Base64 và parse JSON thành công.");
            } catch (parseError) {
                console.error("Lỗi khi parse JSON sau khi giải mã Base64:", parseError);
                showMessage("Dữ liệu trong tệp bị lỗi sau khi giải mã.", "error");
                return; // Dừng lại
            }
        }

        // 6. Validate cấu trúc dữ liệu cơ bản
        if (!validateImportedState(parsedData)) {
            console.error("Dữ liệu đã parse không hợp lệ hoặc thiếu các trường quan trọng.");
            showMessage("Tệp không chứa dữ liệu lưu game hợp lệ.", "error");
            return; // Dừng lại
        }
        console.log("Dữ liệu đã qua kiểm tra cấu trúc cơ bản.");

        // --- BẮT ĐẦU HIỂN THỊ POPUP XÁC NHẬN LỒNG NHAU ---
        pendingRestoreData = parsedData; // Lưu dữ liệu hợp lệ chờ xác nhận

        // Lấy tham chiếu đến popup xác nhận và các nút bên trong
        const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
        const confirmRestoreBtn = document.getElementById('confirm-restore-btn');
        const cancelRestoreBtn = document.getElementById('cancel-restore-btn');
        const closeRestorePopupBtn = confirmRestorePopup ? confirmRestorePopup.querySelector('.close-button') : null;

        // Kiểm tra xem tất cả các phần tử cần thiết có tồn tại không
        if (!savegamePopupElement || !confirmRestorePopup || !confirmRestoreBtn || !cancelRestoreBtn || !closeRestorePopupBtn) {
             console.error("Lỗi: Thiếu các phần tử DOM cho popup lưu/nhập hoặc popup xác nhận khôi phục!");
             showMessage("Lỗi giao diện: Không thể xác nhận khôi phục.", "error");
             pendingRestoreData = null; // Xóa dữ liệu đang chờ nếu có lỗi DOM
             return;
        }

        // 1. Thêm class để làm mờ và vô hiệu hóa popup lưu/nhập bên dưới
        savegamePopupElement.classList.add('popup-underlay');
        console.log("Đã thêm class 'popup-underlay' vào #menu-savegame-popup.");

        // 2. Hiển thị popup xác nhận khôi phục bằng 'flex' để căn giữa
        confirmRestorePopup.style.display = 'flex';
        console.log("Đã hiển thị #popup-confirm-restoregame bằng display: flex.");

        // 3. Lớp phủ tối (darkOverlay) đã được hiển thị khi mở popup lưu/nhập,
        //    không cần gọi lại showDarkOverlay() ở đây.

        // 4. Đặt focus vào nút "Xác Nhận Khôi Phục" để tiện cho người dùng
        setTimeout(() => {
            confirmRestoreBtn.focus();
            console.log("Đã focus vào nút #confirm-restore-btn.");
        }, 50); // Dùng setTimeout để đảm bảo popup đã render

        // --- POPUP LƯU/NHẬP GỐC KHÔNG BỊ ĐÓNG ---

        // --- Kết thúc logic hiển thị popup lồng nhau ---

    } catch (error) {
        // Xử lý các lỗi có thể xảy ra trong quá trình
        if (error.name === 'AbortError') {
            // Người dùng hủy hộp thoại chọn tệp
            console.log("Người dùng đã hủy hộp thoại chọn tệp.");
            showMessage("Đã hủy thao tác chọn tệp.", "info");
        } else {
            // Các lỗi khác (đọc file, permission,...)
            console.error("Lỗi trong quá trình nhập game từ tệp:", error);
            showMessage(`Lỗi khi nhập tệp: ${error.message}`, "error");
        }

        // Quan trọng: Nếu có lỗi, đảm bảo xóa class làm mờ khỏi popup lưu/nhập
        // và reset dữ liệu đang chờ
        if (savegamePopupElement) {
            savegamePopupElement.classList.remove('popup-underlay');
            console.log("Đã xóa class 'popup-underlay' khỏi #menu-savegame-popup do lỗi.");
        }
        pendingRestoreData = null; // Reset dữ liệu chờ
    }
}

	// --- các hàm xử lý cho popup mới ---
/** Đóng popup xác nhận khôi phục game */
function closeConfirmRestorePopup() {
    const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
    const savegamePopupElement = document.getElementById('menu-savegame-popup'); // <<<< LẤY POPUP DƯỚI

    if (confirmRestorePopup) {
        confirmRestorePopup.style.display = 'none';
        pendingRestoreData = null; // Quan trọng: Xóa dữ liệu đang chờ

        // Xóa class làm mờ khỏi popup lưu/nhập
        if (savegamePopupElement) {
            savegamePopupElement.classList.remove('popup-underlay');
        }

        // KIỂM TRA OVERLAY: Chỉ ẩn overlay nếu popup save/load cũng *không* hiển thị
        setTimeout(() => {
            const savegamePopupVisible = savegamePopupElement && (savegamePopupElement.style.display === 'block' || savegamePopupElement.style.display === 'flex');
            // Chỉ ẩn nếu không còn modal nào khác VÀ popup save/load cũng không hiển thị
            const anyOtherModalOpen = document.querySelector('.modal[style*="display: block"]:not(#popup-confirm-restoregame), .modal[style*="display: flex"]:not(#popup-confirm-restoregame)');
            if (!anyOtherModalOpen && !savegamePopupVisible && darkOverlayElement && darkOverlayElement.classList.contains('visible')) {
                hideDarkOverlay();
            }
        }, 50);
    }
}

/** Xử lý khi nhấn nút Hủy Bỏ trong popup khôi phục */
function handleCancelRestore() {
    console.log("Người dùng đã hủy thao tác khôi phục.");
    showMessage("Đã hủy thao tác phục hồi dữ liệu.", "info");
    closeConfirmRestorePopup(); // Chỉ đóng popup xác nhận, popup lưu/nhập vẫn mở và active lại
}


/** Xử lý khi nhấn nút Xác Nhận Khôi Phục */
function handleConfirmRestore() {
    const savegamePopupElement = document.getElementById('menu-savegame-popup'); // <<<< LẤY POPUP DƯỚI
    if (pendingRestoreData) {
        console.log("Người dùng đã xác nhận khôi phục.");
        applyAndRestartGame(pendingRestoreData); // Gọi hàm áp dụng dữ liệu

        // Đóng cả hai popup sau khi áp dụng thành công
        closeConfirmRestorePopup(); // Đóng popup xác nhận (đã bao gồm xóa class underlay)
        closeSavegamePopup();     // Đóng popup lưu/nhập gốc
        // Hàm closeSavegamePopup nên tự động kiểm tra và ẩn overlay nếu cần
    } else {
        console.error("Lỗi: Không có dữ liệu khôi phục đang chờ.");
        showMessage("Lỗi: Không tìm thấy dữ liệu để khôi phục.", "error");
        // Nếu lỗi, vẫn đóng popup xác nhận và xóa class làm mờ
        closeConfirmRestorePopup();
    }
    // pendingRestoreData đã được reset trong closeConfirmRestorePopup()
}
 
	  
	  
	   /** Xuất trạng thái game hiện tại ra tệp JSON */
     async function exportGameStateToFile() {
        console.log("Bắt đầu quá trình xuất game ra tệp (Base64)...");
        try {
            saveGame(); // Cập nhật gameState trong bộ nhớ
            console.log("Trạng thái game đã được cập nhật trong bộ nhớ.");

            // 2. Lấy dữ liệu gameState và chuyển thành JSON
            const jsonString = JSON.stringify(gameState, null, 2); // Có thể bỏ định dạng đẹp (null, 2) nếu muốn tệp nhỏ hơn chút
            console.log("Đã tạo chuỗi JSON.");

            // --- [THAY ĐỔI] Mã hóa chuỗi JSON thành Base64 ---
            const dataToExport = encodeStringToBase64(jsonString);
            if (dataToExport === null) {
                showMessage("Lỗi: Không thể mã hóa dữ liệu lưu game.", "error");
                return; // Dừng nếu mã hóa lỗi
            }
            console.log("Đã mã hóa dữ liệu JSON thành Base64.");
            // ----------------------------------------------

            // 3. Tạo tên tệp đề xuất
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            // Có thể đổi đuôi tệp thành .sav hoặc gì đó khác thay vì .json để người dùng biết nó không phải JSON thuần
            const suggestedName = `VuonCayHanhPhuc_Save_${timestamp}.sav`; // <-- Đổi đuôi tệp thành .sav
            console.log("Tên tệp đề xuất:", suggestedName);

            // 4. Mở hộp thoại "Save As"
            const fileHandle = await window.showSaveFilePicker({
                suggestedName: suggestedName,
                types: [{
                    // Cập nhật description và accept nếu đổi đuôi tệp
                    description: 'Vườn Cây Hạnh Phúc Save File (Encoded)',
                    accept: { 'application/octet-stream': ['.sav'] }, // Dùng kiểu generic nếu không phải json
                }],
            });
            console.log("Người dùng đã chọn tệp:", fileHandle.name);

            // 5. Tạo luồng ghi
            const writableStream = await fileHandle.createWritable();
            console.log("Đã tạo luồng ghi.");

            // 6. Ghi dữ liệu ĐÃ MÃ HÓA vào luồng
            await writableStream.write(dataToExport);
            console.log("Đã ghi dữ liệu Base64 vào luồng.");

            // 7. Đóng luồng ghi
            await writableStream.close();
            console.log("Đã đóng luồng ghi.");

            showMessage("Đã lưu tiến trình trò chơi vào tệp thành công!", "success");
            closeSavegamePopup();

        } catch (error) {
            if (error.name === 'AbortError') {
                console.log("Người dùng đã hủy hộp thoại lưu tệp.");
                showMessage("Đã hủy thao tác lưu tệp.", "info");
            } else {
                console.error("Lỗi khi lưu game ra tệp (Base64):", error);
                showMessage(`Lỗi khi lưu tệp: ${error.message}`, "error");
            }
        }
    }

	  
	  
        // =================================
		/** Mở Popup Lưu/Nhập Game */
function openSavegamePopup() {
    if (savegamePopup) {
        console.log("Mở popup Lưu/Nhập game.");
        closeMenuPopup(); // Đóng menu chính trước
        savegamePopup.style.display = 'block'; // Hiển thị popup
        showDarkOverlay(); // Hiển thị lớp phủ tối

        // Tự động focus vào nút Lưu hoặc Nhập
        const focusTarget = btnSaveGame || btnImportSaveGame;
        if (focusTarget) {
            setTimeout(() => focusTarget.focus(), 50);
        }
    } else {
        console.error("Không tìm thấy phần tử DOM của popup Lưu/Nhập game!");
    }
}

/** Đóng Popup Lưu/Nhập Game */
function closeSavegamePopup() {
    if (savegamePopup) {
        savegamePopup.style.display = 'none';
        // Chỉ ẩn lớp phủ nếu không còn modal/popup nào khác đang mở
        setTimeout(() => {
            const anyModalOpen = document.querySelector('.modal[style*="display: block"], .modal[style*="display: flex"]');
            if (!anyModalOpen && darkOverlayElement && darkOverlayElement.classList.contains('visible')) {
                hideDarkOverlay();
            }
        }, 50);
    }
}
		
		
		
		function showDarkOverlay() {
    if (darkOverlayElement) {
        darkOverlayElement.classList.add('visible');
        console.log("Lớp phủ tối đã hiển thị.");
    } else {
        console.error("Không tìm thấy #dark-overlay để hiển thị.");
    }
}

/** Ẩn lớp phủ tối */
function hideDarkOverlay() {
    if (darkOverlayElement) {
        darkOverlayElement.classList.remove('visible');
         console.log("Lớp phủ tối đã ẩn.");
    } else {
         console.error("Không tìm thấy #dark-overlay để ẩn.");
    }
}

		
		function toggleEffectSounds() {
    if (!toggleEffectsSoundBtn) return;

    // 1. Đảo ngược trạng thái
    areEffectSoundsEnabled = !areEffectSoundsEnabled;
    console.log(`Người dùng chuyển trạng thái hiệu ứng thành: ${areEffectSoundsEnabled}`);

    // 2. Lưu trạng thái mới vào localStorage
    localStorage.setItem(EFFECTS_ENABLED_KEY, areEffectSoundsEnabled.toString());
    console.log(`Đã lưu trạng thái hiệu ứng (${areEffectSoundsEnabled}) vào localStorage.`);

    // 3. Cập nhật văn bản nút
    updateEffectSoundButtonText();

    // 4. Tắt các hiệu ứng đang chạy nếu người dùng vừa tắt
    if (!areEffectSoundsEnabled) {
        if (lightningSound && !lightningSound.paused) { lightningSound.pause(); lightningSound.currentTime = 0; }
        if (rainSound && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
        if (rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
        console.log("Đã dừng các hiệu ứng âm thanh đang chạy (nếu có).");
    } else {
        // Nếu người dùng vừa bật lại, gameTick tiếp theo sẽ tự động xử lý bật âm thanh thời tiết nếu cần
        console.log("Hiệu ứng đã được bật. Âm thanh thời tiết sẽ phát nếu phù hợp trong gameTick.");
    }
}
function updateEffectSoundButtonText() {
    if (!toggleEffectsSoundBtn) return; // Kiểm tra nút tồn tại
    if (areEffectSoundsEnabled) {
        toggleEffectsSoundBtn.textContent = "🔇 Tắt Âm Thanh Hiệu Ứng";
        // Tùy chọn: Thêm title để rõ hơn
        toggleEffectsSoundBtn.title = "Tắt các hiệu ứng âm thanh như sấm sét, mưa,...";
    } else {
        toggleEffectsSoundBtn.textContent = "🔊 Bật Âm Thanh Hiệu Ứng";
        toggleEffectsSoundBtn.title = "Bật các hiệu ứng âm thanh như sấm sét, mưa,...";
    }
}
		function getTotalInventoryQuantity() {
            let totalQuantity = 0;
            // Tính tổng từ kho đã thu hoạch
            for (const itemId in gameState.harvestedItems) {
                totalQuantity += gameState.harvestedItems[itemId] || 0;
            }
            // Tính tổng từ kho đã mua
            for (const itemId in gameState.inventory) {
                totalQuantity += gameState.inventory[itemId] || 0;
            }
            return totalQuantity;
        }
		
		
		/** [MỚI] Chọn ngẫu nhiên một vật phẩm từ ITEM_DATA để làm phần thưởng */
function getRandomRewardItem() {
    const validItemIds = Object.keys(ITEM_DATA);
    if (validItemIds.length === 0) {
        console.error("Không có vật phẩm nào trong ITEM_DATA để chọn làm phần thưởng.");
        return null;
    }
    const randomIndex = Math.floor(Math.random() * validItemIds.length);
    const randomItemId = validItemIds[randomIndex];
    console.log("Vật phẩm thưởng ngẫu nhiên được chọn:", randomItemId);
    return randomItemId;
}

/** [MỚI] Hiển thị popup phần thưởng với thông tin vật phẩm */
function showRewardPopup(itemId) {
    // Kiểm tra các phần tử DOM cần thiết
    if (!hatNgocTroiRewardPopup || !rewardItemImage || !rewardItemName || !confirmRewardBtn) {
        console.error("Thiếu phần tử DOM cho popup phần thưởng Hạt Ngọc Trời.");
        // Nếu thiếu, không thể hiện popup, cần khởi động lại timer để tránh kẹt
        startHatNgocTroiTimer();
        return;
    }
    const item = ITEM_DATA[itemId];
    if (!item) {
        console.error(`Không tìm thấy thông tin cho vật phẩm thưởng ID: ${itemId}`);
        // Nếu không tìm thấy item, cũng khởi động lại timer
        startHatNgocTroiTimer();
        return;
    }

    // Xác định đường dẫn ảnh
    let iconSrc = 'Hinhanh/Caychet.png';
    if (item.type === 'seed' && item.imageFolder) {
        iconSrc = `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
    } else if (item.type === 'tool' && item.imageFolder && item.imageFile) {
        iconSrc = `${item.imageFolder}/${item.imageFile}`;
    }

    // Cập nhật nội dung popup
    rewardItemImage.src = iconSrc;
    rewardItemImage.alt = item.name;
    rewardItemImage.onerror = () => { if (rewardItemImage.src !== 'Hinhanh/Caychet.png') rewardItemImage.src = 'Hinhanh/Caychet.png'; };
    rewardItemName.textContent = item.name;

    // Lưu itemId vào nút xác nhận
    confirmRewardBtn.dataset.itemId = itemId;

    // Hiển thị popup thưởng
    hatNgocTroiRewardPopup.style.display = 'block'; // Hoặc 'flex'
    console.log(`Đang hiển thị popup thưởng cho: ${item.name} (ID: ${itemId})`);
}

/** [MỚI] Thêm phần thưởng vào kho, đóng popup thưởng và khởi động lại timer Hạt Ngọc Trời */
function grantRewardAndClosePopup() {
           const itemId = confirmRewardBtn?.dataset?.itemId;
          if (!itemId || !ITEM_DATA[itemId]) {
              console.error("Không thể xác định vật phẩm thưởng để trao.");
              closeRewardPopup();
              startHatNgocTroiTimer(); // Khởi động lại timer nếu có lỗi
              return;
          }
          const item = ITEM_DATA[itemId];

          // --- [MỚI] Kiểm tra giới hạn kho đồ trước khi nhận quà ---
          const currentTotalCount = getTotalInventoryCount();
          const giftQuantity = 1;

          if (currentTotalCount + giftQuantity > MAX_INVENTORY_CAPACITY) {
              showMessage(`Kho đồ đầy (${currentTotalCount}/${MAX_INVENTORY_CAPACITY}), không thể nhận phần thưởng "${item.name}" từ Hạt Ngọc Trời!`, "error");
              console.warn(`(Hạt Ngọc Trời) Kho đồ đầy, không thể trao thưởng: ${item.name}`);
              logAction('gift_fail', null, `Kho đồ đầy (${currentTotalCount}/${MAX_INVENTORY_CAPACITY}), không nhận được quà Hạt Ngọc Trời: ${item.name}.`, '🚫', itemId);

              // Đóng popup và khởi động lại timer MÀ KHÔNG trao thưởng
              closeRewardPopup();
              startHatNgocTroiTimer(); // Quan trọng: Vẫn khởi động lại timer
              return; // Dừng lại ở đây
          }
          // --- Kết thúc kiểm tra giới hạn ---

          // Thêm vật phẩm vào kho "Đã Mua" (nếu không bị chặn bởi kiểm tra ở trên)
          gameState.inventory[itemId] = (gameState.inventory[itemId] || 0) + 1;
          console.log(`Đã thêm 1 ${item.name} (ID: ${itemId}) vào kho từ Hạt Ngọc Trời.`);

          // Cập nhật UI liên quan (kho đồ, shop, modals)
          if (inventoryModal.style.display === 'block') renderInventory(); // Cập nhật kho để thấy item mới và tiêu đề
          if (shopModal.style.display === 'block') updateShopButtons();
          if (plantActionModal.style.display === 'block' && currentActionPlotId !== null) updatePlantActionModalButtons(currentActionPlotId);
          if (emptyPlotActionModal.style.display === 'block' && currentActionPlotId !== null) updateEmptyPlotActionModal(currentActionPlotId);
          if (seedSelectionModal.style.display === 'block' && item.type === 'seed') populateSeedSelection();
          if (fertilizerSelectionModal.style.display === 'block' && item.type === 'tool' && typeof item.fertilityBoost === 'number') populateFertilizerSelection();

          saveGame();
          showMessage(`Bạn nhận được 1 ${item.name} từ Hạt Ngọc Trời!`, "success");
          logAction('gift', null, `Nhận quà từ Hạt Ngọc Trời: 1 ${item.name}.`, '💎', itemId);

          // Đóng popup thưởng
          closeRewardPopup();

          // Khởi động lại timer cho Hạt Ngọc Trời tiếp theo
          console.log("Phần thưởng đã được nhận. Khởi động lại timer Hạt Ngọc Trời.");
          startHatNgocTroiTimer();
      }

/** [MỚI] Hàm riêng để đóng popup phần thưởng */
function closeRewardPopup() {
      if (hatNgocTroiRewardPopup) {
        hatNgocTroiRewardPopup.style.display = 'none';
        if (confirmRewardBtn) {
             delete confirmRewardBtn.dataset.itemId;
        }
        console.log("Đã đóng popup thưởng Hạt Ngọc Trời.");
    }
}


/** [CẬP NHẬT] Đóng Popup Hạt Ngọc Trời ban đầu VÀ kích hoạt hiển thị phần thưởng */
function closeHatNgocTroiPopup() {
      if (hatNgocTroiPopup) {
        hatNgocTroiPopup.style.display = 'none'; // Đóng popup ban đầu
        console.log("Đã đóng Popup Hạt Ngọc Trời ban đầu. Chuẩn bị hiển thị phần thưởng.");

        // Chọn vật phẩm thưởng ngẫu nhiên
        const rewardItemId = getRandomRewardItem();

        if (rewardItemId && ITEM_DATA[rewardItemId]) { // Thêm kiểm tra ITEM_DATA[rewardItemId] tồn tại
            // *** Hiển thị popup phần thưởng ***
            showRewardPopup(rewardItemId);
        } else {
            // Xử lý trường hợp không chọn được phần thưởng (ví dụ: ITEM_DATA rỗng hoặc lỗi)
            console.error(`Không thể chọn hoặc tìm thấy vật phẩm thưởng hợp lệ. rewardItemId: ${rewardItemId}`);
            showMessage("Ồ! Có lỗi xảy ra, không thể nhận phần thưởng Hạt Ngọc Trời.", "error");
            // [QUAN TRỌNG] Vẫn phải khởi động lại timer ở đây nếu có lỗi, để game không bị kẹt
            startHatNgocTroiTimer();
        }
        // --- Timer KHÔNG được khởi động lại ở đây ---
    } else {
         console.warn("Không tìm thấy hatNgocTroiPopup để đóng.");
    }
}
		
		
		
		
		/** Hiển thị Popup Hạt Ngọc Trời */
function showHatNgocTroiPopup() {
    if (hatNgocTroiPopup) {
        console.log("Hiển thị Popup Hạt Ngọc Trời!");
        hatNgocTroiPopup.style.display = 'block'; // Hoặc 'flex' tùy theo CSS
        // Reset timer để nó không chạy lại ngay lập tức
        clearTimeout(hatNgocTroiTimeout);
        hatNgocTroiTimeout = null;
    }
}

/** Đóng Popup Hạt Ngọc Trời và khởi động lại timer */
function closeHatNgocTroiPopup() {
    try {
        const allItemIds = Object.keys(ITEM_DATA);
        if (allItemIds.length > 0) {
            const randomIndex = Math.floor(Math.random() * allItemIds.length);
            const randomItemId = allItemIds[randomIndex];
            const giftedItem = ITEM_DATA[randomItemId];

            if (giftedItem) {
                // Thêm 1 vật phẩm vào kho đồ ĐÃ MUA
                gameState.inventory[randomItemId] = (gameState.inventory[randomItemId] || 0) + 1;
                console.log(`(Hạt Ngọc Trời) Tặng quà: 1 x ${giftedItem.name} (ID: ${randomItemId})`);

                // Chuẩn bị thông báo
                let giftMessage = `✨ Từ Hạt Ngọc Trời, bạn nhận được 1 ${giftedItem.name}!`;
                let giftIconType = '🎁'; // Icon mặc định
                if(giftedItem.type === 'seed') giftIconType = '🌱';
                else if(giftedItem.id === 'pesticide') giftIconType = '💊';
                else if(typeof giftedItem.fertilityBoost === 'number') giftIconType = '💩';

                // Hiển thị thông báo (kéo dài hơn một chút)
                showMessage(`${giftIconType} ${giftMessage}`, "success", MESSAGE_DISPLAY_TIME * 1.5);

                // Cập nhật UI liên quan (Kho đồ, các modal chọn/hành động)
                if (inventoryModal.style.display === 'block') renderInventory();
                if (seedSelectionModal.style.display === 'block' && giftedItem.type === 'seed') populateSeedSelection();
                if (fertilizerSelectionModal.style.display === 'block' && giftedItem.type === 'tool' && typeof giftedItem.fertilityBoost === 'number') populateFertilizerSelection();
                if (plantActionModal.style.display === 'block' && currentActionPlotId !== null) updatePlantActionModalButtons(currentActionPlotId);
                if (emptyPlotActionModal.style.display === 'block' && currentActionPlotId !== null) updateEmptyPlotActionModal(currentActionPlotId);
                // Cập nhật cả nút shop nếu cần (ví dụ nếu quà làm thay đổi số lượng thuốc/phân)
                updateShopButtons();

                // Lưu game
                saveGame();

                // Ghi log
                logAction('gift', null, `Nhận quà từ Hạt Ngọc Trời: 1 ${giftedItem.name}.`, '💎', randomItemId);

            } else {
                console.error("(Hạt Ngọc Trời) Lỗi: Không tìm thấy dữ liệu cho vật phẩm ngẫu nhiên:", randomItemId);
            }
        } else {
             console.warn("(Hạt Ngọc Trời) Không có vật phẩm nào trong ITEM_DATA để tặng.");
        }
    } catch (error) {
        console.error("Lỗi khi xử lý tặng quà từ Hạt Ngọc Trời:", error);
        // Có thể thêm showMessage lỗi ở đây nếu muốn
    }
    // --- Kết thúc logic tặng quà ---

    // --- Logic gốc: Đóng popup và Khởi động lại timer ---
    if (hatNgocTroiPopup) {
        hatNgocTroiPopup.style.display = 'none';
        console.log("Đã đóng Popup Hạt Ngọc Trời (và tặng quà). Khởi động lại timer.");
        startHatNgocTroiTimer(); // Khởi động lại timer để popup có thể xuất hiện lại
    }
}

/** Khởi động hoặc đặt lại timer cho Popup Hạt Ngọc Trời */
function startHatNgocTroiTimer() {
              // Chỉ khởi động timer nếu game đang chạy và chưa có timer nào đang chạy
            if (gameLoopInterval && !hatNgocTroiTimeout) {
                clearTimeout(hatNgocTroiTimeout); // Xóa timer cũ nếu có (phòng lỗi)

                // <<< TÍNH TOÁN DELAY NGẪU NHIÊN >>>
                const randomDelay = MIN_HAT_NGOC_TROI_DELAY_MS + Math.random() * (MAX_HAT_NGOC_TROI_DELAY_MS - MIN_HAT_NGOC_TROI_DELAY_MS);
                const randomDelaySeconds = Math.round(randomDelay / 1000); // Chuyển sang giây để log

                console.log(`Bắt đầu đếm ngược khoảng ${formatTime(randomDelay)} (${randomDelaySeconds}s) cho Hạt Ngọc Trời tiếp theo.`);
                hatNgocTroiTimeout = setTimeout(showHatNgocTroiPopup, randomDelay); // <<< SỬ DỤNG DELAY NGẪU NHIÊN >>>

            } else if (!gameLoopInterval) {
                // console.log("Không bắt đầu timer Hạt Ngọc Trời vì game loop chưa chạy.");
            } else if (hatNgocTroiTimeout) {
                 // console.log("Timer Hạt Ngọc Trời đã chạy.");
            }
        }

		
		
		
		
		
		 /** Chọn ngẫu nhiên một icon thời tiết mới, tránh chọn lại icon cũ */
        function chooseRandomWeather() {
             const currentId = gameState.currentWeather?.id; // Lấy id hiện tại một cách an toàn

    // Nếu chỉ có một hoặc không có chế độ thời tiết nào, trả về cái đầu tiên (hoặc undefined nếu rỗng)
    if (WEATHER_DATA.length <= 1) {
        return WEATHER_DATA[0];
    }

    let newWeather;
    do {
        // Chọn ngẫu nhiên một object từ mảng WEATHER_DATA
        newWeather = WEATHER_DATA[Math.floor(Math.random() * WEATHER_DATA.length)];
    } while (newWeather.id === currentId); // Lặp lại nếu ID trùng với ID hiện tại

    return newWeather; // Trả về toàn bộ object {id, icon, name}
        }
		/** Cập nhật giao diện người dùng cho phần thời tiết */
        function renderWeatherUI() {
            // 1. Kiểm tra các phần tử DOM và dữ liệu cần thiết (giữ nguyên)
            if (!weatherIconElement || !weatherNameElement || !weatherTimerElement || !weatherProgressBarElement || !gameState.currentWeather) {
                console.warn("Thiếu phần tử DOM thời tiết hoặc gameState.currentWeather không hợp lệ.");
                // Đặt giá trị mặc định/trống khi có lỗi
                if(weatherIconElement) weatherIconElement.textContent = '❓';
                if(weatherNameElement) weatherNameElement.textContent = '---';
                if(weatherTimerElement) weatherTimerElement.textContent = '--:--';
                if(weatherProgressBarElement) weatherProgressBarElement.style.width = '0%';
                // <<< THÊM: Đảm bảo xóa class nếu có lỗi dữ liệu thời tiết >>>
                const gameContainerForReset = document.getElementById('game-container');
                if (gameContainerForReset) {
                    gameContainerForReset.classList.remove('darken-weather-effect');
                }
                // <<< KẾT THÚC THÊM >>>
                return; // Thoát sớm nếu thiếu
            }

            // 2. Tính toán thời gian và tiến trình (giữ nguyên)
            const now = Date.now();
            const timeUntilChange = Math.max(0, gameState.nextWeatherChangeTimestamp - now);
            const totalDuration = WEATHER_CHANGE_INTERVAL_MS;
            const progressPercent = totalDuration > 0
                ? Math.max(0, Math.min(100, (timeUntilChange / totalDuration) * 100))
                : 0;

            // 3. Lấy các thuộc tính cần thiết từ gameState.currentWeather
            const { id, icon, name } = gameState.currentWeather;

            // 4. Cập nhật giao diện người dùng thời tiết (icon, tên, timer, progress) - giữ nguyên
            weatherIconElement.textContent = icon;
            weatherIconElement.title = `Thời tiết hiện tại: ${name}`;
            weatherNameElement.textContent = name;
            const minutes = Math.floor(timeUntilChange / 60000);
            const seconds = Math.floor((timeUntilChange % 60000) / 1000);
            weatherTimerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            weatherTimerElement.title = `Thời gian còn lại đến khi đổi thời tiết: ${formatTime(timeUntilChange)}`;
            weatherProgressBarElement.style.width = `${progressPercent}%`;
            if (weatherProgressContainer) {
                weatherProgressContainer.title = `Tiến độ chu kỳ thời tiết hiện tại (${name})`;
            }

            // --- [MỚI] Logic làm tối UI khi mưa/bão ---
            const shouldDarken = (id === 'rainy' || id === 'thunderstorm'); // Điều kiện để làm tối
            const gameContainerElement = document.getElementById('game-container');

            if (gameContainerElement) {
                // Sử dụng classList.toggle để thêm/xóa class một cách gọn gàng
                // Tham số thứ hai là boolean: true -> thêm class, false -> xóa class
                gameContainerElement.classList.toggle('darken-weather-effect', shouldDarken);

                // Log để debug (tùy chọn)
                // if (shouldDarken && !gameContainerElement.classList.contains('darken-weather-effect')) {
                //     console.log("Applying darken effect for weather:", id);
                // } else if (!shouldDarken && gameContainerElement.classList.contains('darken-weather-effect')) {
                //     console.log("Removing darken effect for weather:", id);
                // }
            } else {
                // Cái này không nên xảy ra nếu HTML đúng
                console.error("renderWeatherUI: Không thể tìm thấy phần tử #game-container để áp dụng hiệu ứng thời tiết!");
            }
            // --- Kết thúc Logic làm tối UI ---
        }
		    // --- Listener để bắt đầu nhạc nền sau tương tác đầu tiên ---
		 function openConfirmSellAllModal(itemId, itemName, quantity, totalValue) {
            if (!confirmSellAllModal || !confirmSellItemName || !confirmSellQuantity || !confirmSellTotalValue || !confirmSellAllBtn) {
                console.error("Lỗi: Thiếu các phần tử DOM cho modal xác nhận bán hết.");
                return;
            }
            // Điền thông tin vào modal
            confirmSellItemName.textContent = itemName;
            confirmSellQuantity.textContent = quantity;
            confirmSellTotalValue.textContent = totalValue;

            // Lưu thông tin vào dataset của nút xác nhận để hàm xử lý có thể lấy
            confirmSellAllBtn.dataset.itemId = itemId;
            confirmSellAllBtn.dataset.quantity = quantity;

            // Hiển thị modal
            openModal('confirm-sell-all-modal'); // Dùng hàm openModal chung
        }

        /** Đóng hộp thoại xác nhận bán hết */
        function closeConfirmSellAllModal() {
            if (confirmSellAllModal) {
                closeModal('confirm-sell-all-modal'); // Dùng hàm closeModal chung
                // Xóa dữ liệu khỏi nút để tránh lỗi
                if (confirmSellAllBtn) {
                    delete confirmSellAllBtn.dataset.itemId;
                    delete confirmSellAllBtn.dataset.quantity;
                }
            }
        }

        /** Xử lý khi click nút Xác nhận trong hộp thoại bán hết */
        function handleConfirmSellAll() {
            if (!confirmSellAllBtn) return;
            const itemId = confirmSellAllBtn.dataset.itemId;
            const quantityString = confirmSellAllBtn.dataset.quantity;

            if (!itemId || !quantityString) {
                console.error("Lỗi: Không tìm thấy itemId hoặc quantity trên nút xác nhận bán hết.");
                closeConfirmSellAllModal();
                return;
            }

            const quantity = parseInt(quantityString);
            if (isNaN(quantity) || quantity <= 0) {
                console.error("Lỗi: Số lượng bán hết không hợp lệ:", quantityString);
                closeConfirmSellAllModal();
                return;
            }

            // Gọi hàm bán với thông tin đã lưu
            sellHarvestedItem(itemId, quantity);
            // Đóng modal sau khi bán
            closeConfirmSellAllModal();
        }

        // Gắn listener cho các nút trong modal xác nhận (nên thực hiện trong attachEventListeners)
        // Tuy nhiên, để đơn giản, có thể thêm trực tiếp ở đây nếu các nút luôn tồn tại
        if (confirmSellAllBtn) {
             confirmSellAllBtn.addEventListener('click', handleConfirmSellAll);
        } else { console.warn("Không tìm thấy nút confirm-sell-all-btn khi gắn listener."); }

        if (cancelSellAllBtn) {
             cancelSellAllBtn.addEventListener('click', closeConfirmSellAllModal);
        } else { console.warn("Không tìm thấy nút cancel-sell-all-btn khi gắn listener."); }
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
    function playMusicOnFirstInteraction() {
    // >>> THAY ĐỔI: Chỉ thử phát nếu người dùng đã bật hoặc chưa tương tác <<<
    if (!musicStarted && backgroundMusic && (isMusicManuallyEnabled || !toggleSoundBtn || toggleSoundBtn.textContent.includes('Tắt'))) {
    // >>> KẾT THÚC THAY ĐỔI <<<
        const playPromise = backgroundMusic.play();

        if (playPromise !== undefined) {
            playPromise.then(_ => {
                console.log("Nhạc nền đã bắt đầu phát.");
                musicStarted = true;
                isMusicManuallyEnabled = true; // Đánh dấu là đã bật (kể cả tự động)
                // >>> CẬP NHẬT VĂN BẢN NÚT <<<
                if (toggleSoundBtn) {
                    toggleSoundBtn.textContent = "🔇 Tắt Âm Thanh";
                }
                // >>> KẾT THÚC CẬP NHẬT <<<
                document.removeEventListener('click', playMusicOnFirstInteraction, { capture: true });
            })
            .catch(error => {
                console.warn("Không thể tự động phát nhạc nền (cần tương tác người dùng):", error);
                // Nếu lỗi, đảm bảo nút hiển thị đúng trạng thái "Bật"
                if (toggleSoundBtn && !backgroundMusic.paused) { // Kiểm tra lại nếu play() lỗi nhưng nhạc vẫn chạy? (Hiếm)
                    toggleSoundBtn.textContent = "🔇 Tắt Âm Thanh";
                } else if (toggleSoundBtn) {
                    toggleSoundBtn.textContent = "🔊 Bật Âm Thanh";
                }
                isMusicManuallyEnabled = false; // Đặt lại nếu tự động phát lỗi
            });
        } else {
             // Nếu playPromise là undefined (trình duyệt cũ không hỗ trợ), cập nhật nút dựa trên trạng thái hiện tại
             updateSoundButtonText();
			 
			 // Luôn gắn listener vì mặc định là muốn bật nhạc
        document.addEventListener('click', playMusicOnFirstInteraction, { capture: true });
        console.log("Đã gắn listener để cố gắng phát nhạc sau tương tác đầu tiên.");
        }
    } else if (musicStarted) {
         document.removeEventListener('click', playMusicOnFirstInteraction, { capture: true });
    }
}

    // Gắn listener vào document để bắt click bất kỳ đâu
    // Sử dụng capture: true để đảm bảo listener này chạy trước các listener khác có thể ngăn chặn sự kiện (stopPropagation)
    document.addEventListener('click', playMusicOnFirstInteraction, { capture: true });
    console.log("Đã gắn listener để phát nhạc nền sau tương tác.");
    // --- Kết thúc Listener nhạc nền ---


        /** Khởi tạo môi trường game. */
      function initGame() {
    console.log(`Đang khởi tạo Vườn Hạnh Phúc (Khóa Lưu: ${GAME_SAVE_KEY})...`);
    try {
        // 1. Tải tất cả trạng thái game, bao gồm cả cài đặt âm thanh
        loadGame();

        // 2. Khởi tạo dữ liệu logic game dựa trên trạng thái đã tải
        initializePlotsData(); // Dựa trên gameState.maxUnlockedPlots đã tải

        // 3. Render giao diện ban đầu dựa trên trạng thái đã tải
        renderGarden();        // Vẽ các ô đất
        renderUI();            // Cập nhật tiền, số ô
        populateShop();        // Điền vật phẩm vào cửa hàng

        // 4. Bắt đầu vòng lặp game chính
        startGameLoop();

        // 5. Hiển thị game và ẩn chỉ báo tải
        loadingIndicator.style.display = 'none';
        gameContainer.classList.remove('hidden');

        // 6. Gắn các trình lắng nghe sự kiện cho các nút và phần tử tương tác
        attachEventListeners();

        // 7. Cập nhật văn bản nút âm thanh DỰA TRÊN TRẠNG THÁI ĐÃ TẢI trong loadGame()
        updateSoundButtonText();       // Cập nhật nút nhạc nền
        updateEffectSoundButtonText(); // Cập nhật nút hiệu ứng

        // 8. Hiển thị thông báo chào mừng
        console.log("Khởi tạo game hoàn tất. Chào mừng!");
        if(gameState.totalPlayTime < 10 * 1000) showMessage("Chào mừng đến Vườn Cây Hạnh Phúc!", "success");
        else showMessage("Chào mừng quay trở lại!", "info");

        // 9. Xử lý nhạc nền ban đầu (Không tự động phát ngay)
        // Chỉ log trạng thái, việc phát sẽ chờ tương tác hoặc visibility change
        if (isMusicEnabled) {
            console.log("INIT: Nhạc nền đang được BẬT theo cài đặt. Sẽ phát sau tương tác.");
        } else {
            console.log("INIT: Nhạc nền đang được TẮT theo cài đặt.");
            // Đảm bảo audio element cũng ở trạng thái pause nếu cài đặt là tắt
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
            }
        }

    } catch (error) {
        // Xử lý lỗi nghiêm trọng trong quá trình khởi tạo
        console.error("LỖI NGHIÊM TRỌNG trong quá trình khởi tạo game:", error);
        loadingIndicator.textContent = "Lỗi nghiêm trọng! Không thể tải game. Hãy thử xóa dữ liệu trang web.";
        loadingIndicator.style.color = 'red';
        // Không ẩn loading để người dùng thấy lỗi
    }
} // --- Kết thúc hàm initGame ---


        /** Gắn các trình lắng nghe sự kiện chính. */
      function attachEventListeners() {
    console.log("[V10 Buy Fix attachEventListeners] Starting to attach event listeners...");
    let listenerCount = 0; // Đếm số lượng listener đã gắn thành công

    // --- NÚT UI CHÍNH ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Main UI button listeners...");
    if (openShopBtn) {
        openShopBtn.addEventListener('click', () => {
            console.log("[V10 UI Click] Open Shop Button");
            switchShopTab('seeds');
            openModal('shop-modal');
        });
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: openShopBtn not found."); }

    if (openInventoryBtn) {
        openInventoryBtn.addEventListener('click', () => {
            console.log("[V10 UI Click] Open Inventory Button");
            switchInventoryTab('harvested');
            renderInventory(); // Render trước khi mở để lấy số lượng mới nhất
            openModal('inventory-modal');
        });
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: openInventoryBtn not found."); }

    if (openMenuBtn) {
        openMenuBtn.addEventListener('click', () => {
            console.log("[V10 UI Click] Open Menu Button");
            openMenuPopup();
        });
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: openMenuBtn not found."); }

    // --- NÚT TRONG MENU POPUP ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Menu Popup button listeners...");
    if (menuPopup) { // Chỉ gắn listener nút con nếu popup cha tồn tại
        const closeMenuPopupBtn = menuPopup.querySelector('.close-button');
        if (closeMenuPopupBtn) {
            closeMenuPopupBtn.addEventListener('click', closeMenuPopup);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: Close button not found inside menuPopup."); }

        if (plantingHistoryBtn) {
            plantingHistoryBtn.addEventListener('click', handlePlantingHistoryClick);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: plantingHistoryBtn not found."); }

        if (toggleSoundBtn) {
            toggleSoundBtn.addEventListener('click', toggleBackgroundMusic);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: toggleSoundBtn not found."); }

        if (toggleEffectsSoundBtn) {
            toggleEffectsSoundBtn.addEventListener('click', toggleEffectSounds);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: toggleEffectsSoundBtn not found."); }

        if (exportImportBtn) {
            exportImportBtn.addEventListener('click', openSavegamePopup);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: exportImportBtn not found."); }
		 if (dailyQuestBtn) { // <<< THÊM LISTENER CHO NÚT NHIỆM VỤ
        dailyQuestBtn.addEventListener('click', openDailyQuestPopup);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: dailyQuestBtn not found."); }
		
		
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: menuPopup element not found, skipping child listeners."); }


    // --- KHU VƯỜN (Sử dụng Ủy Quyền Sự Kiện - Event Delegation) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Garden area listeners...");
    if (gardenElement) {
        gardenElement.addEventListener('click', handleGardenClick);
        gardenElement.addEventListener('mouseover', handlePlotMouseover);
        gardenElement.addEventListener('mouseout', handlePlotMouseout);
        gardenElement.addEventListener('mousemove', handlePlotMousemove);
        listenerCount += 4; // Đếm 4 listeners đã gắn
        console.log("[V10 Buy Fix attachEventListeners] Garden listeners attached successfully.");
    } else {
        console.error("[V10 Buy Fix attachEventListeners] FATAL ERROR: gardenElement not found! Plot interactions will not work.");
    }

    // --- ĐÓNG MODAL/POPUP TOÀN CỤC ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching global modal/popup closing listeners...");
    window.addEventListener('click', handleModalBackgroundClick);
    document.addEventListener('keydown', handleEscapeKey);
    listenerCount += 2;

    // --- TABS TRONG CÁC MODAL ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Tab listeners...");
    if (shopTabsContainer) {
        shopTabsContainer.addEventListener('click', handleShopTabClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: shopTabsContainer not found."); }

    if (inventoryTabsContainer) {
        inventoryTabsContainer.addEventListener('click', handleInventoryTabClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: inventoryTabsContainer not found."); }

    // --- DANH SÁCH VẬT PHẨM (Ủy quyền) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Item List listeners (Shop & Inventory)...");
    // Cửa hàng (Mua và thay đổi số lượng) - Gắn listener vào container cha
    if (shopSeedList) {
        shopSeedList.addEventListener('click', handleShopItemClick); // Xử lý click nút Mua
        shopSeedList.addEventListener('input', handleShopQuantityChange); // Xử lý thay đổi input
        shopSeedList.addEventListener('change', handleShopQuantityChange); // Backup listener cho input
        listenerCount += 3;
        console.log("[V10 Buy Fix attachEventListeners] Shop Seed List listeners attached.");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: shopSeedList not found."); }

    if (shopToolList) {
        shopToolList.addEventListener('click', handleShopItemClick); // Xử lý click nút Mua
        shopToolList.addEventListener('input', handleShopQuantityChange); // Xử lý thay đổi input
        shopToolList.addEventListener('change', handleShopQuantityChange); // Backup listener cho input
        listenerCount += 3;
        console.log("[V10 Buy Fix attachEventListeners] Shop Tool List listeners attached.");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: shopToolList not found."); }

    // Kho đồ (Bán và Bỏ) - Gắn listener vào container cha
    if (inventoryHarvestedList) {
        inventoryHarvestedList.addEventListener('click', handleSellHarvestedClick); // Xử lý click nút Bán / Bán hết
        listenerCount++;
        console.log("[V10 Buy Fix attachEventListeners] Inventory Harvested List listeners attached.");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: inventoryHarvestedList not found."); }

    if (inventoryPurchasedList) {
        inventoryPurchasedList.addEventListener('click', handleDiscardPurchasedItemClick); // Xử lý click nút Bỏ đi...
        listenerCount++;
        console.log("[V10 Buy Fix attachEventListeners] Inventory Purchased List listeners attached.");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: inventoryPurchasedList not found."); }

    // --- MODAL LỰA CHỌN (Ủy quyền) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Selection Modal listeners...");
    if (seedSelectionList) {
        seedSelectionList.addEventListener('click', handleSeedSelectionClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: seedSelectionList not found."); }

    if (fertilizerSelectionList) {
        fertilizerSelectionList.addEventListener('click', handleFertilizerSelection);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: fertilizerSelectionList not found."); }

    // --- MODAL HÀNH ĐỘNG (Ủy quyền) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Action Modal listeners...");
    if (plantActionButtonsContainer) {
        plantActionButtonsContainer.addEventListener('click', handlePlantActionClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: plantActionButtonsContainer not found."); }

    if (emptyPlotActionButtonsContainer) {
        emptyPlotActionButtonsContainer.addEventListener('click', handleEmptyPlotActionClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: emptyPlotActionButtonsContainer not found."); }

    if (lightningRodActionModal) {
        const rodButtonsContainer = lightningRodActionModal.querySelector('#rod-action-buttons');
        if (rodButtonsContainer) {
            rodButtonsContainer.addEventListener('click', handleRodActionClick);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: #rod-action-buttons container not found inside lightningRodActionModal."); }
        // Nút đóng cho modal này đã được xử lý bởi listener toàn cục hoặc Escape
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: lightningRodActionModal not found."); }

    // --- POPUP XÁC NHẬN CỤ THỂ (Gắn listener trực tiếp vào nút con) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Confirmation Popup button listeners...");

    // Popup Mua Ô Đất
    if (lockedPlotPopup) {
        if (confirmBuyPlotBtn) { confirmBuyPlotBtn.addEventListener('click', handleConfirmBuyPlot); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmBuyPlotBtn not found in lockedPlotPopup."); }
        if (cancelBuyPlotBtn) { cancelBuyPlotBtn.addEventListener('click', closeLockedPlotPopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: cancelBuyPlotBtn not found in lockedPlotPopup."); }
        const lockedPlotCloseBtn = lockedPlotPopup.querySelector('.close-popup-btn');
        if (lockedPlotCloseBtn) { lockedPlotCloseBtn.addEventListener('click', closeLockedPlotPopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: .close-popup-btn not found in lockedPlotPopup."); }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: lockedPlotPopup element not found."); }

    // Popup Xác nhận Bán Hết
    if (confirmSellAllModal) {
        if (confirmSellAllBtn) { confirmSellAllBtn.addEventListener('click', handleConfirmSellAll); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirm-sell-all-btn not found."); }
        if (cancelSellAllBtn) { cancelSellAllBtn.addEventListener('click', closeConfirmSellAllModal); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: cancel-sell-all-btn not found."); }
        const closeSellAllPopupBtn = confirmSellAllModal.querySelector('.close-button');
        if(closeSellAllPopupBtn) { closeSellAllPopupBtn.addEventListener('click', closeConfirmSellAllModal); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: .close-button not found in confirmSellAllModal."); }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmSellAllModal element not found."); }

    // Popup Bỏ Vật Phẩm
    if (discardItemPopup) {
        if (confirmDiscardBtn) { confirmDiscardBtn.addEventListener('click', handleConfirmDiscardClick); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmDiscardBtn not found."); }
        if (cancelDiscardBtn) { cancelDiscardBtn.addEventListener('click', closeDiscardItemPopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: cancelDiscardBtn not found."); }
        const closeDiscardPopupBtn = discardItemPopup.querySelector('.close-button');
        if (closeDiscardPopupBtn) { closeDiscardPopupBtn.addEventListener('click', closeDiscardItemPopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: .close-button not found in discardItemPopup."); }
        if (discardQuantityInput) { // Gắn listener cho input số lượng bỏ
            discardQuantityInput.addEventListener('input', () => {
                if (confirmDiscardBtn) confirmDiscardBtn.disabled = false;
                if (discardQuantityError) { discardQuantityError.textContent = ''; discardQuantityError.style.display = 'none'; }
            });
            listenerCount++;
            discardQuantityInput.addEventListener('blur', () => { // Kiểm tra khi mất focus
                const qty = parseInt(discardQuantityInput.value); const max = parseInt(discardQuantityInput.max); let err = '';
                if (isNaN(qty) || qty < 1) err = 'SL > 0.'; else if (qty > max) err = `SL <= ${max}.`;
                if (err && discardQuantityError && confirmDiscardBtn) { discardQuantityError.textContent = err; discardQuantityError.style.display = 'block'; confirmDiscardBtn.disabled = true; }
                else if (discardQuantityError && confirmDiscardBtn) { discardQuantityError.textContent = ''; discardQuantityError.style.display = 'none'; confirmDiscardBtn.disabled = false; }
            });
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: discardQuantityInput not found."); }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: discardItemPopup element not found."); }

    // Popup Xác nhận Sửa Cột Thu Lôi
    if (confirmRepairRodPopup) {
        const confirmBtn = confirmRepairRodPopup.querySelector('#confirm-repair-rod-btn');
        const cancelBtn = confirmRepairRodPopup.querySelector('#cancel-repair-rod-btn');
        const closeBtn = confirmRepairRodPopup.querySelector('.close-popup-btn');
        if (confirmBtn) { confirmBtn.addEventListener('click', handleConfirmRepair); listenerCount++; } else console.warn("Missing confirm-repair-rod-btn");
        if (cancelBtn) { cancelBtn.addEventListener('click', closeConfirmRepairPopup); listenerCount++; } else console.warn("Missing cancel-repair-rod-btn");
        if (closeBtn) { closeBtn.addEventListener('click', closeConfirmRepairPopup); listenerCount++; } else console.warn("Missing close-popup-btn in confirm-repair-rod-popup");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmRepairRodPopup not found."); }

    // Popup Xác nhận Gỡ Cột Thu Lôi
    if (confirmRemoveRodPopup) {
        const confirmBtn = confirmRemoveRodPopup.querySelector('#confirm-remove-rod-btn');
        const cancelBtn = confirmRemoveRodPopup.querySelector('#cancel-remove-rod-btn');
        const closeBtn = confirmRemoveRodPopup.querySelector('.close-popup-btn');
        if (confirmBtn) { confirmBtn.addEventListener('click', handleConfirmRemove); listenerCount++; } else console.warn("Missing confirm-remove-rod-btn");
        if (cancelBtn) { cancelBtn.addEventListener('click', closeConfirmRemovePopup); listenerCount++; } else console.warn("Missing cancel-remove-rod-btn");
        if (closeBtn) { closeBtn.addEventListener('click', closeConfirmRemovePopup); listenerCount++; } else console.warn("Missing close-popup-btn in confirm-remove-rod-popup");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmRemoveRodPopup not found."); }

    // Popup Lưu/Nhập Game
    if (savegamePopup) {
        const closeSavegamePopupBtn = savegamePopup.querySelector('.close-button');
        if (closeSavegamePopupBtn) { closeSavegamePopupBtn.addEventListener('click', closeSavegamePopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: Close button not found in savegamePopup."); }
        if (btnSaveGame) { btnSaveGame.addEventListener('click', exportGameStateToFile); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: btn-savegame not found."); }
        if (btnImportSaveGame) { btnImportSaveGame.addEventListener('click', importGameStateFromFile); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: btn-import-savegame not found."); }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: savegamePopup element not found."); }

    // Popup Xác nhận Khôi Phục Game
    const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
    if (confirmRestorePopup) {
        const confirmBtn = confirmRestorePopup.querySelector('#confirm-restore-btn');
        const cancelBtn = confirmRestorePopup.querySelector('#cancel-restore-btn');
        const closeBtn = confirmRestorePopup.querySelector('.close-button');
        if (confirmBtn) { confirmBtn.addEventListener('click', handleConfirmRestore); listenerCount++; }
        else console.warn("Missing #confirm-restore-btn in #popup-confirm-restoregame");
        if (cancelBtn) { cancelBtn.addEventListener('click', handleCancelRestore); listenerCount++; }
        else console.warn("Missing #cancel-restore-btn in #popup-confirm-restoregame");
        if (closeBtn) { closeBtn.addEventListener('click', handleCancelRestore); listenerCount++; } // Nút X cũng là hủy
        else console.warn("Missing .close-button in #popup-confirm-restoregame");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: popup-confirm-restoregame not found."); }

    // Popup Phần Thưởng Hạt Ngọc Trời
    if (hatNgocTroiRewardPopup) {
        if (confirmRewardBtn) {
            confirmRewardBtn.addEventListener('click', grantRewardAndClosePopup);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmRewardBtn not found for reward popup."); }
        // Nút đóng khác nếu có
        const closeRewardPopupBtn = hatNgocTroiRewardPopup.querySelector('.close-button');
        if (closeRewardPopupBtn) {
            closeRewardPopupBtn.addEventListener('click', closeRewardPopup); // Đảm bảo cũng đóng popup
            listenerCount++;
        }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: hat-ngoc-troi-reward-popup element not found."); }

    // --- SỰ KIỆN VÒNG ĐỜI TRANG ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Page Lifecycle listeners...");
    window.addEventListener('beforeunload', handlePageUnload);
    document.addEventListener('visibilitychange', handleVisibilityChange);
    listenerCount += 2;

    console.log(`[V10 Buy Fix attachEventListeners] Finished attaching approximately ${listenerCount} event listeners.`);
} // --- Kết thúc hàm attachEventListeners ---

        /** Khởi tạo hoặc xác thực mảng dữ liệu gameState.plots dựa trên maxUnlockedPlots */
        function initializePlotsData() {
    // Trạng thái mặc định cho một ô đất, bao gồm các trường mới nhất
    const defaultPlotState = {
        seedId: null,               // ID hạt giống đang trồng (null nếu trống)
        plantTime: null,            // Timestamp khi bắt đầu trồng
        hasPest: false,             // Cờ báo có sâu hay không
        health: INITIAL_PLANT_HEALTH, // Máu hiện tại của cây
        fertility: BASE_FERTILITY,  // Độ phì nhiêu hiện tại của đất (%)
        causeOfDeath: null,         // Nguyên nhân chết ('pest' hoặc null)
        pestDeathClickCount: 0,     // Số lần click để dọn cây chết do sâu miễn phí
        barrenHarvestPenaltyFactor: 1.0, // Hệ số nhân thời gian mọc nếu thu hoạch trên đất cằn
        isDry: false,                // Trạng thái khô hạn
        fenceData: null,            // Dữ liệu hàng rào
        fertilizerGrowthUsageCount: 0, // Số lần dùng Phân Bón Tăng Trưởng
        // --- THÊM MỚI ---
        fertilizerProtectUsageCount: 0, // Số lần dùng Phân Bón Bảo Vệ
        hasFertilizerProtectBuff: false // Cờ báo buff bảo vệ sâu bệnh đang hoạt động
        // --- KẾT THÚC THÊM MỚI ---
    };

    // Đảm bảo mảng có đủ chỗ cho các ô đã mở khóa
    while (gameState.plots.length < gameState.maxUnlockedPlots) {
        const newId = gameState.plots.length;
        gameState.plots.push({ id: newId, ...JSON.parse(JSON.stringify(defaultPlotState)) });
    }

    // Xác thực dữ liệu các ô hiện có (quan trọng khi tải từ save cũ hoặc lỗi)
    for(let i = 0; i < gameState.plots.length; i++) {
         const savedPlotData = gameState.plots[i] || {}; // Lấy dữ liệu lưu, hoặc object rỗng nếu ko có
         gameState.plots[i] = {
            ...JSON.parse(JSON.stringify(defaultPlotState)), // Bắt đầu với mặc định mới nhất
            ...savedPlotData,                                 // Ghi đè bằng dữ liệu đã tải
            id: i // Luôn đảm bảo ID đúng
         };
         // Giới hạn các giá trị số trong khoảng hợp lệ
         const plot = gameState.plots[i];
         plot.health = Math.max(0, Math.min(INITIAL_PLANT_HEALTH, plot.health));
         plot.fertility = Math.max(0, Math.min(BASE_FERTILITY, plot.fertility));
         plot.pestDeathClickCount = Math.max(0, plot.pestDeathClickCount || 0);
         plot.barrenHarvestPenaltyFactor = Math.max(1.0, plot.barrenHarvestPenaltyFactor || 1.0); // Đảm bảo không nhỏ hơn 1
         plot.isDry = !!plot.isDry; // Đảm bảo là boolean
         plot.fertilizerGrowthUsageCount = Math.max(0, parseInt(plot.fertilizerGrowthUsageCount || 0)); // Đảm bảo là số không âm

         // --- THÊM VALIDATE MỚI ---
         plot.fertilizerProtectUsageCount = Math.max(0, parseInt(savedPlotData.fertilizerProtectUsageCount || 0));
         // Load buff, đảm bảo nó chỉ bật nếu có cây sống và count > 0
         plot.hasFertilizerProtectBuff = (typeof savedPlotData.hasFertilizerProtectBuff === 'boolean' && plot.seedId && plot.health > 0 && plot.fertilizerProtectUsageCount > 0) ? savedPlotData.hasFertilizerProtectBuff : false;
         // Đảm bảo count và buff đồng bộ (nếu buff on thì count > 0, nếu count=0 thì buff off)
         if (plot.hasFertilizerProtectBuff && plot.fertilizerProtectUsageCount <= 0) {
              plot.hasFertilizerProtectBuff = false;
         } else if (!plot.hasFertilizerProtectBuff && plot.fertilizerProtectUsageCount > 0 && (!plot.seedId || plot.health <= 0)) {
              // Nếu ô trống/chết nhưng count > 0 -> reset count (buff đã tắt ở trên)
              plot.fertilizerProtectUsageCount = 0;
         }
         // --- KẾT THÚC VALIDATE MỚI ---

         // <<< THÊM: Validate fenceData >>>
         if (savedPlotData.fenceData && typeof savedPlotData.fenceData === 'object' && savedPlotData.fenceData.id === 'raobaove' && ITEM_DATA.raobaove) {
             const fenceHealth = parseInt(savedPlotData.fenceData.health);
             if (!isNaN(fenceHealth) && fenceHealth >= 0 && fenceHealth <= ITEM_DATA.raobaove.health) {
                 plot.fenceData = { id: 'raobaove', health: fenceHealth };
             } else {
                  console.warn(`initializePlotsData: Fence health không hợp lệ ở ô ${i}, loại bỏ fenceData.`);
                  plot.fenceData = null;
             }
         } else {
             plot.fenceData = null; // Mặc định là null nếu không có hoặc không hợp lệ
         }
         // <<< KẾT THÚC: Validate fenceData >>>

         // Kiểm tra và reset trạng thái cây nếu dữ liệu không hợp lệ
         if (plot.seedId && (!plot.plantTime || !ITEM_DATA[plot.seedId])) {
             console.warn(`Dữ liệu cây ở ô ${i} không hợp lệ (seed: ${plot.seedId}, time: ${plot.plantTime}). Đang reset ô.`);
             const currentFertility = plot.fertility;
             const currentPenaltyFactor = plot.barrenHarvestPenaltyFactor;
             const currentIsDry = plot.isDry;
             const currentFenceData = plot.fenceData; // Giữ lại hàng rào khi reset lỗi
             Object.assign(plot, JSON.parse(JSON.stringify(defaultPlotState))); // Reset về mặc định (đã bao gồm thuộc tính mới)
             plot.id = i; // Giữ lại ID
             plot.fertility = currentFertility; // Phục hồi
             plot.barrenHarvestPenaltyFactor = currentPenaltyFactor; // Phục hồi
             plot.isDry = currentIsDry; // Phục hồi trạng thái khô hạn
             plot.fenceData = currentFenceData; // Phục hồi hàng rào
         }
         // Nếu cây đang sống nhưng buff bảo vệ lại bật mà count = 0 -> tắt buff đi (double check)
         else if (plot.seedId && plot.health > 0 && plot.hasFertilizerProtectBuff && plot.fertilizerProtectUsageCount <= 0) {
             plot.hasFertilizerProtectBuff = false;
             console.warn(`Plot ${i}: Fixed inconsistent fertilizer protect buff state (buff on but count is 0).`);
         }
         // Nếu cây chết hoặc ô trống nhưng buff vẫn bật -> tắt buff và reset count
         else if ((!plot.seedId || plot.health <= 0) && plot.hasFertilizerProtectBuff) {
             plot.hasFertilizerProtectBuff = false;
             plot.fertilizerProtectUsageCount = 0;
             console.warn(`Plot ${i}: Reset fertilizer protect buff on empty/dead plot.`);
         }
    }
    console.log(`Đã khởi tạo/xác thực dữ liệu cho ${gameState.plots.length} ô đất (bao gồm isDry, protect buff).`);
}
// --- Kết thúc hàm initializePlotsData ---


        /** Tạo hoặc cập nhật các phần tử DOM cho ô đất trong khu vườn */
        function renderGarden() {
            // --- Code khởi tạo ---
            gardenElement.innerHTML = ''; // Xóa nội dung cũ
            const now = Date.now();
            let offlineMessages = { pestFound: false, plantDied: false };
            const tornadoAffectedPlotIds = new Set(gameState.activeTornadoes.map(t => t.plotId));

            // --- [HÀM TRỢ GIÚP VẼ HÀNG RÀO - Đặt bên trong] ---
            const renderFenceIfNeeded = (targetElement, currentPlotData) => {
                const existingFenceVisual = targetElement.querySelector('.fence-visual-container');
                if (existingFenceVisual) targetElement.removeChild(existingFenceVisual);
                const existingFenceHealth = targetElement.querySelector('.fence-health-bar-wrapper');
                if (existingFenceHealth) targetElement.removeChild(existingFenceHealth);

                if (currentPlotData && currentPlotData.fenceData && ITEM_DATA.raobaove) {
                    const fenceItem = ITEM_DATA.raobaove;
                    const isFenceBroken = currentPlotData.fenceData.health <= 0;

                    // Visual Hàng Rào
                    const fenceVisualContainer = document.createElement('div');
                    fenceVisualContainer.classList.add('fence-visual-container');
                    fenceVisualContainer.style.cssText = `position: absolute; top: 13px; left: 0; width: 100%; height: 40%; display: flex; justify-content: center; align-items: flex-start; z-index: 2; pointer-events: none; opacity: ${isFenceBroken ? 0.6 : 0.9};`;
                    const fenceImg = document.createElement('img');
                    fenceImg.src = isFenceBroken ? `${fenceItem.imageFolder}/${fenceItem.brokenImageFile}` : `${fenceItem.imageFolder}/${fenceItem.imageFile}`;
                    fenceImg.alt = isFenceBroken ? "Rào bảo vệ hỏng" : "Rào bảo vệ";
                    fenceImg.style.cssText = `max-width: 120%; max-height: 120%; object-fit: contain;`;
                    fenceImg.onerror = () => { if (fenceImg.src !== 'Hinhanh/Caychet.png') fenceImg.src = 'Hinhanh/Caychet.png'; };
                    fenceVisualContainer.appendChild(fenceImg);
                    targetElement.appendChild(fenceVisualContainer);

                    // Thanh máu Hàng Rào (chỉ hiện khi chưa hỏng)
                    if (!isFenceBroken) {
                        const fenceHealthWrapper = document.createElement('div');
                        fenceHealthWrapper.classList.add('bar-wrapper', 'fence-health-bar-wrapper');
                        fenceHealthWrapper.style.cssText = `position: absolute; top: 2px; width: 60%; height: 4px; left: 20%; background-color: #555; border-radius: 2px; overflow: hidden; border: 1px solid #333; z-index: 3;`;
                        const fenceHealthFill = document.createElement('div');
                        fenceHealthFill.classList.add('bar-fill');
                        const fenceHealthPercent = (currentPlotData.fenceData.health / fenceItem.health) * 100;
                        fenceHealthFill.style.width = `${fenceHealthPercent}%`;
                        fenceHealthFill.style.backgroundColor = fenceHealthPercent < 30 ? '#ff9800' : (fenceHealthPercent < 60 ? '#03A9F4' : '#2196F3');
                        fenceHealthWrapper.appendChild(fenceHealthFill);
                        targetElement.appendChild(fenceHealthWrapper);
                    }
                }
            };
            // --- [KẾT THÚC HÀM TRỢ GIÚP VẼ HÀNG RÀO] ---

            // --- Vòng lặp qua các ô đất (bao gồm ô khóa tiếp theo) ---
            for (let i = 0; i <= gameState.maxUnlockedPlots; i++) {
                const isUnlocked = i < gameState.maxUnlockedPlots;
                const plotData = isUnlocked ? gameState.plots[i] : null;
                const rodData = isUnlocked ? getRodData(i) : null; // Lấy dữ liệu cột thu lôi
                const plotElement = document.createElement('div');
                plotElement.classList.add('plot');
                plotElement.dataset.plotId = i;

                // Xử lý hiệu ứng lốc xoáy (nếu có)
                const isAffectedByTornado = tornadoAffectedPlotIds.has(i);
                plotElement.classList.toggle('tornado-affected', isAffectedByTornado);
                const existingTornadoEmoji = plotElement.querySelector('.tornado-emoji-container');
                if (existingTornadoEmoji) plotElement.removeChild(existingTornadoEmoji);
                if (isAffectedByTornado) {
                    const tornadoEmojiContainer = document.createElement('div');
                    tornadoEmojiContainer.classList.add('tornado-emoji-container'); tornadoEmojiContainer.textContent = '🌪️';
                    plotElement.appendChild(tornadoEmojiContainer);
                }

                // --- Xử lý Ô Đất Bị Khóa ---
                if (!isUnlocked) {
                    plotElement.classList.add('locked');
                    const cost = calculatePlotCost(i);
                    const plotInfo = document.createElement('div'); plotInfo.classList.add('plot-info');
                    plotInfo.textContent = `🔒 Khóa (Mua: ${cost}💰)`;
                    plotElement.appendChild(plotInfo);
                }
                // --- Xử lý Ô Đất Có Cột Thu Lôi ---
                else if (rodData) {
                    // ... (Code vẽ cột thu lôi, thanh máu, thông tin như trong hàm gốc - không thay đổi) ...
                     plotElement.classList.add('has-lightning-rod');
                     plotElement.classList.toggle('broken', rodData.health <= 0);
                     const visualContainerRod = document.createElement('div'); visualContainerRod.classList.add('plant-visual-container');
                     const rodVisual = document.createElement('div'); rodVisual.classList.add('plant-visual', 'visible');
                     const rodImg = document.createElement('img'); rodImg.src = 'Hinhanh/pic_cotthuloi.png'; rodImg.alt = 'Cột thu lôi'; rodImg.style.cssText = 'max-width: 60%; max-height: 60%; object-fit: contain;';
                     rodImg.onerror = () => { if (rodImg.src !== 'Hinhanh/Caychet.png') rodImg.src = 'Hinhanh/Caychet.png'; };
                     rodVisual.appendChild(rodImg); visualContainerRod.appendChild(rodVisual); plotElement.appendChild(visualContainerRod);
                     const barsContainerRod = document.createElement('div'); barsContainerRod.classList.add('bars-container');
                     const rodHealthWrapper = document.createElement('div'); rodHealthWrapper.classList.add('bar-wrapper', 'health-bar-wrapper'); rodHealthWrapper.style.display = 'block';
                     const rodHealthFill = document.createElement('div'); rodHealthFill.classList.add('bar-fill', 'health-bar-fill');
                     const rodHealthPercent = (rodData.health / LIGHTNING_ROD_MAX_HEALTH) * 100; rodHealthFill.style.width = `${rodHealthPercent}%`;
                     if (rodData.health <= 0) { rodHealthFill.style.backgroundColor = '#757575'; } else if (rodData.health <= LIGHTNING_ROD_MAX_HEALTH * 0.25) { rodHealthFill.classList.add('low-health'); } else if (rodData.health <= LIGHTNING_ROD_MAX_HEALTH * 0.6) { rodHealthFill.classList.add('medium-health'); }
                     rodHealthWrapper.appendChild(rodHealthFill); barsContainerRod.appendChild(rodHealthWrapper); plotElement.appendChild(barsContainerRod);
                     const plotInfoRod = document.createElement('div'); plotInfoRod.classList.add('plot-info');
                     if (rodData.health <= 0) { plotInfoRod.textContent = `⚡ Cột thu lôi (Hỏng!)`; plotInfoRod.style.backgroundColor = 'rgba(100, 0, 0, 0.7)'; } else { plotInfoRod.textContent = `⚡ Cột thu lôi (HP: ${rodData.health}/${LIGHTNING_ROD_MAX_HEALTH})`; }
                     plotElement.appendChild(plotInfoRod);
                }
                // --- Xử lý Ô Đất Bình Thường (Không khóa, không rod) ---
                else if (plotData) {
                     const isBarren = plotData.fertility <= 0;
                     plotElement.classList.toggle('barren-soil', isBarren); // Class đất cằn
                     plotElement.classList.toggle('dry-soil-effect', plotData.isDry); // Class đất khô
                     plotElement.classList.toggle('infested', plotData.hasPest); // Class có sâu

                     // Tạo cấu trúc DOM cơ bản (visual, icon sâu, thanh bar, info, gif sét)
                     const visualContainer = document.createElement('div'); visualContainer.classList.add('plant-visual-container');
                     const plantVisual = document.createElement('div'); plantVisual.classList.add('plant-visual'); visualContainer.appendChild(plantVisual);
                     const pestIcon = document.createElement('div'); pestIcon.classList.add('pest-icon'); pestIcon.textContent = '🐛'; pestIcon.style.display = plotData.hasPest ? 'block' : 'none'; visualContainer.appendChild(pestIcon);
                     plotElement.appendChild(visualContainer);
                     const barsContainer = document.createElement('div'); barsContainer.classList.add('bars-container');
                     const healthBarWrapper = document.createElement('div'); healthBarWrapper.classList.add('bar-wrapper', 'health-bar-wrapper'); healthBarWrapper.style.display = 'none';
                     const healthBarFill = document.createElement('div'); healthBarFill.classList.add('bar-fill', 'health-bar-fill'); healthBarWrapper.appendChild(healthBarFill); barsContainer.appendChild(healthBarWrapper);
                     const fertilityBarWrapper = document.createElement('div'); fertilityBarWrapper.classList.add('bar-wrapper', 'fertility-bar-wrapper');
                     const fertilityBarFill = document.createElement('div'); fertilityBarFill.classList.add('bar-fill', 'fertility-bar-fill'); fertilityBarWrapper.appendChild(fertilityBarFill); barsContainer.appendChild(fertilityBarWrapper);
                     const plotInfo = document.createElement('div'); plotInfo.classList.add('plot-info');
                     plotElement.appendChild(barsContainer); plotElement.appendChild(plotInfo);
                     const gifContainer = document.createElement('div'); gifContainer.classList.add('lightning-gif-container'); const gifImage = document.createElement('img'); gifImage.src = 'Hinhanh/hieuungsetdanh.gif'; gifImage.alt = 'Hiệu ứng sét đánh'; gifContainer.appendChild(gifImage); plotElement.appendChild(gifContainer);

                     // --- !!! GỌI HÀM VẼ HÀNG RÀO (nếu có) !!! ---
                     renderFenceIfNeeded(plotElement, plotData);
                     // --- !!! KẾT THÚC GỌI HÀM VẼ HÀNG RÀO !!! ---

                     // Cập nhật class low-fertility (nếu không cằn)
                     const isLowFertility = plotData.fertility < LOW_FERTILITY_THRESHOLD;
                     plotElement.classList.toggle('low-fertility', isLowFertility && !isBarren);

                     // Lấy thông tin cây và hạt giống
                     const stageInfo = getPlantStageInfo(plotData, now);
                     const seedInfo = plotData.seedId ? ITEM_DATA[plotData.seedId] : null;

                     // Cập nhật THANH PHÌ NHIÊU
                     const fertilityPercent = Math.max(0, plotData.fertility);
                     fertilityBarFill.style.width = `${fertilityPercent}%`;
                     fertilityBarFill.className = 'bar-fill fertility-bar-fill'; // Reset class
                     if (isBarren) fertilityBarFill.classList.add('barren'); else if (isLowFertility) fertilityBarFill.classList.add('low-fertility'); else if (fertilityPercent < 60) fertilityBarFill.classList.add('medium-fertility');

                     // --- Xử lý khi CÓ CÂY trồng trên ô ---
                     if (plotData.seedId && plotData.plantTime && seedInfo) {
                         plotElement.classList.add('planted');
                         healthBarWrapper.style.display = 'block'; // Hiện thanh máu

                         if (stageInfo && !stageInfo.isError) {
                             // Cập nhật hình ảnh cây
                             let img = plantVisual.querySelector('img'); if (!img) { img = document.createElement('img'); plantVisual.appendChild(img); }
                             const imgSrc = stageInfo.visualSrc || 'Hinhanh/Caychet.png'; if (img.src !== imgSrc) img.src = imgSrc; img.alt = seedInfo.name;
                             img.onerror = () => { if (img.src !== 'Hinhanh/Caychet.png') img.src = 'Hinhanh/Caychet.png'; };
                             plantVisual.classList.add('visible');
                             // Cập nhật class chết
                             plantVisual.classList.toggle('stage-dead', stageInfo.isDead);
                             plantVisual.classList.toggle('pest-death', stageInfo.isDead && (plotData.causeOfDeath === 'pest' || plotData.causeOfDeath === 'lightning' || plotData.causeOfDeath === 'tornado'));

                             // Cập nhật THANH MÁU CÂY
                             const healthPercent = Math.max(0, plotData.health);
                             healthBarFill.style.width = `${healthPercent}%`;
                             healthBarFill.className = 'bar-fill health-bar-fill'; // Reset
                             if (healthPercent < 30) healthBarFill.classList.add('low-health'); else if (healthPercent < 70) healthBarFill.classList.add('medium-health');

                             // Cập nhật thông tin text (plotInfo) bao gồm Hàng Rào
                             // Chuẩn bị các phần thông tin
                             const fertilityText = isBarren ? ' (Đất CẰN!)' : ` (Đất: ${Math.round(plotData.fertility)}%)`;
                             const dryText = plotData.isDry ? ' (Khô!)' : '';
                             const pestText = plotData.hasPest ? ' (Có sâu!)' : ''; // Có sâu không?
                             const fenceText = plotData.fenceData ? (plotData.fenceData.health > 0 ? ` | 🚧(${Math.round(plotData.fenceData.health)}%)` : ' | 🚧(Hỏng!)') : '';
                             let barrenWarning = ''; if (isBarren && plotData.barrenHarvestPenaltyFactor > 1.0) barrenWarning = ` (Mọc CHẬM x${plotData.barrenHarvestPenaltyFactor.toFixed(2)}!)`; else if (isBarren) barrenWarning = ' (Đất CẰN!)';

                             // Xóa class cũ của plotInfo trước khi thêm mới
                             plotInfo.classList.remove('needs-cleanup-fee', 'free-cleanup-progress', 'broken-fence-info');
                             let infoText = ''; // Reset infoText

                             // Ưu tiên hiển thị thông báo RÀO HỎNG
                             if (plotData.fenceData && plotData.fenceData.health <= 0) {
                                 const removeCost = ITEM_DATA.raobaove?.removeCost || 5;
                                 infoText = `🚧 Rào Hỏng! Gỡ bỏ (${removeCost}💰)`;
                                 plotInfo.classList.add('broken-fence-info');
                             }
                             // --- Logic hiển thị trạng thái cây/đất (nếu rào không hỏng) ---
                             else {
                                 if (plotData.hasPest) { // <<<< ƯU TIÊN HIỂN THỊ SÂU
                                     infoText = `🐛 SÂU!${pestText} (${seedInfo.name}) - HP: ${Math.round(plotData.health)}%${fertilityText}${dryText}${fenceText}`;
                                 } else if (stageInfo.isMature && plotData.health > 0) { // Trưởng thành VÀ KHÔNG có sâu
                                     infoText = `✅ Thu hoạch (${seedInfo.name})${fertilityText}${dryText}${fenceText}`;
                                 } else if (plotData.health <= 0) { // Cây chết (và không có sâu)
                                     let deathReasonText = '';
                                     switch (plotData.causeOfDeath) {
                                         case 'pest': deathReasonText = 'Do Sâu'; break; // Trường hợp này không nên xảy ra ở nhánh này, nhưng để phòng ngừa
                                         case 'dryness': deathReasonText = 'Do Khô Hạn'; break;
                                         case 'lightning': deathReasonText = 'Do Sét Đánh'; break;
                                         case 'tornado': deathReasonText = 'Do Gió Lốc'; break;
                                         default: deathReasonText = 'Tự nhiên';
                                     }
                                     // Xử lý hiển thị cho dọn sâu chết (nếu logic trước bị sót)
                                     if (plotData.causeOfDeath === 'pest') {
                                         const hasEnoughMoney = gameState.currency >= DEAD_PEST_CLEANUP_COST;
                                         if (!hasEnoughMoney && plotData.pestDeathClickCount > 0) {
                                             const clicksRemaining = DEAD_PEST_FREE_CLEANUP_CLICKS - plotData.pestDeathClickCount;
                                             infoText = `💀 Chết (${deathReasonText})! Click ${clicksRemaining} lần...${dryText}${fenceText}`;
                                             plotInfo.classList.add('free-cleanup-progress');
                                         } else {
                                             infoText = `💀 Chết (${deathReasonText})! - Dọn (${DEAD_PEST_CLEANUP_COST}💰)${fertilityText}${dryText}${fenceText}`;
                                             plotInfo.classList.add('needs-cleanup-fee');
                                         }
                                     } else { // Chết do nguyên nhân khác
                                         infoText = `💀 Chết (${deathReasonText}) - Click dọn${fertilityText}${dryText}${fenceText}`;
                                     }
                                     if (tickCounter <= 1) offlineMessages.plantDied = true;
                                 } else { // Cây đang lớn (không sâu)
                                     const effectiveGrowthTimeMs = stageInfo.effectiveGrowthTimeSec * 1000;
                                     const timeRemaining = Math.max(0, effectiveGrowthTimeMs - (now - plotData.plantTime));
                                     infoText = `${seedInfo.name} (${Math.round(stageInfo.growthProgress * 100)}%) - ${formatTime(timeRemaining, true)}${fertilityText}${barrenWarning}${dryText}${fenceText}`;
                                 }
                             }
                             plotInfo.textContent = infoText; // Gán nội dung text cuối cùng
                         } else { // Lỗi cây trồng
                             // ... (xử lý lỗi như cũ, nhưng thêm fenceText vào infoText) ...
                             let img = plantVisual.querySelector('img'); if (!img) { img = document.createElement('img'); plantVisual.appendChild(img); }
                             img.src = 'Hinhanh/General/ErrorPlant.png'; img.alt = 'Lỗi';
                             plantVisual.classList.add('visible', 'stage-dead');
                             const fertilityTextError = isBarren ? ' (Đất CẰN!)' : ` (Đất: ${Math.round(plotData.fertility)}%)`;
                             const dryTextError = plotData.isDry ? ' (Khô!)' : '';
                             const fenceTextError = plotData.fenceData ? (plotData.fenceData.health > 0 ? ` | 🚧(${Math.round(plotData.fenceData.health)}%)` : ' | 🚧(Hỏng!)') : ''; // Thêm fenceText
                             plotInfo.textContent = `Lỗi cây trồng${fertilityTextError}${dryTextError}${fenceTextError}`;
                             healthBarWrapper.style.display = 'block';
                             const healthPercent = Math.max(0, plotData.health); healthBarFill.style.width = `${healthPercent}%`; healthBarFill.className = 'bar-fill health-bar-fill';
                             if (healthPercent < 30) healthBarFill.classList.add('low-health'); else if (healthPercent < 70) healthBarFill.classList.add('medium-health');
                             // Không cần toggle infested vì không có cây hợp lệ
                             pestIcon.style.display = 'none';
                             if (plotData.fenceData && plotData.fenceData.health <= 0) { plotInfo.classList.add('broken-fence-info'); }
                         }
                     }
                     // --- Xử lý khi Ô TRỐNG (Không có cây và không có Rod) ---
                     else {
                         // Gọi hàm vẽ hàng rào đã được thực hiện ở trên
                         const fertilityTextEmpty = isBarren ? ' (Đất CẰN!)' : ` (Độ phì: ${Math.round(plotData.fertility)}%)`;
                         let barrenPenaltyTextEmpty = ''; if (isBarren && plotData.barrenHarvestPenaltyFactor > 1.0) { barrenPenaltyTextEmpty = `\n(Trồng cây sẽ mọc chậm x${plotData.barrenHarvestPenaltyFactor.toFixed(2)})`; }
                         const dryTextEmpty = plotData.isDry ? ' (Khô!)' : '';
                         const fenceTextEmpty = plotData.fenceData ? (plotData.fenceData.health > 0 ? ` | 🚧(${Math.round(plotData.fenceData.health)}%)` : ' | 🚧(Hỏng!)') : '';

                         // Xóa class cũ và xác định nội dung text dựa trên việc có rào hỏng hay không
                         plotInfo.classList.remove('needs-cleanup-fee', 'free-cleanup-progress', 'broken-fence-info');
                         if (plotData.fenceData && plotData.fenceData.health <= 0) {
                             const removeCost = ITEM_DATA.raobaove?.removeCost || 5;
                             plotInfo.textContent = `🚧 Rào Hỏng! Gỡ bỏ (${removeCost}💰)`;
                             plotInfo.classList.add('broken-fence-info');
                         } else {
                             plotInfo.textContent = `Đất trống${fertilityTextEmpty}${dryTextEmpty}${barrenPenaltyTextEmpty}${fenceTextEmpty}`;
                         }

                         // Reset visual cây và trạng thái
                         plantVisual.innerHTML = ''; plantVisual.classList.remove('visible', 'stage-dead', 'pest-death');
                         plotElement.classList.remove('planted', 'infested'); // Chỉ xóa `planted`, `infested`
                         if (!plotData.isDry) plotElement.classList.remove('dry-soil-effect');
                         pestIcon.style.display = 'none';
                     }
                     // --- Kết thúc Xử lý Ô TRỐNG ---

                } else if (!isUnlocked) { /* Ô khóa đã xử lý */ }
                else { /* Lỗi render */ console.error(`Lỗi render: Không tìm thấy dữ liệu cho ô đã mở khóa ${i}`); plotElement.textContent = `Lỗi ô ${i}`; plotElement.style.backgroundColor = 'red'; plotElement.style.color = 'white'; }

                 // Thêm ô vào DOM
                 if (isUnlocked || i === gameState.maxUnlockedPlots) { gardenElement.appendChild(plotElement); }

            } // --- Kết thúc vòng lặp for các ô đất ---

            // Hiển thị thông báo offline (nếu là tick đầu tiên)
            if (tickCounter <= 1) {
                let pestRemainedOffline = false;
                for (let i = 0; i < gameState.maxUnlockedPlots; i++) { if(gameState.plots[i]?.hasPest) { pestRemainedOffline = true; break; }}
                if (pestRemainedOffline) { setTimeout(() => showMessage("Ối! Có vẻ sâu bệnh vẫn còn trên cây khi bạn vắng mặt!", "warning"), 500); }
                else if (offlineMessages.pestFound) { setTimeout(() => showMessage("Có vẻ sâu bệnh đã ghé thăm khi bạn vắng mặt!", "warning"), 500); }
                if (offlineMessages.plantDied) { setTimeout(() => showMessage("Một số cây trồng đã không qua khỏi khi bạn vắng mặt.", "error"), 600); }
            }
        } // --- Kết thúc hàm renderGarden ---

function placeLightningRod(plotId) {
    if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || gameState.plots[plotId].seedId || isPlotWithRod(plotId)) {
        showMessage("Không thể đặt Cột thu lôi ở ô này (đã có cây/rod hoặc không hợp lệ).", "error");
        return;
    }
    const rodCount = gameState.inventory[LIGHTNING_ROD_ITEM_ID] || 0;
    if (rodCount <= 0) {
        showMessage(`Hết Cột thu lôi trong kho! Hãy mua thêm.`, "error");
        return;
    }

    // --- Thực hiện đặt ---
    gameState.inventory[LIGHTNING_ROD_ITEM_ID]--; // Trừ khỏi kho
    gameState.lightningRods.push({
        plotId: plotId,
        health: LIGHTNING_ROD_MAX_HEALTH,
        repairCost: LIGHTNING_ROD_INITIAL_REPAIR_COST
    });

    // Cập nhật UI và Lưu game
    renderUI();
    renderGarden(); // Vẽ lại vườn để hiện cột thu lôi
    if (inventoryModal.style.display === 'block') renderInventory(); // Cập nhật kho nếu đang mở
    saveGame();

    showMessage(`Đã đặt Cột thu lôi tại ô ${plotId + 1}!`, "success");
    logAction('place_rod', plotId, `Đặt Cột thu lôi tại ô ${plotId + 1}.`, '⚡', LIGHTNING_ROD_ITEM_ID);
}

function handleLightningRodClick(plotId) {
    const rodData = getRodData(plotId);
    if (!rodData) {
        console.warn(`handleLightningRodClick được gọi cho ô ${plotId} không có rod.`);
        return;
    }
    currentActionPlotId = plotId; // Lưu plotId đang thao tác
    updateLightningRodActionModal(plotId); // Cập nhật nội dung modal
    openModal('lightning-rod-action-modal'); // Mở modal hành động rod
}
function updateLightningRodActionModal(plotId) {
    const rodData = getRodData(plotId);
    if (!rodData || !lightningRodActionModal) return;

    const rodTitle = lightningRodActionModal.querySelector('#rod-action-title');
    const rodHealthDisplay = lightningRodActionModal.querySelector('#rod-health-display');
    const repairBtn = lightningRodActionModal.querySelector('#action-repair-rod');
    const removeBtn = lightningRodActionModal.querySelector('#action-remove-rod');

    if (rodTitle) rodTitle.textContent = `⚡ Cột Thu Lôi (Ô ${plotId + 1})`;

    if (rodHealthDisplay) {
         rodHealthDisplay.textContent = `${rodData.health}/${LIGHTNING_ROD_MAX_HEALTH}`;
         rodHealthDisplay.style.color = rodData.health <= 0 ? '#c62828' : (rodData.health < LIGHTNING_ROD_MAX_HEALTH * 0.5 ? '#fb8c00' : 'inherit');
    }


    if (repairBtn) {
        if (rodData.health <= 0) {
            const cost = rodData.repairCost || LIGHTNING_ROD_INITIAL_REPAIR_COST;
            repairBtn.textContent = `🔧 Sửa Chữa (${cost}💰)`;
            repairBtn.disabled = gameState.currency < cost;
            repairBtn.title = repairBtn.disabled ? `Không đủ tiền sửa (Cần ${cost}💰)` : `Sửa chữa cột thu lôi (Tốn ${cost}💰)`;
            repairBtn.style.display = 'block'; // Hiện nút sửa
        } else {
            repairBtn.style.display = 'none'; // Ẩn nút sửa nếu rod chưa hỏng
        }
    }

    if (removeBtn) {
        removeBtn.disabled = false; // Nút gỡ bỏ luôn được bật
        removeBtn.title = "Gỡ bỏ cột thu lôi khỏi ô đất này";
    }
}

function handleRodActionClick(event) {
    const actionButton = event.target.closest('.action-button');
    if (!actionButton || actionButton.disabled || currentActionPlotId === null) return;

    const plotId = currentActionPlotId; // Lấy plotId đã lưu
    const actionId = actionButton.id;

    switch(actionId) {
        case 'action-repair-rod':
            openConfirmRepairPopup(plotId); // Mở popup xác nhận sửa
            break;
        case 'action-remove-rod':
            openConfirmRemovePopup(plotId); // Mở popup xác nhận gỡ
            break;
        default:
             console.warn("Hành động cột thu lôi không xác định:", actionId);
    }
    // Không đóng modal chính ở đây, đóng sau khi xác nhận
}

function openConfirmRepairPopup(plotId) {
    const rodData = getRodData(plotId);
    if (!rodData || rodData.health > 0) return;
    const cost = rodData.repairCost || LIGHTNING_ROD_INITIAL_REPAIR_COST;
    const msgElement = confirmRepairRodPopup.querySelector('#confirm-repair-message');
    const confirmBtn = confirmRepairRodPopup.querySelector('#confirm-repair-rod-btn');

    if (msgElement) msgElement.innerHTML = `Bạn có chắc muốn sửa cột thu lôi ở ô <strong>${plotId + 1}</strong> với giá <strong>${cost}💰</strong>?`;
    if (confirmBtn) {
        confirmBtn.dataset.plotId = plotId;
        confirmBtn.disabled = gameState.currency < cost;
    }
    confirmRepairRodPopup.style.display = 'flex';
     setTimeout(() => confirmBtn?.focus(), 50);
}
function closeConfirmRepairPopup() { confirmRepairRodPopup.style.display = 'none'; }
function handleConfirmRepair() {
    const confirmBtn = confirmRepairRodPopup.querySelector('#confirm-repair-rod-btn');
    const plotId = parseInt(confirmBtn?.dataset.plotId);
    if (!isNaN(plotId)) {
        repairRod(plotId);
    }
    closeConfirmRepairPopup();
    closeModal('lightning-rod-action-modal'); // Đóng cả modal hành động gốc
     currentActionPlotId = null;
}

function openConfirmRemovePopup(plotId) {
    const rodData = getRodData(plotId);
    if (!rodData) return;
    const msgElement = confirmRemoveRodPopup.querySelector('#confirm-remove-message');
    const confirmBtn = confirmRemoveRodPopup.querySelector('#confirm-remove-rod-btn');

    if (msgElement) msgElement.innerHTML = `Bạn có chắc muốn gỡ bỏ cột thu lôi ở ô <strong>${plotId + 1}</strong> không? (Không thể hoàn tác)`;
    if (confirmBtn) confirmBtn.dataset.plotId = plotId;
    confirmRemoveRodPopup.style.display = 'flex';
    setTimeout(() => confirmBtn?.focus(), 50);
}
function closeConfirmRemovePopup() { confirmRemoveRodPopup.style.display = 'none'; }
function handleConfirmRemove() {
    const confirmBtn = confirmRemoveRodPopup.querySelector('#confirm-remove-rod-btn');
    const plotId = parseInt(confirmBtn?.dataset.plotId);
    if (!isNaN(plotId)) {
        removeRod(plotId);
    }
    closeConfirmRemovePopup();
    closeModal('lightning-rod-action-modal'); // Đóng cả modal hành động gốc
    currentActionPlotId = null;
}

/** [MỚI] Hành động: Sửa chữa cột thu lôi */
function repairRod(plotId) {
    const rodIndex = gameState.lightningRods.findIndex(r => r.plotId === plotId);
    if (rodIndex === -1) return;
    const rod = gameState.lightningRods[rodIndex];
    if (rod.health > 0) { showMessage("Cột thu lôi này chưa hỏng.", "info"); return; }

    const cost = rod.repairCost || LIGHTNING_ROD_INITIAL_REPAIR_COST;
    if (gameState.currency < cost) { showMessage(`Không đủ tiền sửa! Cần ${cost}💰.`, "error"); return; }

    // --- Thực hiện sửa ---
    gameState.currency -= cost;
    rod.health = LIGHTNING_ROD_MAX_HEALTH; // Phục hồi máu
    rod.repairCost = Math.floor(cost * LIGHTNING_ROD_REPAIR_COST_MULTIPLIER); // Tính phí sửa lần sau

    // Cập nhật UI, Lưu game
    renderUI();
    renderGarden();
    saveGame();

    showMessage(`Đã sửa Cột thu lôi ở ô ${plotId + 1} với ${cost}💰. Phí sửa lần tới: ${rod.repairCost}💰.`, "success");
    logAction('repair_rod', plotId, `Sửa Cột thu lôi (-${cost}💰). HP: ${rod.health}/${LIGHTNING_ROD_MAX_HEALTH}. Phí sau: ${rod.repairCost}💰.`, '🔧', LIGHTNING_ROD_ITEM_ID);
}
function removeRod(plotId) {
    const rodIndex = gameState.lightningRods.findIndex(r => r.plotId === plotId);
    if (rodIndex === -1) { showMessage("Không tìm thấy cột thu lôi để gỡ.", "warning"); return; }

    // --- Thực hiện gỡ ---
    gameState.lightningRods.splice(rodIndex, 1); // Xóa khỏi mảng

    // --- [QUYẾT ĐỊNH] Không trả lại vật phẩm vào kho ---
    // gameState.inventory[LIGHTNING_ROD_ITEM_ID] = (gameState.inventory[LIGHTNING_ROD_ITEM_ID] || 0) + 1;

    // Cập nhật UI, Lưu game
    renderGarden(); // Vẽ lại vườn
    if (inventoryModal.style.display === 'block') renderInventory(); // Cập nhật kho nếu cần
    saveGame();

    showMessage(`Đã gỡ bỏ Cột thu lôi khỏi ô ${plotId + 1}.`, "info");
    logAction('remove_rod', plotId, `Gỡ bỏ Cột thu lôi khỏi ô ${plotId + 1}.`, '🗑️', LIGHTNING_ROD_ITEM_ID);
}



        /** Bắt đầu vòng lặp game chính. */
        function startGameLoop() {
            if (gameLoopInterval) {
                console.warn("Vòng lặp game đã chạy.");
                return;
            }
            console.log(`Đang bắt đầu vòng lặp game với khoảng thời gian: ${TICK_INTERVAL}ms`);
             gameTick(); // Chạy tick đầu tiên ngay lập tức
             gameLoopInterval = setInterval(gameTick, TICK_INTERVAL); // Thiết lập interval
			 startHatNgocTroiTimer();
        }

        /** Dừng vòng lặp game chính. */
        function stopGameLoop() {
             if (gameLoopInterval) {
        clearInterval(gameLoopInterval); // Xóa interval
        gameLoopInterval = null; // Đặt lại biến ID
        clearTimeout(hatNgocTroiTimeout); // <<< DỪNG TIMER KHI GAME LOOP DỪNG
        hatNgocTroiTimeout = null;        // <<< RESET BIẾN TIMER
        console.log("Vòng lặp game và timer Hạt Ngọc Trời đã dừng.");
    }
        }

        /** Nhịp đập chính của game, cập nhật trạng thái cây trồng, UI, và sự kiện sâu bệnh. */
         async function gameTick() {
            const now = Date.now();
            gameState.lastUpdateTimestamp = now; // Cập nhật timestamp ở đầu tick
            tickCounter++;

            let plotStateChangedDuringTick = false; // Cờ theo dõi thay đổi trong tick này

            // Cập nhật thời gian hiển thị (giờ:phút)
            const currentTime = new Date();
            const hours = String(currentTime.getHours()).padStart(2, '0');
            const minutes = String(currentTime.getMinutes()).padStart(2, '0');
            const timeString = `${hours}:${minutes}`;
            if (gameTimeElement.textContent !== timeString) {
                gameTimeElement.textContent = timeString;
            }

            // --- Xử Lý Thay Đổi Thời Tiết ---
            let weatherJustChanged = false;
            let previousWeatherId = gameState.currentWeather?.id;

            if (now >= gameState.nextWeatherChangeTimestamp) {
                const oldWeatherIdForEventCheck = previousWeatherId;
                gameState.currentWeather = chooseRandomWeather(); // Chọn thời tiết mới
                gameState.currentWeatherStartTime = now; // Thời điểm bắt đầu chu kỳ mới
                gameState.nextWeatherChangeTimestamp = now + WEATHER_CHANGE_INTERVAL_MS; // Lên lịch lần đổi kế tiếp
                const weatherDisplayName = gameState.currentWeather.name || gameState.currentWeather.icon;
                console.log(`Thời tiết đã thay đổi thành: ${weatherDisplayName} (ID: ${gameState.currentWeather.id})`);
                showMessage(`Thời tiết đã đổi thành ${weatherDisplayName}`, 'info');
                weatherJustChanged = true;
                weatherUpdateNeeded = true; // Cần vẽ lại UI thời tiết

                // Dừng âm thanh thời tiết CŨ nếu hiệu ứng đang bật
                if (areEffectSoundsEnabled) {
                    if (oldWeatherIdForEventCheck === 'rainy' && gameState.currentWeather.id !== 'rainy' && rainSound && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
                    if (oldWeatherIdForEventCheck === 'rainy_sunny' && gameState.currentWeather.id !== 'rainy_sunny' && rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
                }

                // Xử lý hiệu ứng tức thì: Hết khô khi mưa
                const rainyWeatherIdsForDryness = ['rainy', 'thunderstorm', 'rainy_sunny'];
                if (rainyWeatherIdsForDryness.includes(gameState.currentWeather.id)) {
                    let clearedDryPlots = 0;
                    for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                        const plot = gameState.plots[i];
                        if (plot && plot.isDry) {
                            plot.isDry = false; clearedDryPlots++; plotStateChangedDuringTick = true;
                        }
                    }
                    if (clearedDryPlots > 0) { setTimeout(() => { showMessage(`🌧️ Mưa đã làm ${clearedDryPlots} ô đất hết khô!`, "success"); }, 200); }
                }

                // Lên lịch/hủy lịch sự kiện Tornado khi thời tiết đổi sang/khỏi Windy
                if (gameState.currentWeather.id === 'windy') {
                    if (gameState.nextTornadoEventTimestamp <= 0 || gameState.nextTornadoEventTimestamp <= now) {
                        const nextInterval = TORNADO_EVENT_MIN_INTERVAL_MS_WINDY + Math.random() * (TORNADO_EVENT_MAX_INTERVAL_MS_WINDY - TORNADO_EVENT_MIN_INTERVAL_MS_WINDY);
                        gameState.nextTornadoEventTimestamp = now + nextInterval;
                        console.log(`(Weather Change to Windy) Sự kiện lốc tiếp theo được lên lịch sau ${formatTime(nextInterval)}`);
                    }
                } else { // Nếu không phải Windy nữa
                    gameState.nextTornadoEventTimestamp = 0; // Hủy lịch
                    if (gameState.activeTornadoes.length > 0) {
                        console.log("Thời tiết không còn là Windy, xóa các hiệu ứng lốc đang hoạt động.");
                        gameState.activeTornadoes = []; // Xóa lốc đang chạy
                        plotStateChangedDuringTick = true; // Cần render lại vườn
                    }
                }
                saveGame(); // Lưu game sau khi đổi thời tiết và xử lý hiệu ứng
            }

            // Luôn Cập Nhật UI Thời Tiết MỖI TICK (bao gồm hiệu ứng làm tối)
            renderWeatherUI();
            weatherUpdateNeeded = false; // Đã cập nhật

            // XỬ LÝ ÂM THANH MƯA & MƯA NẮNG THEO NÚT HIỆU ỨNG
            if (areEffectSoundsEnabled) {
                if (rainSound) {
                    if (gameState.currentWeather.id === 'rainy' && rainSound.paused) { try { await rainSound.play(); } catch (error) { /* Bỏ qua lỗi */ } }
                    else if (gameState.currentWeather.id !== 'rainy' && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
                }
                if (rainySunnySound) {
                    if (gameState.currentWeather.id === 'rainy_sunny' && rainySunnySound.paused) { try { await rainySunnySound.play(); } catch (error) { /* Bỏ qua lỗi */ } }
                    else if (gameState.currentWeather.id !== 'rainy_sunny' && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
                }
            } else { // Tắt âm thanh nếu hiệu ứng bị tắt
                if (rainSound && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
                if (rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
            }

            // KIỂM TRA VÀ ÁP DỤNG KHÔ HẠN KHI TRỜI NẮNG
            let dryCheckOccurredThisTick = false;
            if (gameState.currentWeather.id === 'sunny' && now >= gameState.nextDryCheckTimestamp && !dryCheckOccurredThisTick) {
                 dryCheckOccurredThisTick = true;
                 const eligiblePlotIndices = [];
                 for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                      if (gameState.activeTornadoes.some(t => t.plotId === i)) continue; // Bỏ qua ô đang bị tornado
                      if (isPlotWithRod(i)) continue; // Bỏ qua ô có rod
                      const plot = gameState.plots[i];
                      if (plot && !plot.isDry) { eligiblePlotIndices.push(i); } // Chỉ xét ô chưa khô
                 }
                 let numPlotsToAffect = 0;
                 if (eligiblePlotIndices.length > 0) {
                     const maxAffect = Math.min(eligiblePlotIndices.length, 3); // Làm khô tối đa 3 ô
                     numPlotsToAffect = Math.floor(Math.random() * maxAffect) + 1; // Ít nhất 1 ô
                 }
                 let becameDryCount = 0;
                 const shuffledEligible = eligiblePlotIndices.sort(() => 0.5 - Math.random());
                 for (let k = 0; k < numPlotsToAffect; k++) {
                     const plotIndexToAffect = shuffledEligible[k];
                     const plotToAffect = gameState.plots[plotIndexToAffect];
                     if (plotToAffect && !plotToAffect.isDry) {
                         plotToAffect.isDry = true; becameDryCount++; plotStateChangedDuringTick = true;
                     }
                 }
                 if (becameDryCount > 0) { showMessage(`🥵 Nắng gắt đã làm khô ${becameDryCount} ô đất!`, "warning"); }
                 // Lên lịch kiểm tra khô hạn tiếp theo (30-60 giây)
                 const nextIntervalSunny = (30 + Math.random() * 30) * 1000;
                 gameState.nextDryCheckTimestamp = now + nextIntervalSunny;
            } else if (gameState.currentWeather.id !== 'sunny' && now >= gameState.nextDryCheckTimestamp) { // Nếu không nắng, cũng lên lịch lại
                 dryCheckOccurredThisTick = true;
                 const randomIntervalOther = (60 + Math.random() * 60) * 1000; // 60-120 giây
                 gameState.nextDryCheckTimestamp = now + randomIntervalOther;
            }

            // --- Xử Lý Sâu Bệnh, Hồi Máu, Giảm Phì Nhiêu, Khô Hạn và TORNADO cho từng Ô Đất ---
            for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                // Bỏ qua ô có cột thu lôi (rod không bị ảnh hưởng bởi logic này)
                if (isPlotWithRod(i)) continue;
                const plot = gameState.plots[i];
                if (!plot) continue; // Bỏ qua nếu không có dữ liệu ô đất

                let plotUpdatedByOthers = false; // Cờ riêng cho các thay đổi thông thường

                // === ƯU TIÊN XỬ LÝ TẤN CÔNG TORNADO (bao gồm tác động lên hàng rào) ===
                const activeTornado = gameState.activeTornadoes.find(t => t.plotId === i);
                if (activeTornado) {
                    const duration = TORNADO_EFFECT_DURATION_MS_WINDY;
                    // Số tick còn lại (ít nhất 1) để chia sát thương
                    const ticksRemaining = Math.max(1, Math.ceil((activeTornado.expireTimestamp - now) / TICK_INTERVAL));
                    // Tổng số tick dự kiến trong toàn bộ thời gian hiệu ứng
                    const totalTicksInDuration = Math.ceil(duration / TICK_INTERVAL);
                    let damageAppliedThisTick = false; // Cờ xem có gây sát thương trong tick này không
                    let fenceTookHit = false; // Cờ xem rào có hứng chịu không

                    // 1. Kiểm tra và tấn công Hàng Rào trước nếu có và còn máu
                    if (plot.fenceData && plot.fenceData.health > 0 && ITEM_DATA.raobaove) {
                        fenceTookHit = true; // Đánh dấu rào hứng chịu
                        const fenceMaxHealth = ITEM_DATA.raobaove.health;
                        let fenceDamage = 0; // Sát thương hàng rào trong tick này

                        // Tính sát thương lên hàng rào dựa trên loại tornado
                        if (activeTornado.isDestruction) { // Phá hủy hoàn toàn rào trong thời gian còn lại
                            fenceDamage = ticksRemaining > 0 ? plot.fenceData.health / ticksRemaining : plot.fenceData.health;
                        } else { // Gây thiệt hại một phần (% máu tối đa)
                            const totalFenceDmg = fenceMaxHealth * TORNADO_PARTIAL_DAMAGE_FACTOR;
                            // Chia đều tổng sát thương cho tổng số tick của hiệu ứng
                            fenceDamage = totalTicksInDuration > 0 ? totalFenceDmg / totalTicksInDuration : 0;
                        }

                        const oldFenceHealth = plot.fenceData.health;
                        plot.fenceData.health = Math.max(0, plot.fenceData.health - fenceDamage); // Giảm máu rào
						
        if (plot.fenceData.health <= 0 && oldFenceHealth > 0) {
            // Rào vừa bị phá hủy bởi cơn lốc NÀY!
            console.warn(`(Tornado Fence Break) Rào ô ${i} bị phá hủy! Dừng hiệu ứng lốc cho ô này.`);
            // Hiển thị thông báo cho người chơi (đã có sẵn)
            showMessage(`🚧 Rào bảo vệ ở ô ${i + 1} bị gió lốc phá hỏng!`, "error");
            logAction('fence_broken', i, `Rào bảo vệ ô ${i + 1} bị gió lốc phá hỏng.`, '💥🚧', 'raobaove');

            // *** HÀNH ĐỘNG QUAN TRỌNG: Xóa cơn lốc đang hoạt động cho ô này ***
            const tornadoIndex = gameState.activeTornadoes.findIndex(t => t.plotId === i);
            if (tornadoIndex !== -1) {
                gameState.activeTornadoes.splice(tornadoIndex, 1); // Xóa phần tử khỏi mảng
                console.log(` -> Đã loại bỏ activeTornado cho ô ${i} vì rào bị phá hủy.`);
            }

            plotStateChangedDuringTick = true; // Đảm bảo vườn được vẽ lại
            continue; // *** QUAN TRỌNG: Bỏ qua phần còn lại của xử lý lốc VÀ xử lý plot thông thường cho ô này TRONG TICK NÀY ***
        }
       
						
						
						
						
                        if (plot.fenceData.health !== oldFenceHealth) {
                            damageAppliedThisTick = true; // Đánh dấu có sát thương
                            // --- LOG THÊM ---
                            console.log(`(Tornado Tick) Rào ô ${i} hứng ${fenceDamage.toFixed(1)} dmg. Máu còn: ${plot.fenceData.health.toFixed(1)}. Loại: ${activeTornado.isDestruction ? 'Phá hủy' : 'Thiệt hại nặng'}.`);
                            // ---------------
                        }
                        // Xử lý khi rào bị phá hủy (máu về 0 từ > 0)
                        if (plot.fenceData.health <= 0 && oldFenceHealth > 0) {
                            console.warn(`(Tornado Hits Fence) Rào bảo vệ ở ô ${i} bị phá hủy!`);
                            showMessage(`🚧 Rào bảo vệ ở ô ${i + 1} bị gió lốc phá hỏng!`, "error");
                            logAction('fence_broken', i, `Rào bảo vệ ô ${i + 1} bị gió lốc phá hỏng.`, '💥🚧', 'raobaove');
                        }
                    } // Kết thúc xử lý hàng rào

                    // 2. Nếu hàng rào KHÔNG hứng chịu (không có hoặc đã hỏng), mới tấn công cây/đất
                    if (!fenceTookHit) {
                        // --- LOG THÊM ---
                        console.log(`(Tornado Tick) Rào ô ${i} không hứng chịu. Tấn công cây/đất. Loại: ${activeTornado.isDestruction ? 'Phá hủy' : 'Thiệt hại nặng'}.`);
                        // ---------------
                        if (activeTornado.isDestruction) { // Phá hủy hoàn toàn cây/đất
                            // Chia đều máu/phì nhiêu còn lại cho số tick còn lại
                            const healthDamage = ticksRemaining > 0 ? plot.health / ticksRemaining : plot.health;
                            const fertilityDamage = ticksRemaining > 0 ? plot.fertility / ticksRemaining : plot.fertility;
                            // Gây sát thương cho cây nếu có
                            if (plot.seedId && plot.health > 0) {
                                const oldH = plot.health;
                                plot.health = Math.max(0, plot.health - healthDamage);
                                if(plot.health !== oldH) {
                                     damageAppliedThisTick = true;
                                     // --- LOG THÊM ---
                                     console.log(` -> Cây ô ${i} chịu ${healthDamage.toFixed(1)} dmg (phá hủy). HP còn: ${plot.health.toFixed(1)}.`);
                                     // ---------------
                                }
                                // Xử lý khi cây chết do bị hủy diệt
                                if(plot.health === 0 && oldH > 0) {
                                    plot.causeOfDeath = 'tornado'; plot.hasPest = false; plot.isDry = false; plot.pestDeathClickCount = 0;
                                    const plantName = ITEM_DATA[plot.seedId]?.name || 'Cây';
                                    console.warn(`(Tornado Destr) Plot ${i} (${plantName}) bị hủy diệt.`);
                                    logAction('plant_death', i, `${plantName} ô ${i+1} bị hủy diệt do gió lốc.`, '💀🌪️', plot.seedId);
                                }
                            }
                            // Hoặc gây sát thương cho đất trống nếu có
                            else if (!plot.seedId && plot.fertility > 0) {
                                const oldF = plot.fertility;
                                plot.fertility = Math.max(0, plot.fertility - fertilityDamage);
                                if(plot.fertility !== oldF) {
                                    damageAppliedThisTick = true;
                                     // --- LOG THÊM ---
                                     console.log(` -> Đất ô ${i} chịu ${fertilityDamage.toFixed(1)} dmg (phá hủy). Phì còn: ${plot.fertility.toFixed(1)}.`);
                                     // ---------------
                                }
                                // Xử lý khi đất thành cằn cỗi
                                if(plot.fertility === 0 && oldF > 0) {
                                    plot.barrenHarvestPenaltyFactor = 1.0; plot.isDry = false;
                                    console.log(`(Tornado Destr) Plot ${i} (trống) thành cằn cỗi.`);
                                    logAction('soil_barren', i, `Đất ô ${i+1} thành cằn do gió lốc.`, '🧱🌪️', null);
                                }
                            }
                        } else { // Gây thiệt hại một phần (% máu/phì nhiêu HIỆN TẠI) cho cây/đất
                            // Tổng sát thương dự kiến là % máu/phì nhiêu HIỆN TẠI
                            const totalHDmg = plot.health * TORNADO_PARTIAL_DAMAGE_FACTOR;
                            const totalFDmg = plot.fertility * TORNADO_PARTIAL_DAMAGE_FACTOR;
                            // Chia đều tổng sát thương cho tổng số tick của hiệu ứng
                            const healthDamageTick = totalTicksInDuration > 0 ? totalHDmg / totalTicksInDuration : 0;
                            const fertilityDamageTick = totalTicksInDuration > 0 ? totalFDmg / totalTicksInDuration : 0;
                            // Gây sát thương cho cây nếu có
                            if (plot.seedId && plot.health > 0) {
                                const oldH = plot.health;
                                plot.health = Math.max(0, plot.health - healthDamageTick);
                                if(plot.health !== oldH) {
                                    damageAppliedThisTick = true;
                                    // --- LOG THÊM ---
                                    console.log(` -> Cây ô ${i} chịu ${healthDamageTick.toFixed(1)} dmg (thiệt hại nặng). HP còn: ${plot.health.toFixed(1)}.`);
                                    // ---------------
                                }
                                // Xử lý khi cây chết do thiệt hại nặng
                                if(plot.health === 0 && oldH > 0) {
                                    plot.causeOfDeath = 'tornado'; plot.hasPest = false; plot.isDry = false; plot.pestDeathClickCount = 0;
                                    const plantName = ITEM_DATA[plot.seedId]?.name || 'Cây';
                                    console.warn(`(Tornado Part) Plot ${i} (${plantName}) chết do thiệt hại nặng.`);
                                    logAction('plant_death', i, `${plantName} ô ${i+1} chết do thiệt hại gió lốc.`, '💀🌪️', plot.seedId);
                                }
                            }
                            // Hoặc gây sát thương cho đất trống nếu có
                            else if (!plot.seedId && plot.fertility > 0) {
                                const oldF = plot.fertility;
                                plot.fertility = Math.max(0, plot.fertility - fertilityDamageTick);
                                if(plot.fertility !== oldF) {
                                    damageAppliedThisTick = true;
                                    // --- LOG THÊM ---
                                    console.log(` -> Đất ô ${i} chịu ${fertilityDamageTick.toFixed(1)} dmg (thiệt hại nặng). Phì còn: ${plot.fertility.toFixed(1)}.`);
                                    // ---------------
                                }
                                // Xử lý khi đất thành cằn cỗi do thiệt hại nặng
                                if(plot.fertility === 0 && oldF > 0) {
                                    plot.barrenHarvestPenaltyFactor = 1.0; plot.isDry = false;
                                    console.log(`(Tornado Part) Plot ${i} (trống) thành cằn cỗi do thiệt hại nặng.`);
                                    logAction('soil_barren', i, `Đất ô ${i+1} thành cằn do thiệt hại gió lốc.`, '🧱🌪️', null);
                                }
                            }
                        }
                    } // Kết thúc xử lý cây/đất

                    // Đánh dấu thay đổi trạng thái chung nếu có sát thương
                    if (damageAppliedThisTick) plotStateChangedDuringTick = true;
                    // QUAN TRỌNG: Bỏ qua các xử lý khác (sâu, hồi máu,...) cho ô này trong tick này nếu đang bị tornado
                    continue;
                } // Kết thúc xử lý nếu ô đang bị tornado

                // --- Phần xử lý plot thông thường (nếu KHÔNG bị tornado) ---

                // A. Sát thương sâu (nếu có sâu và cây còn sống)
                if (plot.hasPest && plot.health > 0) {
                    const stageInfo = getPlantStageInfo(plot, now); // Lấy thông tin giai đoạn
                    const damage = PEST_DAMAGE_PER_TICK * (stageInfo?.isMature ? PEST_DAMAGE_MATURE_REDUCTION_FACTOR : 1); // Giảm sát thương nếu trưởng thành
                    const oldHealth = plot.health;
                    plot.health = Math.max(0, plot.health - damage); // Giảm máu
                    if (plot.health === 0 && oldHealth > 0) { // Nếu chết do sâu
                        plot.causeOfDeath = 'pest'; plot.hasPest = false; plot.pestDeathClickCount = 0; plot.isDry = false;
                        plotUpdatedByOthers = true;
                        const plantName = ITEM_DATA[plot.seedId]?.name || 'Cây';
                        console.warn(`(Pest Damage) Plot ${i} (${plantName}) died from pest.`);
                        logAction('plant_death', i, `${plantName} ô ${i+1} chết do sâu.`, '💀🐛', plot.seedId);
                    } else if(plot.health !== oldHealth) { // Nếu chỉ giảm máu
                        plotUpdatedByOthers = true;
                    }
                }

                // B. Sâu mới xuất hiện (chỉ khi thời tiết phù hợp, cây sống, chưa có sâu)
                const noPestWeather = ['sunny', 'cloudy', 'windy', 'lightning'];
                if (!noPestWeather.includes(gameState.currentWeather.id) && plot.seedId && plot.health > 0 && !plot.hasPest && Math.random() < PEST_APPEARANCE_CHANCE_PER_TICK_PER_PLOT) {
                    plot.hasPest = true;
                    const plantName = ITEM_DATA[plot.seedId]?.name || 'cây';
                    showMessage(`Ối! Sâu xuất hiện trên ${plantName} ở ô ${i+1}!`, "pest-event");
                    plotUpdatedByOthers = true;
                    logAction('pest_appear', i, `Sâu xuất hiện trên ${plantName}.`, '🐛✨', plot.seedId);
                }

                // C. Hồi máu VÀ tiêu hao phì nhiêu nếu cây trưởng thành (nếu không sâu, không khô)
                if (plot.seedId && plot.health > 0 && plot.health < INITIAL_PLANT_HEALTH && !plot.hasPest && !plot.isDry) {
                    const oldHealth = plot.health;
                    plot.health = Math.min(INITIAL_PLANT_HEALTH, plot.health + HEALTH_REGEN_PER_TICK); // Tăng máu
                    const healthGained = plot.health - oldHealth;
                    if (healthGained > 0) { // Nếu máu thực sự tăng
                        plotUpdatedByOthers = true;
                        const stageInfoForRegen = getPlantStageInfo(plot, now);
                        const seedInfoForRegen = ITEM_DATA[plot.seedId];
                        // Tiêu hao phì nếu cây trưởng thành, có hao đất, đất còn phì
                        if (stageInfoForRegen && stageInfoForRegen.isMature && seedInfoForRegen && seedInfoForRegen.fertilityCost > 0 && seedInfoForRegen.growthTime > 0 && plot.fertility > 0) {
                            const fertilityDecreasePerGrowthSecond = (seedInfoForRegen.fertilityCost * BASE_FERTILITY) / seedInfoForRegen.growthTime;
                            const fertilityDecreaseThisTick = fertilityDecreasePerGrowthSecond * (TICK_INTERVAL / 1000);
                            if (fertilityDecreaseThisTick > 0) {
                                const oldFertility = plot.fertility;
                                plot.fertility = Math.max(0, plot.fertility - fertilityDecreaseThisTick); // Giảm phì
                                // Xử lý nếu đất thành cằn do hồi máu
                                if (oldFertility > 0 && plot.fertility <= 0) {
                                     plot.barrenHarvestPenaltyFactor = 1.0;
                                     console.log(`(Mature Regen) Plot ${i} became barren due to regeneration cost.`);
                                }
                            }
                        }
                    }
                }

                // D. Giảm phì do cây lớn (chỉ khi cây đang lớn, còn sống, đất còn phì)
                if (plot.seedId && plot.health > 0) {
                    const seedInfo = ITEM_DATA[plot.seedId];
                    const stageInfo = getPlantStageInfo(plot, now);
                    // Điều kiện: có hao đất, đất còn phì, cây đang lớn
                    if (seedInfo?.fertilityCost > 0 && seedInfo.growthTime > 0 && plot.fertility > 0 && stageInfo && !stageInfo.isMature && !stageInfo.isDead) {
                        const decreasePerSecond = (seedInfo.fertilityCost * BASE_FERTILITY) / seedInfo.growthTime;
                        const decreaseThisTick = decreasePerSecond * (TICK_INTERVAL / 1000);
                        if (decreaseThisTick > 0) {
                            const oldF = plot.fertility;
                            plot.fertility = Math.max(0, plot.fertility - decreaseThisTick); // Giảm phì
                            if (plot.fertility !== oldF) plotUpdatedByOthers = true; // Đánh dấu thay đổi
                            // Xử lý nếu đất thành cằn do cây lớn
                             if (oldF > 0 && plot.fertility <= 0) {
                                 plot.barrenHarvestPenaltyFactor = 1.0;
                                 console.log(`(Growth Cost) Plot ${i} became barren due to plant growth cost.`);
                            }
                        }
                    }
                }

                // E. Hậu quả khô hạn (giảm máu cây hoặc độ phì đất trống)
                if (plot.isDry) {
                    let changedByDryness = false;
                    if (plot.seedId && plot.health > 0) { // Cây trồng bị khô
                        const oldH = plot.health;
                        plot.health = Math.max(0, plot.health - DRY_HEALTH_DRAIN_PER_TICK); // Giảm máu
                        if (plot.health === 0 && oldH > 0) { // Chết do khô
                            plot.causeOfDeath = 'dryness'; plot.hasPest = false; plot.isDry = false;
                            changedByDryness = true;
                            const plantName = ITEM_DATA[plot.seedId]?.name || 'Cây';
                            console.warn(`(Dryness Damage) Plot ${i} (${plantName}) died from dryness.`);
                            logAction('plant_death', i, `${plantName} ô ${i+1} chết do khô hạn.`, '💀🏜️', plot.seedId);
                        } else if(plot.health !== oldH) { // Chỉ giảm máu
                            changedByDryness = true;
                        }
                    } else if (!plot.seedId && plot.fertility > 0) { // Đất trống bị khô
                        const oldF = plot.fertility;
                        plot.fertility = Math.max(0, plot.fertility - DRY_FERTILITY_DRAIN_PER_TICK); // Giảm phì
                        if (plot.fertility !== oldF) {
                            changedByDryness = true;
                            if(plot.fertility === 0 && oldF > 0) { // Đất thành cằn do khô
                                plot.barrenHarvestPenaltyFactor = 1.0;
                                console.log(`(Dryness Damage) Plot ${i} (empty) became barren due to dryness.`);
                                logAction('soil_barren', i, `Đất ô ${i+1} thành cằn do khô hạn.`, '🧱🏜️', null);
                            }
                        }
                    }
                    if (changedByDryness) plotUpdatedByOthers = true; // Đánh dấu thay đổi
                }
                // --- Kết thúc xử lý plot thông thường ---

                // Cập nhật cờ trạng thái chung nếu plot này có thay đổi
                if (plotUpdatedByOthers) plotStateChangedDuringTick = true;

            } // Kết thúc vòng lặp for các ô đất

            // --- Tăng Phì Nhiêu Do Mưa (mỗi 15 giây) ---
            const fertilityBoostingWeather = ['rainy', 'thunderstorm', 'rainy_sunny'];
            let rainBoostApplied = false;
            if (fertilityBoostingWeather.includes(gameState.currentWeather.id) && tickCounter % 15 === 0) {
                for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                     if (isPlotWithRod(i) || gameState.activeTornadoes.some(t => t.plotId === i)) continue; // Bỏ qua ô có rod/tornado
                     const plot = gameState.plots[i];
                     if (plot && plot.fertility < BASE_FERTILITY) { // Chỉ tăng nếu chưa max
                         const oldF = plot.fertility;
                         plot.fertility = Math.min(BASE_FERTILITY, plot.fertility + 1); // Tăng 1%
                         if (plot.fertility !== oldF) {
                             rainBoostApplied = true;
                             if (oldF <= 0 && plot.fertility > 0) { plot.barrenHarvestPenaltyFactor = 1.0; } // Reset penalty nếu hết cằn
                         }
                     }
                }
                if (rainBoostApplied) plotStateChangedDuringTick = true; // Cập nhật cờ chung
            }

            // --- XỬ LÝ SÉT ĐÁNH ---
            let strikeOccurred = false; let strikeType = null; let strikeDmgPlant = 0; let strikeDmgSoil = 0;
            // Xác suất và sát thương cho Thunderstorm
            if (gameState.currentWeather.id === 'thunderstorm' && Math.random() < THUNDERSTORM_STRIKE_CHANCE_PER_TICK) {
                strikeType = 'thunderstorm'; strikeDmgPlant = PLANT_HEALTH_DAMAGE; strikeDmgSoil = SOIL_FERTILITY_DAMAGE;
            }
            // Xác suất và sát thương cho Lightning (chỉ hình ảnh nhưng vẫn có thể gây sát thương)
            else if (gameState.currentWeather.id === 'lightning' && Math.random() < LIGHTNING_VISUAL_STRIKE_CHANCE_PER_TICK) {
                strikeType = 'lightning'; strikeDmgPlant = LIGHTNING_PLANT_DAMAGE; strikeDmgSoil = LIGHTNING_SOIL_DAMAGE;
            }

            if (strikeType) { // Nếu có sét đánh
                strikeOccurred = true; const unlockedPlots = gameState.maxUnlockedPlots;
                if (unlockedPlots > 0) {
                    const targetIdx = Math.floor(Math.random() * unlockedPlots); // Chọn ô mục tiêu ngẫu nhiên
                    // Không đánh vào ô đang bị tornado
                    if (!gameState.activeTornadoes.some(t => t.plotId === targetIdx)) {
                        playLightningSound(); // Phát âm thanh (nếu hiệu ứng bật)
                        const targetPlotEl = gardenElement.querySelector(`.plot[data-plot-id="${targetIdx}"]`);
                        const plotData = gameState.plots[targetIdx];
                        const isRodPlot = isPlotWithRod(targetIdx); // Mục tiêu có phải là rod không?
                        const protectingRod = findRodInRange(targetIdx); // Có rod nào bảo vệ không?

                        // --- Trường hợp 1: Được cột thu lôi khác bảo vệ ---
                        if (protectingRod) {
                             protectingRod.health = Math.max(0, protectingRod.health - 1); // Giảm máu rod bảo vệ
                             plotStateChangedDuringTick = true;
                             const rodEl = gardenElement.querySelector(`.plot[data-plot-id="${protectingRod.plotId}"]`);
                             if (rodEl) { rodEl.classList.add('thunderstruck'); setTimeout(() => rodEl.classList.remove('thunderstruck'), 500); }
                             showMessage(`⚡ Cột thu lôi ô ${protectingRod.plotId + 1} hứng sét thay ô ${targetIdx + 1}! (HP: ${protectingRod.health}/${LIGHTNING_ROD_MAX_HEALTH})`, "warning");
                             logAction('lightning_intercepted', protectingRod.plotId, `Rod hứng sét thay ô ${targetIdx + 1}. HP ${protectingRod.health}.`, '🛡️⚡', LIGHTNING_ROD_ITEM_ID);
                             if (protectingRod.health <= 0) {
                                 showMessage(`⚠️ Cột thu lôi ở ô ${protectingRod.plotId + 1} đã hỏng!`, "error", 4500);
                                 logAction('rod_broken', protectingRod.plotId, `Rod ở ô ${protectingRod.plotId + 1} hỏng do sét.`, '💔⚡', LIGHTNING_ROD_ITEM_ID);
                             }
                             saveGame(); // Lưu trạng thái rod
                        }
                        // --- Trường hợp 2: Sét đánh trúng chính cột thu lôi ---
                        else if (isRodPlot) {
                             const rodData = getRodData(targetIdx);
                             if (rodData && rodData.health > 0) { // Chỉ giảm máu nếu rod còn hoạt động
                                  rodData.health = Math.max(0, rodData.health - 1);
                                  plotStateChangedDuringTick = true;
                                  const rodEl = gardenElement.querySelector(`.plot[data-plot-id="${targetIdx}"]`);
                                  if (rodEl) { rodEl.classList.add('thunderstruck'); setTimeout(() => rodEl.classList.remove('thunderstruck'), 500); }
                                  showMessage(`⚡ Cột thu lôi ô ${targetIdx + 1} bị sét đánh! (HP: ${rodData.health}/${LIGHTNING_ROD_MAX_HEALTH})`, "warning");
                                  logAction('lightning_strike_rod', targetIdx, `Rod bị sét đánh. HP ${rodData.health}.`, '💥⚡', LIGHTNING_ROD_ITEM_ID);
                                  if (rodData.health <= 0) {
                                      showMessage(`⚠️ Cột thu lôi ở ô ${targetIdx + 1} đã hỏng!`, "error", 4500);
                                      logAction('rod_broken', targetIdx, `Rod ở ô ${targetIdx + 1} hỏng do sét.`, '💔⚡', LIGHTNING_ROD_ITEM_ID);
                                  }
                                  saveGame();
                             }
                        }
                        // --- Trường hợp 3: Sét đánh trúng ô thường (không rod, không được bảo vệ) ---
                        else if (targetPlotEl && plotData && !targetPlotEl.classList.contains('locked')) {
                             targetPlotEl.classList.add('thunderstruck'); // Hiệu ứng rung lắc + GIF
                             setTimeout(() => targetPlotEl.classList.remove('thunderstruck'), STRIKE_DURATION_MS);

                             let dmgApplied = false; let msgType = 'warning'; let strikeMsg = `⚡ Sét đánh trúng ô ${targetIdx + 1}!`;
                             const plantName = plotData.seedId ? (ITEM_DATA[plotData.seedId]?.name || 'Cây') : null;

                             // Gây sát thương cho cây nếu có và còn sống
                             if (plotData.seedId && plotData.health > 0) {
                                  const oldH = plotData.health;
                                  plotData.health = Math.max(0, plotData.health - strikeDmgPlant);
                                  const lost = oldH - plotData.health;
                                  if(lost > 0) { strikeMsg += `\n${plantName} mất ${lost.toFixed(0)} HP!`; dmgApplied = true; plotStateChangedDuringTick = true; }
                                  if(plotData.health === 0 && oldH > 0) { // Nếu cây chết do sét
                                      plotData.causeOfDeath = 'lightning'; plotData.hasPest=false; plotData.isDry=false; plotData.pestDeathClickCount=0;
                                      strikeMsg += `\n${plantName} chết! 💀`; msgType='error';
                                      logAction('plant_death', targetIdx, `${plantName} ô ${targetIdx + 1} chết do sét đánh.`, '💀⚡', plotData.seedId);
                                  }
                             }
                             // Hoặc gây sát thương cho đất trống nếu còn phì nhiêu
                             else if (!plotData.seedId && plotData.fertility > 0) {
                                  const oldF = plotData.fertility;
                                  plotData.fertility = Math.max(0, plotData.fertility - strikeDmgSoil);
                                  const lost = oldF - plotData.fertility;
                                  if(lost > 0) { strikeMsg += `\nĐất giảm ${lost.toFixed(0)}% phì!`; dmgApplied = true; plotStateChangedDuringTick = true; }
                                  if(plotData.fertility === 0 && oldF > 0) { // Nếu đất thành cằn do sét
                                      strikeMsg += `\nĐất cằn!`; msgType='error'; plotData.barrenHarvestPenaltyFactor=1.0;
                                      logAction('soil_barren', targetIdx, `Đất ô ${targetIdx + 1} thành cằn do sét đánh.`, '🧱⚡', null);
                                  }
                             }

                             if(dmgApplied) { showMessage(strikeMsg, msgType, 4000); logAction('lightning_strike', targetIdx, strikeMsg.replace('\n',' - '), '⚡', null); }
                        }
                    } // end if (!isTornadoAffected)
                } // end if (unlockedPlots > 0)
            } // end if (strikeType)
            // --- KẾT THÚC XỬ LÝ SÉT ---

            // --- XỬ LÝ SỰ KIỆN TORNADO (WINDY 🌪️) - KÍCH HOẠT ---
            // Chỉ kích hoạt nếu đang là Windy, đến thời điểm, và đã được lên lịch (> 0)
            if (gameState.currentWeather.id === 'windy' && gameState.nextTornadoEventTimestamp > 0 && now >= gameState.nextTornadoEventTimestamp) {
                console.log("(Windy Event) Kích hoạt sự kiện gió lốc!");
                let affectedPlotsInfo = []; let messages = ["🌪️ Gió lốc quét qua vườn!"];
                const maxPlots = gameState.maxUnlockedPlots;
                const numAffected = Math.floor(Math.random() * Math.min(maxPlots, 5)) + 1; // 1-5 ô
                const availableIndices = []; // Tìm ô hợp lệ (không rod, không tornado khác)
                for(let i=0; i<maxPlots; ++i) { if(!gameState.activeTornadoes.some(t => t.plotId === i) && !isPlotWithRod(i)) { availableIndices.push(i); } }
                const targets = availableIndices.sort(() => 0.5 - Math.random()).slice(0, numAffected); // Chọn ngẫu nhiên

                targets.forEach(id => {
                    const plot = gameState.plots[id]; if(!plot) return;
                    let name= plot.seedId ? (ITEM_DATA[plot.seedId]?.name || "?") : "Đất trống";
                    let type= plot.seedId ? "plant" : "empty";
                    affectedPlotsInfo.push({plotId: id+1, name, type});
                    const isDestr = Math.random() < TORNADO_DESTRUCTION_CHANCE; // Quyết định phá hủy hay thiệt hại
                    const msg = isDestr ? "phá hủy!" : `thiệt hại nặng (${(TORNADO_PARTIAL_DAMAGE_FACTOR*100).toFixed(0)}%)!`;
                    gameState.activeTornadoes.push({ // Thêm vào danh sách hoạt động
                        plotId: id, expireTimestamp: now + TORNADO_EFFECT_DURATION_MS_WINDY,
                        isDestruction: isDestr, targetType: type
                    });
                    messages.push(`- ${name} ô ${id+1} bị ${msg}`);
                    plotStateChangedDuringTick = true; // Đánh dấu thay đổi
                });

                if(affectedPlotsInfo.length > 0) {
                    showMessage(messages.join('\n'), 'error', 3800 + affectedPlotsInfo.length*800);
                    logAction('tornado_event', null, `Lốc ảnh hưởng ô: ${affectedPlotsInfo.map(p=>p.plotId).join(',')}.`, '🌪️');
                }
                // Lên lịch cho sự kiện tornado tiếp theo
                const nextInt = TORNADO_EVENT_MIN_INTERVAL_MS_WINDY + Math.random()*(TORNADO_EVENT_MAX_INTERVAL_MS_WINDY - TORNADO_EVENT_MIN_INTERVAL_MS_WINDY);
                gameState.nextTornadoEventTimestamp = now + nextInt;
                console.log(`(Windy) Lốc tiếp theo sau ${formatTime(nextInt)}`);
            }
            // --- KẾT THÚC SỰ KIỆN TORNADO ---

            // --- XÓA TORNADO HẾT HẠN ---
            const initialTornadoCount = gameState.activeTornadoes.length;
            gameState.activeTornadoes = gameState.activeTornadoes.filter(t => t.expireTimestamp > now); // Lọc bỏ những cái đã hết hạn
            if (gameState.activeTornadoes.length < initialTornadoCount) {
                plotStateChangedDuringTick = true; // Cần render lại nếu có tornado bị xóa
                console.log(`Đã xóa ${initialTornadoCount - gameState.activeTornadoes.length} tornado hết hạn.`);
            }
            // --- KẾT THÚC XÓA TORNADO ---

            // === Render lại vườn NẾU có thay đổi trạng thái của bất kỳ ô nào ===
            if (plotStateChangedDuringTick) {
                renderGarden(); // Vẽ lại khu vườn
            }

            // Cập nhật modal nếu đang mở và dữ liệu ô tương ứng có thể đã thay đổi
            if (plantActionModal.style.display === 'block' && currentActionPlotId !== null && gameState.plots[currentActionPlotId]) { updatePlantActionModalButtons(currentActionPlotId); }
            if (emptyPlotActionModal.style.display === 'block' && currentActionPlotId !== null && gameState.plots[currentActionPlotId]) { updateEmptyPlotActionModal(currentActionPlotId); }
            if (lightningRodActionModal.style.display === 'block' && currentActionPlotId !== null && isPlotWithRod(currentActionPlotId)) { updateLightningRodActionModal(currentActionPlotId); }

            // Tự động lưu game định kỳ
            if (tickCounter % AUTO_SAVE_INTERVAL_TICKS === 0 && tickCounter > 0) {
                saveGame();
            }
        } // --- Kết thúc hàm gameTick ---

       
        /**
         * [CẬP NHẬT Req 4] Tính toán thời gian phát triển hiệu quả (tính bằng giây) dựa trên độ phì nhiêu và hệ số phạt.
         */
         function getEffectiveGrowthTime(plot) {
            if (!plot || !plot.seedId) return 0;
            const seedInfo = ITEM_DATA[plot.seedId];
            if (!seedInfo || seedInfo.type !== 'seed') return 0;

            const baseGrowthTime = seedInfo.growthTime;
            if (baseGrowthTime <= 0) return 0;

            const plotFertility = plot.fertility;
            const penaltyFactor = plot.barrenHarvestPenaltyFactor || 1.0;

            // Áp dụng hệ số phạt CHỈ KHI đất cằn (<= 0%)
            if (plotFertility <= 0 && penaltyFactor > 1.0) {
                const totalEffectiveTime = baseGrowthTime * penaltyFactor;
                // console.log(`Plot ${plot.id} barren. Base: ${baseGrowthTime}s, Factor: ${penaltyFactor}, Effective: ${totalEffectiveTime}s`);
                return Math.max(baseGrowthTime, totalEffectiveTime); // Đảm bảo không ít hơn thời gian gốc
            }

            // Trả về thời gian gốc nếu đất không cằn hoặc không có penalty factor > 1
            return baseGrowthTime;
        }


        /** Lấy thông tin toàn diện về trạng thái, độ trưởng thành và NGUỒN HÌNH ẢNH của cây. */
        function getPlantStageInfo(plot, currentTime) {
            // --- Phần khởi tạo giá trị mặc định ---
            const defaultReturn = {
                visualSrc: '', stageIndex: -1, isMature: false, isDead: false, growthProgress: 0,
                health: plot.health, fertility: plot.fertility, hasPest: plot.hasPest,
                effectiveGrowthTimeSec: 0, isError: false, causeOfDeath: plot.causeOfDeath,
                barrenHarvestPenaltyFactor: plot.barrenHarvestPenaltyFactor || 1.0
            };

            if (!plot.seedId || !plot.plantTime) {
                return { ...defaultReturn, fertility: plot.fertility, health: INITIAL_PLANT_HEALTH, barrenHarvestPenaltyFactor: plot.barrenHarvestPenaltyFactor || 1.0 };
            }

            const seedInfo = ITEM_DATA[plot.seedId];
            if (!seedInfo || seedInfo.type !== 'seed' || !seedInfo.imageFolder) {
                console.error(`SeedId "${plot.seedId}" không hợp lệ hoặc thiếu imageFolder trong ô ${plot.id}`);
                return { ...defaultReturn, isError: true, health: plot.health, fertility: plot.fertility, hasPest: plot.hasPest, causeOfDeath: plot.causeOfDeath, barrenHarvestPenaltyFactor: plot.barrenHarvestPenaltyFactor || 1.0 };
            }

            // --- Phần tính toán thời gian, tiến trình, giai đoạn ---
            const effectiveGrowthTimeSec = getEffectiveGrowthTime(plot);
            const totalGrowthTimeMs = effectiveGrowthTimeSec * 1000;
            const elapsedTime = currentTime - plot.plantTime;
            const growthProgress = totalGrowthTimeMs > 0 ? Math.min(1, elapsedTime / totalGrowthTimeMs) : 1;

            let stageIndex = -1;
            let visualSrc = '';
            const isDead = plot.health <= 0;
            const baseImagePath = `Hinhanh/${seedInfo.imageFolder}/`;

            // --- Xử lý cây chết ---
            if (isDead) {
                stageIndex = -2;
                // Sử dụng ảnh chết chung cho sâu, sét, lốc
                if (plot.causeOfDeath === 'pest' || plot.causeOfDeath === 'lightning' || plot.causeOfDeath === 'tornado') {
                    visualSrc = 'Hinhanh/Caychet.png';
                } else { // Chết tự nhiên, khô hạn, không rõ
                    visualSrc = baseImagePath + 'Caychet.png';
                }
            } else { // Cây còn sống
                const stageThresholds = [0, 0.3, 0.7, 1.0];
                for (let i = stageThresholds.length - 1; i >= 0; i--) {
                    if (growthProgress >= stageThresholds[i] - 0.0001) {
                        stageIndex = i;
                        visualSrc = baseImagePath + `pic_hatgiong_giaidoan${i + 1}.png`;
                        break;
                    }
                }
                if (stageIndex === -1 && growthProgress >= 0) { // Fallback nếu không lọt vòng lặp
                    stageIndex = 0;
                    visualSrc = baseImagePath + 'pic_hatgiong_giaidoan1.png';
                }
            }

            // --- Phần xác định isMature và fallback images ---
            const isMature = (growthProgress >= 1.0 - 0.0001) && !isDead && !plot.hasPest;
            // Fallback images
            if (isMature && !visualSrc && !isDead) {
                 visualSrc = baseImagePath + `pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
                 stageIndex = PLANT_GROWTH_STAGES - 1;
            }
            if (isDead && !visualSrc) {
                if (plot.causeOfDeath === 'pest' || plot.causeOfDeath === 'lightning' || plot.causeOfDeath === 'tornado') {
                     visualSrc = 'Hinhanh/Caychet.png';
                } else {
                     visualSrc = baseImagePath + 'pic_hatgiong_giaidoanchet.png';
                }
            }
            if (!visualSrc && stageIndex >= 0 && !isDead) visualSrc = 'Hinhanh/General/ErrorPlant.png';
            if (!visualSrc) visualSrc = 'Hinhanh/Caychet.png';

            // --- Trả về kết quả tổng hợp ---
            return {
                visualSrc, stageIndex, isMature, isDead, growthProgress,
                health: plot.health, fertility: plot.fertility, hasPest: plot.hasPest,
                effectiveGrowthTimeSec, isError: false, causeOfDeath: plot.causeOfDeath,
                barrenHarvestPenaltyFactor: plot.barrenHarvestPenaltyFactor || 1.0
            };
        } // --- Kết thúc hàm getPlantStageInfo ---

        /** Render các phần tử UI chính (tiền, số ô đất). */
        function renderUI() {
            currencyElement.textContent = gameState.currency;
            plotCountElement.textContent = `${gameState.maxUnlockedPlots}`;
        }

        /** Điền vào modal cửa hàng với các tab và vật phẩm. */
        

        /** Render modal kho đồ với ô nhập số lượng bán. */
       function renderInventory() {
    inventoryHarvestedList.innerHTML = '';
    inventoryPurchasedList.innerHTML = '';
    let harvestedCount = 0;
    let purchasedCount = 0;

    // --- Tính toán và cập nhật tiêu đề kho đồ ---
    const currentTotalCount = getTotalInventoryCount(); // Sử dụng hàm đã cập nhật
    const inventoryTitleElement = inventoryModal.querySelector('.modal-header h2');
    if (inventoryTitleElement) {
        inventoryTitleElement.textContent = `🎒 Túi Đồ Của Bạn (${currentTotalCount}/${gameState.maxInventoryCapacity})`;
    }

    // --- Render Tab Đã Thu Hoạch (CÓ CHẤT LƯỢNG) ---
    const harvestedItemIds = Object.keys(gameState.harvestedItems);
    harvestedItemIds.sort((a, b) => (ITEM_DATA[a]?.name || '').localeCompare(ITEM_DATA[b]?.name || ''));

    harvestedItemIds.forEach(itemId => {
        const qualityData = gameState.harvestedItems[itemId];
        if (!qualityData) { // Thêm kiểm tra phòng lỗi
             delete gameState.harvestedItems[itemId];
             return;
        }
        // Tính tổng số lượng từ các bậc chất lượng
        const totalQuantity = (qualityData[QUALITY_TIERS.PERFECT] || 0) +
                              (qualityData[QUALITY_TIERS.GOOD] || 0) +
                              (qualityData[QUALITY_TIERS.FAIR] || 0) +
                              (qualityData[QUALITY_TIERS.POOR] || 0);

        if (totalQuantity > 0) {
            harvestedCount++;
            const item = ITEM_DATA[itemId];
            if (!item || item.type !== 'seed') {
                console.warn(`Vật phẩm thu hoạch "${itemId}" không phải hạt giống hoặc không tồn tại.`);
                // Xóa dữ liệu lỗi khỏi kho
                delete gameState.harvestedItems[itemId];
                return;
            }

            const itemCard = document.createElement('div');
            itemCard.classList.add('item-card', 'no-hover');
            itemCard.dataset.itemId = itemId;

            let iconSrc = item.imageFolder ? `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png` : 'Hinhanh/Caychet.png';
            const imgTagInv = `<img src="${iconSrc}" alt="${item.name}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
            const iconHtml = `<span class="item-icon">${imgTagInv}</span>`;

            const baseValue = item.harvestYield || 0;
            let totalPotentialValue = 0; // Tổng giá trị nếu bán hết

            // Xây dựng chuỗi hiển thị chi tiết chất lượng và tính tổng giá trị
            let qualityDetailsHtml = '<div class="item-quality-details" style="font-size: 0.75rem; margin-bottom: 6px; text-align: left; padding: 0 5px;">';
            let qualityParts = [];
            const tierOrder = [QUALITY_TIERS.PERFECT, QUALITY_TIERS.GOOD, QUALITY_TIERS.FAIR, QUALITY_TIERS.POOR];
            tierOrder.forEach(tier => {
                const count = qualityData[tier] || 0;
                if (count > 0) {
                    const tierValue = Math.round(baseValue * (QUALITY_VALUE_MULTIPLIERS[tier] || 0));
                    qualityParts.push(`${QUALITY_DISPLAY_NAMES[tier]}: ${count} (Giá: ${tierValue}💰)`);
                    totalPotentialValue += count * tierValue;
                }
            });
            // Xử lý trường hợp không có chất lượng nào (dù totalQuantity > 0, nên không xảy ra)
            if (qualityParts.length === 0) qualityParts.push("Không có dữ liệu chất lượng");
            qualityDetailsHtml += qualityParts.join('<br>') + '</div>';

            itemCard.innerHTML = `
                ${iconHtml}
                <div class="item-name">${item.name}</div>
                <div class="item-quantity">Tổng số lượng: <span class="current-quantity">${totalQuantity}</span></div>
                <!-- Hiển thị chi tiết chất lượng -->
                ${qualityDetailsHtml}
                <div class="item-harvest-value">Tổng giá trị (bán hết): <span>${totalPotentialValue}💰</span></div>
                <div class="sell-container">
                    <div class="sell-quantity-selector">
                        <label for="sell-qty-${itemId}">Bán SL:</label>
                        <input type="number" id="sell-qty-${itemId}" class="sell-quantity-input" value="1" min="1" max="${totalQuantity}" step="1" data-item-id="${itemId}">
                    </div>
                    <div class="sell-buttons-row" style="display: flex; justify-content: center; gap: 8px; width: 100%; margin-top: 5px;">
                        <button class="sell-button sell-selected-button" data-item-id="${itemId}" title="Bán số lượng đã chọn (Ưu tiên chất lượng thấp)">Bán</button>
                        <button class="sell-button sell-all-button" data-item-id="${itemId}" title="Bán hết ${totalQuantity} ${item.name} (Giá trị: ${totalPotentialValue}💰)">Bán Hết</button>
                    </div>
                </div>
            `;
            inventoryHarvestedList.appendChild(itemCard);
        } else {
            // Nếu tổng số lượng = 0 nhưng key vẫn tồn tại, xóa nó đi
            if (gameState.harvestedItems[itemId]) {
                delete gameState.harvestedItems[itemId];
            }
        }
    });

    // --- Render Tab Đã Mua ---
    const purchasedItemIds = Object.keys(gameState.inventory);
    purchasedItemIds.sort((a, b) => {
        const itemA = ITEM_DATA[a]; const itemB = ITEM_DATA[b];
        if (!itemA) return 1; if (!itemB) return -1;
        // Sửa lại thứ tự ưu tiên: tool -> upgrade -> seed
        const typeOrderInv = { 'tool': 1, 'upgrade': 2, 'seed': 3 };
        const orderAInv = typeOrderInv[itemA.type] || 99;
        const orderBInv = typeOrderInv[itemB.type] || 99;
        if (orderAInv !== orderBInv) return orderAInv - orderBInv;
        // Trong cùng type 'tool', ưu tiên pesticide rồi đến giá
        if (itemA.type === 'tool') {
            if (itemA.id === 'pesticide') return -1;
            if (itemB.id === 'pesticide') return 1;
            const priceDiff = (itemA.price || 0) - (itemB.price || 0);
            if (priceDiff !== 0) return priceDiff;
        }
        // Sắp xếp theo giá cho seed và upgrade
        const priceDiffGeneral = (itemA.price || 0) - (itemB.price || 0);
        if (priceDiffGeneral !== 0) return priceDiffGeneral;
        // Nếu giá bằng nhau, sắp xếp theo tên
        return (itemA.name || '').localeCompare(itemB.name || '');
    });

    purchasedItemIds.forEach(itemId => {
        const quantity = gameState.inventory[itemId];
        if (quantity > 0) {
            purchasedCount++;
            const item = ITEM_DATA[itemId];
            if (!item) { console.warn(`Vật phẩm đã mua "${itemId}" không tìm thấy trong ITEM_DATA.`); return; }

            const itemCard = document.createElement('div');
            itemCard.classList.add('item-card', 'no-hover');
            itemCard.dataset.itemId = itemId;

            let iconHtml = '';
            let detailsHtml = '';
            let quantityClass = '';

            // ---- LOGIC LẤY ICON ĐÃ ĐƯỢC SỬA ----
            let iconSrc = 'Hinhanh/Caychet.png'; // Ảnh mặc định
            if (item.type === 'seed' && item.imageFolder) {
                iconSrc = `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
            } else if (item.type === 'tool' && item.imageFolder && item.imageFile) {
                iconSrc = `${item.imageFolder}/${item.imageFile}`;
            }
            // <<< ĐIỀU KIỆN ĐÃ THÊM CHO UPGRADE >>>
            else if (item.type === 'upgrade' && item.imageFolder && item.imageFile) {
                // Lấy ảnh từ imageFolder và imageFile giống như tool
                iconSrc = `${item.imageFolder}/${item.imageFile}`;
            }
            // ---- KẾT THÚC SỬA LOGIC ICON ----

            const imgTagPurch = `<img src="${iconSrc}" alt="${item.name}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
            iconHtml = `<span class="item-icon">${imgTagPurch}</span>`;

            // Tạo details và class cho quantity (logic không đổi)
            if (item.type === 'seed') {
                detailsHtml = `<div class="item-details" style="font-size: 0.7rem;">(Lớn: ${formatTime(item.growthTime * 1000, true)}, Hao: ${(item.fertilityCost*100).toFixed(0)}% đất)</div>`;
            } else if (item.id === 'pesticide') {
                detailsHtml = `<div class="item-details" style="font-size: 0.75rem;">${item.description || ''}</div>`;
                quantityClass = 'pesticide';
            } else if (item.type === 'tool') { // Phân bón & các tool khác (không phải upgrade)
                 detailsHtml = `<div class="item-details" style="font-size: 0.75rem;">`;
                 if (typeof item.fertilityBoost === 'number') detailsHtml += `<div>💩 Phì: +${(item.fertilityBoost * 100).toFixed(0)}%</div>`;
                 // Thêm mô tả nếu có và không chỉ là về phì nhiêu
                 if (item.description) detailsHtml += `<div>${item.description}</div>`;
                 detailsHtml += `</div>`;
                 if (typeof item.fertilityBoost === 'number') quantityClass = 'fertilizer';
            } else if (item.type === 'upgrade') { // Thêm xử lý cho upgrade
                detailsHtml = `<div class="item-details" style="font-size: 0.75rem;">${item.description || 'Nâng cấp'}</div>`;
                quantityClass = 'upgrade'; // Có thể thêm class riêng nếu muốn style khác
            }

            // Tạo innerHTML cho thẻ vật phẩm
            itemCard.innerHTML = `
                ${iconHtml}
                <div class="item-name">${item.name}</div>
                <div class="item-quantity ${quantityClass}">Số lượng: ${quantity}</div>
                ${detailsHtml}
                <button class="action-button discard-purchased-button" data-item-id="${itemId}" title="Bỏ vật phẩm này..." style="background-color: #e74c3c; margin-top: 8px; padding: 5px 10px; font-size: 0.75rem;">Bỏ đi...</button>
            `;
            inventoryPurchasedList.appendChild(itemCard);
        }
   });

    // --- Hiển thị/ẩn thông báo trống và danh sách ---
    inventoryHarvestedEmptyMessage.style.display = harvestedCount === 0 ? 'block' : 'none';
    inventoryPurchasedEmptyMessage.style.display = purchasedCount === 0 ? 'block' : 'none';
    const activeTab = inventoryTabsContainer.querySelector('.tab-button.active')?.dataset.tab || 'harvested';
    switchInventoryTab(activeTab); // Gọi lại để đảm bảo hiển thị đúng
    inventoryHarvestedList.style.display = (harvestedCount > 0 && inventoryHarvestedList.classList.contains('active-list')) ? 'grid' : 'none';
    inventoryPurchasedList.style.display = (purchasedCount > 0 && inventoryPurchasedList.classList.contains('active-list')) ? 'grid' : 'none';
} // --- Kết thúc hàm renderInventory ---
function buyInventoryUpgrade(itemId) {
    const item = ITEM_DATA[itemId];
    console.log(`Attempting to buy upgrade: ${itemId}`); // Debug log

    // --- Kiểm tra cơ bản ---
    if (!item || item.type !== 'upgrade' || !item.upgradeCapacity) {
        showMessage("Lỗi: Vật phẩm nâng cấp không hợp lệ!", "error");
        console.error(`buyInventoryUpgrade: Invalid item or missing upgradeCapacity for ${itemId}`);
        return;
    }

    const requiredCapacity = item.upgradeCapacity.from;
    const newCapacity = item.upgradeCapacity.to;
    const cost = item.price;

    // --- Kiểm tra điều kiện mua ---
    if (gameState.maxInventoryCapacity !== requiredCapacity) {
        showMessage(`Yêu cầu sức chứa kho hiện tại là ${requiredCapacity} để mua "${item.name}". Kho của bạn đang là ${gameState.maxInventoryCapacity}.`, "warning");
        console.warn(`buyInventoryUpgrade: Capacity requirement not met for ${itemId}. Current: ${gameState.maxInventoryCapacity}, Required: ${requiredCapacity}`);
        return;
    }

    if (gameState.currency < cost) {
        showMessage(`Không đủ tiền mua "${item.name}"! Cần ${cost}💰.`, "error");
        console.warn(`buyInventoryUpgrade: Insufficient funds for ${itemId}. Have: ${gameState.currency}, Need: ${cost}`);
        // Cập nhật lại nút trong shop để đảm bảo nó disabled
        if (shopModal.style.display === 'block') updateShopButtons();
        return;
    }

    // --- Thực hiện nâng cấp ---
    gameState.currency -= cost;
    gameState.maxInventoryCapacity = newCapacity;
    console.log(`Inventory capacity upgraded to ${newCapacity}`);

    // --- Cập nhật giao diện & Lưu game ---
    renderUI(); // Cập nhật tiền
    renderInventory(); // Cập nhật tiêu đề kho đồ
    updateShopButtons(); // Vô hiệu hóa nút vừa mua, có thể kích hoạt nút nâng cấp tiếp theo
    saveGame();

    // --- Thông báo & Log ---
    showMessage(`Chúc mừng! Kho đồ đã được nâng cấp lên ${newCapacity} chỗ!`, "success");
    logAction('buy_upgrade', null, `Mua nâng cấp "${item.name}", kho lên ${newCapacity} chỗ (-${cost}💰).`, '⬆️🎒', itemId);

    // --- Cập nhật lại shop một lần nữa để chắc chắn ---
    // (Đôi khi renderInventory hoặc renderUI có thể ảnh hưởng đến updateShopButtons trước đó)
     if (shopModal.style.display === 'block') {
         setTimeout(updateShopButtons, 50); // Delay nhỏ để đảm bảo các cập nhật khác hoàn tất
     }
}




	  
function clearPlantOnly(plotId) {
             // 1. Kiểm tra đầu vào (giống clearPlot)
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                 console.warn(`Cố gắng dọn cây trên ô không hợp lệ/bị khóa ${plotId}.`);
                 return;
             }
             const plot = gameState.plots[plotId];

             // 2. Lưu trữ thông tin *trước* khi reset (giống clearPlot)
             const wasPlanted = !!plot.seedId;
             const originalSeedId = plot.seedId;
             const plantName = wasPlanted ? (ITEM_DATA[originalSeedId]?.name || 'cây') : 'ô đất';
             const wasDead = wasPlanted && plot.health <= 0;
             const causeOfDeath = plot.causeOfDeath;
             const wasPestDeath = wasDead && causeOfDeath === 'pest';
             const wasFreePestCleanup = wasPestDeath && (plot.pestDeathClickCount || 0) >= DEAD_PEST_FREE_CLEANUP_CLICKS;

             // 3. --- Reset Trạng Thái Cây Trồng (KHÔNG chạm vào fenceData) ---
             plot.seedId = null;
             plot.plantTime = null;
             plot.hasPest = false;
             plot.health = INITIAL_PLANT_HEALTH;
             plot.causeOfDeath = null;
             plot.pestDeathClickCount = 0;
             // plot.fertility KHÔNG reset
             plot.barrenHarvestPenaltyFactor = 1.0; // Reset hệ số phạt
             plot.isDry = false; // Reset khô hạn
             // --- Reset Buff khi Chỉ Dọn Cây ---
             plot.fertilizerGrowthUsageCount = 0; // Reset bộ đếm khi chỉ dọn cây
             plot.fertilizerProtectUsageCount = 0; // Reset bộ đếm khi chỉ dọn cây
             plot.hasFertilizerProtectBuff = false; // Reset buff khi chỉ dọn cây
             // --- Kết Thúc Reset Buff ---
             // *** Dòng plot.fenceData = null; đã bị XÓA bỏ ***

             // 4. Cập nhật giao diện và Lưu game (giống clearPlot)
             renderGarden();
             saveGame();

             // 5. Log Action (giống clearPlot, có thể giữ nguyên hoặc sửa nhẹ text nếu muốn)
             let logDetails = '';
             let logIcon = '⛏️';
             if (wasPlanted) {
                 if (wasPestDeath) {
                     logIcon = '💀';
                     logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết do sâu, ${wasFreePestCleanup ? 'miễn phí' : 'tốn phí'}).`; // Bỏ 'ở ô...'
                 } else if (wasDead && causeOfDeath === 'dryness') {
                     logIcon = '💀';
                     logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết do khô hạn).`;
                 } else if (wasDead && causeOfDeath === 'lightning') {
                     logIcon = '💀⚡';
                     logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết do sét đánh).`;
                 } else if (wasDead && causeOfDeath === 'tornado') { // Thêm case gió lốc
                    logIcon = '💀🌪️';
                    logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết do gió lốc).`;
                 } else if (wasDead) {
                     logIcon = '💀';
                     logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết tự nhiên/khác).`;
                 } else {
                     logDetails = `Ô ${plotId + 1}: Xới bỏ ${plantName} (đang sống).`;
                 }
             } else {
                 logDetails = `Đã xới/dọn ô đất trống ${plotId + 1}.`;
             }
             logAction('clear_plant', plotId, logDetails, logIcon, originalSeedId); // Có thể đổi type log nếu muốn

             // 6. Hiển thị Thông báo (giống clearPlot, có thể giữ nguyên)
              if (!(wasPestDeath && !wasFreePestCleanup)) {
                 if (wasFreePestCleanup) { /* Message đã hiện khi đủ click */ }
                 else if (wasDead && causeOfDeath === 'dryness') { showMessage(`Đã dọn ${plantName} chết khô khỏi ô ${plotId + 1}.`, "info"); }
                 else if (wasDead && causeOfDeath === 'lightning') { showMessage(`Đã dọn ${plantName} chết do sét đánh khỏi ô ${plotId + 1}.`, "info"); }
                 else if (wasDead && causeOfDeath === 'tornado') { showMessage(`Đã dọn ${plantName} chết do gió lốc khỏi ô ${plotId + 1}.`, "info"); }
                 else if (wasPlanted && !wasDead) { showMessage(`Đã xới bỏ ${plantName} đang sống ở ô ${plotId + 1}.`, "warning"); }
                 else if (wasDead) { showMessage(`Đã dọn ${plantName} chết khỏi ô ${plotId + 1}.`, "info"); }
             }

             // 7. Đóng modal hành động nếu nó đang mở (giống clearPlot)
             if (plantActionModal.style.display === 'block' && currentActionPlotId === plotId) {
                 closeModal('plant-action-modal');
                 currentActionPlotId = null;
             }
         } // --- Kết thúc hàm clearPlantOnly ---
	  
	/** Đóng popup xác nhận bỏ vật phẩm */
function closeDiscardItemPopup() {
    if (discardItemPopup) {
        discardItemPopup.style.display = 'none';
        // Tùy chọn: Reset input và error message khi đóng
        if(discardQuantityInput) discardQuantityInput.value = 1;
        if(discardQuantityError) discardQuantityError.textContent = '';
        if(confirmDiscardBtn) delete confirmDiscardBtn.dataset.itemId;
    }
}  
	  

		 function discardPurchasedItem(itemId, quantityToDiscard) {
    // 1. Validate itemId và lấy thông tin item
    const item = ITEM_DATA[itemId];
    if (!item) {
        console.error(`discardPurchasedItem: Vật phẩm không tồn tại: ${itemId}`);
        showMessage("Lỗi: Không thể bỏ vật phẩm không tồn tại.", "error");
        return;
    }

    // 2. Kiểm tra số lượng hiện có trong kho ĐÃ MUA
    const currentQuantity = gameState.inventory[itemId] || 0;

    // 3. Validate quantityToDiscard (đảm bảo là số, > 0 và <= số lượng hiện có)
    const validQuantityToDiscard = parseInt(quantityToDiscard);
    if (isNaN(validQuantityToDiscard) || validQuantityToDiscard <= 0) {
         showMessage(`Số lượng (${quantityToDiscard}) cần bỏ không hợp lệ.`, "error");
         console.warn(`discardPurchasedItem: Số lượng bỏ không hợp lệ: ${quantityToDiscard}`);
         return;
    }
    if (validQuantityToDiscard > currentQuantity) {
         showMessage(`Không thể bỏ ${validQuantityToDiscard} ${item.name}, bạn chỉ có ${currentQuantity}.`, "error");
         console.warn(`discardPurchasedItem: Số lượng bỏ (${validQuantityToDiscard}) > số lượng hiện có (${currentQuantity}) cho ${itemId}.`);
         return;
    }

    // 4. Thực hiện bỏ vật phẩm
    gameState.inventory[itemId] -= validQuantityToDiscard;
    console.log(`Đã bỏ ${validQuantityToDiscard} ${item.name}.`);

    // 5. Xóa key nếu số lượng về 0
    if (gameState.inventory[itemId] <= 0) {
        delete gameState.inventory[itemId];
        console.log(`Đã xóa hết ${item.name} (ID: ${itemId}) khỏi kho đã mua.`);
    } else {
        console.log(`Còn lại: ${gameState.inventory[itemId]} ${item.name}.`);
    }

    // 6. Cập nhật UI và các modal liên quan
    renderInventory(); // Quan trọng: Cập nhật lại kho đồ ngay lập tức
    updateShopButtons(); // Nếu bỏ thuốc/phân bón có thể ảnh hưởng shop
    if (seedSelectionModal.style.display === 'block' && item.type === 'seed') populateSeedSelection();
    if (fertilizerSelectionModal.style.display === 'block' && item.type === 'tool' && typeof item.fertilityBoost === 'number') populateFertilizerSelection();
    if (plantActionModal.style.display === 'block' && currentActionPlotId !== null) updatePlantActionModalButtons(currentActionPlotId);
    if (emptyPlotActionModal.style.display === 'block' && currentActionPlotId !== null) updateEmptyPlotActionModal(currentActionPlotId);

    // 7. Hiển thị thông báo
    showMessage(`Đã bỏ ${validQuantityToDiscard} ${item.name} khỏi túi đồ.`, "info");

    // 8. Lưu game
    saveGame();

    // 9. Log hành động - CẬP NHẬT CHI TIẾT LOG
    logAction('discard', null, `Bỏ từ kho: ${validQuantityToDiscard} ${item.name}.`, '🗑️', itemId);
}

		function handleDiscardPurchasedItemClick(event) {
    // Sử dụng event delegation: Tìm nút ".discard-purchased-button" gần nhất với phần tử được click.
    const discardButton = event.target.closest('.discard-purchased-button');

    // Nếu không click vào nút này hoặc phần tử cha của nó, thì bỏ qua.
    if (!discardButton) {
        return;
    }

    console.log("[DEBUG] Nút 'Bỏ đi...' đã được click."); // Log khi nút được click

    // Tìm thẻ .item-card cha để lấy itemId
    const itemCard = discardButton.closest('.item-card');
    if (!itemCard) {
        console.error("[Lỗi] Không tìm thấy thẻ '.item-card' cha của nút bỏ vật phẩm.");
        return;
    }

    const itemId = itemCard.dataset.itemId;

    // Kiểm tra xem itemId có hợp lệ và tồn tại trong dữ liệu game không
    if (!itemId || !ITEM_DATA[itemId]) {
        console.error(`[Lỗi] Không tìm thấy itemId hợp lệ ('${itemId}') hoặc dữ liệu cho item này trong ITEM_DATA.`);
        showMessage("Lỗi: Không thể xác định vật phẩm cần bỏ.", "error");
        return;
    }

    const item = ITEM_DATA[itemId];
    const currentQuantity = gameState.inventory[itemId] || 0; // Lấy số lượng hiện có từ gameState

    console.log(`[DEBUG] Thông tin vật phẩm: ID=${itemId}, Tên=${item.name}, Số lượng hiện có=${currentQuantity}`);

    // Kiểm tra xem người chơi có thực sự còn vật phẩm này không
    if (currentQuantity <= 0) {
        showMessage(`Bạn không còn ${item.name} để bỏ.`, "warning");
        console.warn(`[Cảnh báo] Cố gắng bỏ '${itemId}' nhưng số lượng là ${currentQuantity}. Có thể giao diện chưa cập nhật.`);
        // Cập nhật lại giao diện kho đồ phòng trường hợp nút vẫn hiển thị khi item đã hết
        if (inventoryModal.style.display === 'block') {
            renderInventory();
        }
        return;
    }

    // Xác định đường dẫn ảnh icon (lấy logic từ hàm renderInventory hoặc populateShop)
    let iconSrc = 'Hinhanh/Caychet.png'; // Icon mặc định nếu không tìm thấy
    if (item.type === 'seed' && item.imageFolder) {
        iconSrc = `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
    } else if (item.type === 'tool' && item.imageFolder && item.imageFile) {
        iconSrc = `${item.imageFolder}/${item.imageFile}`;
    }
    console.log(`[DEBUG] Đường dẫn icon được xác định: ${iconSrc}`);

    // Nếu mọi thứ hợp lệ, gọi hàm để mở popup xác nhận
    console.log("[DEBUG] Đang gọi hàm openDiscardItemPopup...");
    openDiscardItemPopup(itemId, item.name, currentQuantity, iconSrc);

} // --- Kết thúc hàm handleDiscardPurchasedItemClick ---
function openDiscardItemPopup(itemId, itemName, currentQuantity, iconSrc) {
    console.log(`[DEBUG] --- Bắt đầu mở Popup Xác Nhận Bỏ cho: ${itemName} (ID: ${itemId}) ---`);

    // 1. Lấy tham chiếu đến các phần tử DOM bên trong popup
    const popupElement = document.getElementById('discard-item-popup');
    const iconContainer = document.getElementById('discard-item-icon'); // Span chứa img
    const nameElement = document.getElementById('discard-item-name');
    const currentQuantityElement = document.getElementById('discard-current-quantity');
    const quantityInputElement = document.getElementById('discard-quantity-input');
    const confirmButton = document.getElementById('confirm-discard-btn');
    const errorElement = document.getElementById('discard-quantity-error'); // Span hiển thị lỗi

    // 2. Kiểm tra nghiêm ngặt xem tất cả các phần tử cần thiết có tồn tại không
    let domError = false;
    if (!popupElement) { console.error("[Lỗi DOM] Không tìm thấy phần tử popup chính #discard-item-popup!"); domError = true; }
    if (!iconContainer) { console.error("[Lỗi DOM] Không tìm thấy container icon #discard-item-icon!"); domError = true; }
    if (!nameElement) { console.error("[Lỗi DOM] Không tìm thấy phần tử tên #discard-item-name!"); domError = true; }
    if (!currentQuantityElement) { console.error("[Lỗi DOM] Không tìm thấy phần tử số lượng hiện tại #discard-current-quantity!"); domError = true; }
    if (!quantityInputElement) { console.error("[Lỗi DOM] Không tìm thấy ô nhập số lượng #discard-quantity-input!"); domError = true; }
    if (!confirmButton) { console.error("[Lỗi DOM] Không tìm thấy nút xác nhận #confirm-discard-btn!"); domError = true; }
    if (!errorElement) { console.error("[Lỗi DOM] Không tìm thấy phần tử báo lỗi #discard-quantity-error!"); domError = true; }

    // Nếu có lỗi tìm DOM, dừng lại và báo lỗi
    if (domError) {
        showMessage("Lỗi giao diện: Không thể hiển thị hộp thoại xác nhận.", "error");
        return;
    }

    console.log("[DEBUG] Đã tìm thấy tất cả các phần tử DOM cần thiết của popup.");

    // 3. Tìm thẻ <img> bên trong container icon
    const iconImageElement = iconContainer.querySelector('img');
    if (!iconImageElement) {
        console.error("[Lỗi DOM] Không tìm thấy thẻ <img> bên trong #discard-item-icon. Hãy kiểm tra lại cấu trúc HTML.");
        // Cân nhắc tạo thẻ img nếu muốn linh hoạt hơn, nhưng hiện tại báo lỗi và dừng
        return;
    }

    // 4. Cập nhật nội dung popup với thông tin vật phẩm
    iconImageElement.src = iconSrc;
    iconImageElement.alt = itemName; // Cập nhật alt text
    // Gắn onerror để hiển thị icon lỗi nếu src không hợp lệ
    iconImageElement.onerror = () => {
        console.warn(`[Cảnh báo] Không tải được icon từ: ${iconSrc}. Hiển thị icon mặc định.`);
        if (iconImageElement.src !== 'Hinhanh/Caychet.png') {
            iconImageElement.src = 'Hinhanh/Caychet.png';
        }
    };
    nameElement.textContent = itemName;             // Đặt tên vật phẩm
    currentQuantityElement.textContent = currentQuantity; // Hiển thị số lượng hiện có

    // 5. Thiết lập ô nhập số lượng
    quantityInputElement.value = 1;                 // Reset giá trị về 1
    quantityInputElement.min = 1;                   // Số lượng tối thiểu là 1
    quantityInputElement.max = currentQuantity;     // Số lượng tối đa là số hiện có

    // 6. Reset trạng thái lỗi và nút
    errorElement.textContent = '';                  // Xóa thông báo lỗi cũ
    errorElement.style.display = 'none';            // Ẩn vùng báo lỗi
    confirmButton.disabled = false;                 // Bật lại nút xác nhận (nếu trước đó bị tắt)

    // 7. Lưu trữ itemId vào data attribute của nút xác nhận
    // Hàm handleConfirmDiscardClick sẽ đọc giá trị này để biết cần bỏ item nào
    confirmButton.dataset.itemId = itemId;
    console.log(`[DEBUG] Đã gắn itemId '${itemId}' vào dataset của nút xác nhận.`);

    // 8. Hiển thị popup
    console.log("[DEBUG] Chuẩn bị hiển thị popup bằng cách đặt style.display = 'block'.");
    popupElement.style.display = 'block'; // Hoặc 'flex' tùy vào CSS của bạn

    // 9. Tùy chọn: Tự động focus vào ô nhập số lượng để người dùng nhập dễ hơn
    // Dùng setTimeout để đảm bảo trình duyệt đã render popup trước khi focus
    setTimeout(() => {
        quantityInputElement.focus();
        console.log("[DEBUG] Đã focus vào ô nhập số lượng.");
    }, 50); // Delay nhỏ

    console.log("[DEBUG] --- Popup Xác Nhận Bỏ đã được mở thành công ---");

} // --- Kết thúc hàm openDiscardItemPopup ---





		/** Xử lý click nút "Xác nhận bỏ" trong popup */
function handleConfirmDiscardClick() {
    if (!confirmDiscardBtn || !discardQuantityInput || !discardQuantityError) return;

    const itemId = confirmDiscardBtn.dataset.itemId;
    const quantityToDiscardStr = discardQuantityInput.value;
    const quantityToDiscard = parseInt(quantityToDiscardStr);
    const currentMax = parseInt(discardQuantityInput.max);

    // --- Validation ---
    let isValid = true;
    let errorMsg = '';

    if (!itemId) {
        errorMsg = 'Lỗi: Không xác định được vật phẩm.';
        isValid = false;
    } else if (isNaN(quantityToDiscard) || quantityToDiscard < 1) {
        errorMsg = 'Số lượng phải là số lớn hơn 0.';
        isValid = false;
    } else if (quantityToDiscard > currentMax) {
        errorMsg = `Số lượng không được vượt quá ${currentMax}.`;
        isValid = false;
    }

    // --- Hiển thị lỗi hoặc thực hiện ---
    if (!isValid) {
        discardQuantityError.textContent = errorMsg;
        discardQuantityError.style.display = 'block';
        confirmDiscardBtn.disabled = true; // Disable nút nếu lỗi
    } else {
        discardQuantityError.textContent = '';
        discardQuantityError.style.display = 'none';
        confirmDiscardBtn.disabled = false;

        // Gọi hàm discard với số lượng hợp lệ
        discardPurchasedItem(itemId, quantityToDiscard);
        closeDiscardItemPopup(); // Đóng popup sau khi thực hiện
    }
}

// Thêm listener để bật lại nút Confirm khi người dùng thay đổi input
if (discardQuantityInput) {
    discardQuantityInput.addEventListener('input', () => {
        if (confirmDiscardBtn) confirmDiscardBtn.disabled = false;
        if (discardQuantityError) {
             discardQuantityError.textContent = '';
             discardQuantityError.style.display = 'none';
        }
    });
     // Thêm kiểm tra khi blur (mất focus) để bắt lỗi sớm hơn
     discardQuantityInput.addEventListener('blur', () => {
        const quantityToDiscard = parseInt(discardQuantityInput.value);
        const currentMax = parseInt(discardQuantityInput.max);
        let errorMsg = '';
        if (isNaN(quantityToDiscard) || quantityToDiscard < 1) {
            errorMsg = 'Số lượng phải lớn hơn 0.';
        } else if (quantityToDiscard > currentMax) {
             errorMsg = `Số lượng không được vượt quá ${currentMax}.`;
        }

        if (errorMsg) {
             discardQuantityError.textContent = errorMsg;
             discardQuantityError.style.display = 'block';
             if(confirmDiscardBtn) confirmDiscardBtn.disabled = true;
        } else {
             discardQuantityError.textContent = '';
             discardQuantityError.style.display = 'none';
             if(confirmDiscardBtn) confirmDiscardBtn.disabled = false;
        }
     });
}








        /** Điền vào modal chọn hạt giống dựa trên hạt giống có sẵn trong kho ĐÃ MUA. */
        function populateSeedSelection() {
            console.log("Đang điền modal chọn hạt giống...");
            seedSelectionList.innerHTML = '';
            let availableSeedCount = 0;

            const availableSeedIds = Object.keys(gameState.inventory)
                .filter(itemId => {
                    const item = ITEM_DATA[itemId];
                    return item && item.type === 'seed' && gameState.inventory[itemId] > 0;
                })
                .sort((a, b) => (ITEM_DATA[a]?.price || 0) - (ITEM_DATA[b]?.price || 0));

            availableSeedIds.forEach(seedId => {
                availableSeedCount++;
                const item = ITEM_DATA[seedId];
                const quantity = gameState.inventory[seedId];
                const itemCard = document.createElement('div');
                itemCard.classList.add('item-card');

                 let iconSrc = item.imageFolder ? `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png` : 'Hinhanh/Caychet.png';
                 const imgTagSeed = `<img src="${iconSrc}" alt="${item.name}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
                 const iconHtml = `<span class="item-icon">${imgTagSeed}</span>`;

                itemCard.innerHTML = `
                    ${iconHtml}
                    <div class="item-name">${item.name}</div>
                    <div class="item-quantity">Có sẵn (đã mua): ${quantity}</div>
                    <div class="item-details" style="font-size: 0.7rem;">(Lớn: ${formatTime(item.growthTime * 1000, true)}, Hao: ${(item.fertilityCost*100).toFixed(0)}% đất)</div>
                    <button class="plant-button" data-seed-id="${item.id}">Trồng Hạt Này</button>
                `;
                seedSelectionList.appendChild(itemCard);
            });

            seedSelectionEmptyMessage.style.display = availableSeedCount === 0 ? 'block' : 'none';
            seedSelectionList.style.display = availableSeedCount > 0 ? 'grid' : 'none';
            console.log(`Modal chọn hạt giống đã điền với ${availableSeedCount} loại hạt (từ kho đã mua).`);
        }

        /** Xử lý click vào nút trồng trong modal chọn hạt giống. */
        function handleSeedSelectionClick(event) {
            const plantButton = event.target.closest('.plant-button');
            if (plantButton) {
                const selectedSeedId = plantButton.dataset.seedId;
                if (currentPlantingPlotId !== null && gameState.plots[currentPlantingPlotId]) {
                    plantSeed(currentPlantingPlotId, selectedSeedId);
                    closeModal('seed-selection-modal');
                } else {
                    showMessage("Lỗi: Không thể trồng, vui lòng chọn lại ô đất.", "error");
                    console.error("Lỗi logic: handleSeedSelectionClick không tìm thấy currentPlantingPlotId hợp lệ.");
                    closeModal('seed-selection-modal');
                    currentPlantingPlotId = null;
                }
            }
        }

         /** Điền vào modal chọn phân bón dựa trên phân bón có trong kho ĐÃ MUA. */
         function populateFertilizerSelection() {
            console.log("Đang điền modal chọn phân bón...");
            fertilizerSelectionList.innerHTML = '';
            let availableFertilizerCount = 0;

            // Lấy danh sách ID phân bón hợp lệ từ kho
            const availableFertilizerIds = Object.keys(gameState.inventory)
                 .filter(itemId => {
                    const item = ITEM_DATA[itemId];
                    // Điều kiện mới: là tool VÀ (có fertilityBoost HOẶC là fertilizer_growth HOẶC là fertilizer_protect) VÀ số lượng > 0
                    return item && item.type === 'tool' &&
                           (typeof item.fertilityBoost === 'number' || itemId === 'fertilizer_growth' || itemId === 'fertilizer_protect') &&
                           gameState.inventory[itemId] > 0;
                 })
                 .sort((a, b) => (ITEM_DATA[a]?.price || 0) - (ITEM_DATA[b]?.price || 0)); // Sắp xếp theo giá

             availableFertilizerIds.forEach(fertilizerId => {
                 availableFertilizerCount++;
                 const item = ITEM_DATA[fertilizerId];
                 const quantity = gameState.inventory[fertilizerId];
                 const itemCard = document.createElement('div');
                 itemCard.classList.add('item-card');

                 // Lấy icon
                 let iconSrc = (item.imageFolder && item.imageFile) ? `${item.imageFolder}/${item.imageFile}` : 'Hinhanh/Caychet.png';
                 const imgTagFert = `<img src="${iconSrc}" alt="${item.name}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
                 const iconHtml = `<span class="item-icon">${imgTagFert}</span>`;

                 // --- Hiển thị chi tiết dựa trên loại phân bón (ĐÃ CẬP NHẬT) ---
                 let detailsHtml = `<div class="item-details" style="font-size: 0.75rem;">`;
                 if (fertilizerId === 'fertilizer_growth') {
                    detailsHtml += `<div>⏳ Lớn: -5% TG</div>`;
                    detailsHtml += `<div>❤️ Sức khoẻ: +20%</div>`;
                    detailsHtml += `<div>🚫 Tối đa ${item.usageLimitPerPlant || 3} lần/cây</div>`;
                 } else if (fertilizerId === 'fertilizer_protect') { // <<< THÊM CASE CHO BẢO VỆ >>>
                     detailsHtml += `<div>💩 Phì: +${(item.fertilityBoost * 100).toFixed(0)}%</div>`;
                     detailsHtml += `<div>🛡️ Giảm tỉ lệ sâu</div>`;
                     detailsHtml += `<div>🚫 Tối đa ${item.usageLimitPerPlant || 3} lần/cây</div>`;
                 } else if (typeof item.fertilityBoost === 'number') { // Phân bón tăng phì cũ
                    detailsHtml += `<div>💩 Phì: +${(item.fertilityBoost * 100).toFixed(0)}%</div>`;
                 } else { // Loại tool khác (nếu có)
                     detailsHtml += `<div>${item.description || 'Công cụ'}</div>`;
                 }
                 detailsHtml += `</div>`;
                 // --- Kết Thúc Hiển thị chi tiết ---

                 // Nút Sử dụng
                 itemCard.innerHTML = `
                     ${iconHtml}
                     <div class="item-name">${item.name}</div>
                     <div class="item-quantity">Có sẵn (đã mua): ${quantity}</div>
                     ${detailsHtml}
                     <button class="use-button" data-fertilizer-id="${item.id}">Bón Phân Này</button>
                 `;
                 fertilizerSelectionList.appendChild(itemCard);
             });

             // Hiển thị thông báo trống hoặc danh sách
             fertilizerSelectionEmptyMessage.style.display = availableFertilizerCount === 0 ? 'block' : 'none';
             fertilizerSelectionList.style.display = availableFertilizerCount > 0 ? 'grid' : 'none';
             console.log(`Modal chọn phân bón đã điền với ${availableFertilizerCount} loại (từ kho đã mua).`);
         }


        /** Cập nhật các nút và thông tin trong Modal Hành Động Cây Trồng */
		function updatePlantActionModalButtons(plotId) {
            // --- Kiểm tra đầu vào và lấy dữ liệu cơ bản ---
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                console.warn(`updatePlantActionModalButtons được gọi với plotId không hợp lệ: ${plotId}`);
                if (plantActionModal.style.display === 'block') { closeModal('plant-action-modal'); currentActionPlotId = null; }
                return;
            }
            const plotData = gameState.plots[plotId];
            const seedInfo = plotData.seedId ? ITEM_DATA[plotData.seedId] : null;
            if (!plotData.seedId || !seedInfo) {
                // Nếu không có cây, không nên mở modal này, nhưng để phòng lỗi, ta đóng nó lại.
                console.warn(`Modal hành động cây được mở cho ô ${plotId} không có cây hoặc cây lỗi. Đang đóng.`);
                closeModal('plant-action-modal'); currentActionPlotId = null; return;
            }
            // <<< THÊM: Lấy thông tin Phân Bón Bảo Vệ >>>
            const itemProtect = ITEM_DATA['fertilizer_protect']; // Lấy thông tin cấu hình item

            // --- Lấy thông tin giai đoạn, trạng thái đất và hàng rào ---
            const now = Date.now();
            const stageInfo = getPlantStageInfo(plotData, now);
            const isBarren = plotData.fertility <= 0;
            const isDry = plotData.isDry;
            const fenceData = plotData.fenceData; // Lấy dữ liệu hàng rào của ô đất hiện tại
            const fenceItemInfo = ITEM_DATA.raobaove; // Lấy thông tin cấu hình hàng rào từ ITEM_DATA

            // --- Cập nhật Tiêu đề Modal ---
            plantActionTitle.textContent = `Chăm Sóc ${seedInfo.name} (Ô ${plotId + 1})`;

            // --- Cập nhật Thông tin Hiển thị (bao gồm cả hàng rào và buff bảo vệ) ---
            let barrenPenaltyInfo = '';
            if (isBarren && plotData.barrenHarvestPenaltyFactor > 1.0) barrenPenaltyInfo = ` (Mọc chậm x${plotData.barrenHarvestPenaltyFactor.toFixed(2)})`;
            else if (isBarren) barrenPenaltyInfo = ' (Đất CẰN!)';
            let fertilityInfoStr = isBarren ? `Đất CẰN!` : `Đất: ${Math.round(plotData.fertility)}%`;
            let dryInfoStr = isDry ? ' | 🏜️ Khô!' : '';
            let fenceInfoStr = ''; // Chuỗi thông tin hàng rào
            if (fenceData) { // Kiểm tra xem có dữ liệu hàng rào không
                fenceInfoStr = fenceData.health > 0
                    ? ` | 🚧 Rào: ${Math.round(fenceData.health)}%` // Rào còn tốt
                    : ' | 🚧 Rào Hỏng!'; // Rào đã hỏng
            }
            let infoStr = `HP: ${Math.round(plotData.health)}% | ${fertilityInfoStr}${barrenPenaltyInfo}${dryInfoStr}${fenceInfoStr}`; // Thêm fenceInfoStr
            if (stageInfo && !stageInfo.isMature && !stageInfo.isDead) infoStr += ` | Lớn: ${Math.round(stageInfo.growthProgress * 100)}%`;
            if (plotData.hasPest) infoStr += ` | 🐛 Có sâu!`;
            if (stageInfo.isDead) {
                let deathReasonText = 'Tự nhiên/Khác';
                if (plotData.causeOfDeath === 'pest') deathReasonText = 'Do sâu';
                else if (plotData.causeOfDeath === 'dryness') deathReasonText = 'Do khô hạn';
                else if (plotData.causeOfDeath === 'lightning') deathReasonText = 'Do sét đánh';
                else if (plotData.causeOfDeath === 'tornado') deathReasonText = 'Do gió lốc';
                infoStr = `💀 Cây đã chết (${deathReasonText}) | ${fertilityInfoStr}${dryInfoStr}${fenceInfoStr}`; // Thêm fenceInfoStr
            }

            // --- THÊM THÔNG TIN BUFF BẢO VỆ ---
            if (plotData.hasFertilizerProtectBuff && itemProtect) {
                 const limitProtect = itemProtect.usageLimitPerPlant || 3;
                 // Thêm icon và số lần đã dùng / giới hạn
                 infoStr += ` | 🛡️(${plotData.fertilizerProtectUsageCount}/${limitProtect})`;
            }
            // --- KẾT THÚC THÊM ---

            plantActionInfo.textContent = infoStr; // Gán chuỗi cuối cùng

            // --- Lấy số lượng vật phẩm trong kho ---
            const pesticideCount = gameState.inventory.pesticide || 0;
            let totalFertilizerCount = 0; // Tổng số lượng các loại phân bón hợp lệ
            // let hasFertilityBoostingFertilizer = false; // Không cần cờ này nữa

            for (const itemId in gameState.inventory) {
                 const item = ITEM_DATA[itemId]; const quantity = gameState.inventory[itemId];
                 // Chỉ tính các loại phân bón hợp lệ (tăng phì, tăng trưởng, bảo vệ)
                 if (item && quantity > 0 && item.type === 'tool' &&
                     (typeof item.fertilityBoost === 'number' || itemId === 'fertilizer_growth' || itemId === 'fertilizer_protect'))
                 {
                     totalFertilizerCount += quantity;
                 }
            }
            const fenceCount = gameState.inventory.raobaove || 0; // Lấy số lượng Rào bảo vệ
            const hasFenceItem = fenceCount > 0; // Kiểm tra xem có Rào bảo vệ trong kho không
            const hasPesticide = pesticideCount > 0;
            // const hasAnyFertilizer = totalFertilizerCount > 0; // Dùng totalFertilizerCount > 0 thay thế

            // --- Xóa các nút cũ và tạo lại ---
            plantActionButtonsContainer.innerHTML = '';

            // --- Tạo lại các nút theo thứ tự logic ---

            // 1. Nút Thu hoạch / Bán ngay (nếu cây chín, không sâu, không chết)
            if (stageInfo && stageInfo.isMature && !plotData.hasPest && plotData.health > 0) {
                // Nút Thu Hoạch
                const harvestButton = document.createElement('button');
                harvestButton.id = 'action-harvest-plant';
                harvestButton.classList.add('action-button'); harvestButton.style.backgroundColor = '#4CAF50';
                harvestButton.textContent = `🧺 Thu Hoạch (Vào Kho)`; harvestButton.disabled = false;
                harvestButton.title = `Thu hoạch ${seedInfo.name}`; harvestButton.style.gridColumn = '1 / -1';
                plantActionButtonsContainer.appendChild(harvestButton);

                // Nút Bán Ngay
                const sellNowButton = document.createElement('button');
                sellNowButton.id = 'action-sell-now'; sellNowButton.classList.add('action-button', 'sell-now');
                // Tính giá bán dựa trên chất lượng (máu)
                const qualityTierSell = getQualityTier(plotData.health);
                const valueMultiplierSell = qualityTierSell ? QUALITY_VALUE_MULTIPLIERS[qualityTierSell] : 0;
                const sellValue = Math.round(1 * (seedInfo.harvestYield || 0) * valueMultiplierSell);
                sellNowButton.textContent = `💰 Bán Ngay (${sellValue}💰)`; sellNowButton.disabled = false;
                sellNowButton.title = `Bán trực tiếp ${seedInfo.name} (+${sellValue}💰)`; sellNowButton.style.gridColumn = '1 / -1';
                plantActionButtonsContainer.appendChild(sellNowButton);
            }

            // 2. Nút Trừ Sâu (nếu có sâu, có thuốc, cây sống)
            const treatPestBtnNew = document.createElement('button');
            treatPestBtnNew.id = 'action-treat-pest';
            treatPestBtnNew.classList.add('action-button', 'treat-pest');
            treatPestBtnNew.textContent = `💊 Trừ Sâu (${pesticideCount})`;
            treatPestBtnNew.disabled = !(plotData.hasPest && hasPesticide && plotData.health > 0);
            treatPestBtnNew.title = treatPestBtnNew.disabled ? ((!plotData.hasPest || plotData.health <=0) ? "Cây không có sâu hoặc đã chết" : `Hết Thuốc Trừ Sâu (Có: ${pesticideCount})`) : `Dùng Thuốc Trừ Sâu (Có: ${pesticideCount})`;
            plantActionButtonsContainer.appendChild(treatPestBtnNew);

            // 3. Nút Bón Phân (nếu có phân bón, cây sống) - Bỏ kiểm tra max phì ở đây
            const selectFertilizerBtnNew = document.createElement('button');
            selectFertilizerBtnNew.id = 'action-select-fertilizer';
            selectFertilizerBtnNew.classList.add('action-button', 'select-fertilizer');
            selectFertilizerBtnNew.textContent = `💩 Bón Phân (${totalFertilizerCount})`; // Hiển thị tổng các loại phân bón
            // Disable nếu không có loại phân bón nào HOẶC cây chết
            selectFertilizerBtnNew.disabled = !(totalFertilizerCount > 0 && plotData.health > 0);
            // Cập nhật title để rõ ràng hơn
            if (selectFertilizerBtnNew.disabled) {
                if (totalFertilizerCount <= 0) selectFertilizerBtnNew.title = `Hết Phân Bón (Có: ${totalFertilizerCount})`;
                else selectFertilizerBtnNew.title = "Không bón phân cho cây chết";
            } else {
                selectFertilizerBtnNew.title = `Chọn Phân Bón (Có: ${totalFertilizerCount})`;
            }
            plantActionButtonsContainer.appendChild(selectFertilizerBtnNew);

            // --- 4 & 5. LOGIC NÚT HÀNG RÀO (Giữ nguyên) ---
            if (!fenceData) {
                if (plotData.health > 0 && hasFenceItem) {
                    const addFenceBtn = document.createElement('button');
                    addFenceBtn.id = 'action-add-fence'; addFenceBtn.classList.add('action-button');
                    addFenceBtn.style.backgroundColor = '#009688';
                    addFenceBtn.textContent = `🚧 Thêm Rào (${fenceCount})`;
                    addFenceBtn.title = `Dùng 1 Rào bảo vệ cho ô này (Còn: ${fenceCount})`;
                    addFenceBtn.disabled = false;
                    plantActionButtonsContainer.appendChild(addFenceBtn);
                }
            } else {
                const removeFenceBtn = document.createElement('button');
                removeFenceBtn.id = 'action-remove-fence'; removeFenceBtn.classList.add('action-button');
                let removeCost = 0; let buttonText = "🗑️ Gỡ Rào"; let buttonTitle = "Gỡ bỏ hàng rào bảo vệ khỏi ô này (Miễn phí)";
                let buttonColor = '#7f8c8d'; removeFenceBtn.disabled = false;
                if (fenceData.health <= 0) {
                    removeCost = fenceItemInfo?.removeCost || 5;
                    buttonText = `🗑️ Gỡ Rào Hỏng (${removeCost}💰)`;
                    buttonTitle = gameState.currency < removeCost ? `Không đủ tiền gỡ rào hỏng (Cần ${removeCost}💰)` : `Gỡ bỏ hàng rào đã hỏng (Tốn ${removeCost}💰)`;
                    buttonColor = '#e74c3c'; removeFenceBtn.disabled = gameState.currency < removeCost;
                }
                removeFenceBtn.textContent = buttonText; removeFenceBtn.title = buttonTitle;
                removeFenceBtn.style.backgroundColor = buttonColor; removeFenceBtn.dataset.removeCost = removeCost;
                plantActionButtonsContainer.appendChild(removeFenceBtn);
            }
            // --- KẾT THÚC LOGIC NÚT HÀNG RÀO ---

            // 6. Nút Tưới Nước (nếu cây khô và sống)
            const newWaterButton = document.createElement('button');
            newWaterButton.id = 'modal-content-Tuoinuoc'; // Giữ ID cũ nếu CSS dựa vào nó
            newWaterButton.classList.add('action-button');
            newWaterButton.textContent = '💧 Tưới Nước';
            newWaterButton.disabled = !(isDry && plotData.health > 0);
            newWaterButton.title = (isDry && plotData.health > 0) ? 'Tưới nước cho cây đang bị khô này' : (plotData.health <= 0 ? 'Không thể tưới cây đã chết' : 'Cây không cần tưới nước');
            plantActionButtonsContainer.appendChild(newWaterButton);

            // 7. Nút Xới Đất / Dọn Dẹp (Giữ nguyên logic phức tạp)
            const clearPlantBtnNew = document.createElement('button');
            clearPlantBtnNew.id = 'action-clear-plant';
            clearPlantBtnNew.classList.add('action-button', 'clear-plant');
            clearPlantBtnNew.disabled = false; // Nút này luôn bật để xử lý logic trong handleClearPlantAction
            let clearPlantTitle = "";
            clearPlantBtnNew.textContent = '⛏️ Xới Đất (Bỏ)'; // Mặc định
            clearPlantBtnNew.classList.remove('costly'); // Reset class costly

            if (plotData.health > 0) { // Cây đang sống
                clearPlantTitle = "Bỏ cây trồng này đi (Không thu hoạch được)";
            } else { // Cây đã chết
                if (plotData.causeOfDeath === 'pest') { // Chết do sâu -> Kiểm tra phí
                    const hasEnoughMoney = gameState.currency >= DEAD_PEST_CLEANUP_COST;
                    if (hasEnoughMoney) { // Đủ tiền dọn
                        clearPlantBtnNew.textContent = `⛏️ Dọn Sạch (${DEAD_PEST_CLEANUP_COST}💰)`;
                        clearPlantBtnNew.classList.add('costly');
                        clearPlantTitle = `Dọn ô đất bị sâu phá hoại (Tốn ${DEAD_PEST_CLEANUP_COST}💰)`;
                    } else { // Không đủ tiền -> Hướng dẫn click
                        const clicksRemaining = DEAD_PEST_FREE_CLEANUP_CLICKS - (plotData.pestDeathClickCount || 0);
                        clearPlantBtnNew.textContent = `⛏️ Dọn Sạch (Click ${clicksRemaining} lần)`;
                        clearPlantBtnNew.classList.add('costly'); // Vẫn là costly vì liên quan đến sâu chết
                        clearPlantTitle = `Không đủ tiền (${gameState.currency}/${DEAD_PEST_CLEANUP_COST}💰)! Đóng cửa sổ, click ô đất ${clicksRemaining} lần để dọn miễn phí.`;
                        // Có thể cân nhắc disable nút này luôn khi không đủ tiền?
                        // clearPlantBtnNew.disabled = true; // Tùy chọn: Disable nút nếu không đủ tiền
                    }
                } else { // Chết do nguyên nhân khác -> Miễn phí
                    clearPlantBtnNew.textContent = `⛏️ Dọn Cây Chết`;
                    clearPlantTitle = "Dọn cây đã chết (Miễn phí)";
                }
            }
            clearPlantBtnNew.title = clearPlantTitle;
            plantActionButtonsContainer.appendChild(clearPlantBtnNew);

            // 8. Nút Cửa Hàng
            const shopButton = document.createElement('button');
            shopButton.id = 'action-open-shop';
            shopButton.classList.add('action-button'); shopButton.style.backgroundColor = '#ff9800';
            shopButton.textContent = '🛒 Cửa Hàng'; shopButton.title = 'Mở cửa hàng'; shopButton.disabled = false;
            plantActionButtonsContainer.appendChild(shopButton);

        } // --- Kết thúc hàm updatePlantActionModalButtons ---
	  
	  

         /** Cập nhật modal hành động ô trống */
          function updateEmptyPlotActionModal(plotId) {
             // --- Kiểm tra đầu vào ---
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || gameState.plots[plotId].seedId || isPlotWithRod(plotId)) {
                 console.warn(`updateEmptyPlotActionModal được gọi cho ô ${plotId} không hợp lệ, có cây hoặc có rod.`);
                  if (emptyPlotActionModal.style.display === 'block') {
                      closeModal('empty-plot-action-modal');
                      currentActionPlotId = null;
                  }
                 return;
             }
             const plotData = gameState.plots[plotId];
             const isBarren = plotData.fertility <= 0;
             const fenceData = plotData.fenceData; // Lấy dữ liệu hàng rào
             const fenceItemInfo = ITEM_DATA.raobaove; // Lấy thông tin cấu hình hàng rào

             // --- Cập nhật tiêu đề và thông tin ô đất ---
             emptyPlotActionTitle.textContent = `Ô Đất ${plotId + 1}`;
             let barrenPenaltyInfo = '';
             if (isBarren && plotData.barrenHarvestPenaltyFactor > 1.0) {
                 barrenPenaltyInfo = ` (Trồng cây sẽ mọc chậm x${plotData.barrenHarvestPenaltyFactor.toFixed(2)})`;
             } else if (isBarren) {
                  barrenPenaltyInfo = ' (CẰN KIỆT!)';
             }
             const fertilityText = isBarren ? `CẰN KIỆT 0%` : `${Math.round(plotData.fertility)}%`;
             const dryTextEmpty = plotData.isDry ? ' (Khô!)' : '';
             // Thêm thông tin hàng rào vào info
             let fenceInfoStrModal = '';
             if (fenceData) {
                  fenceInfoStrModal = fenceData.health > 0
                      ? ` | 🚧 Rào: ${Math.round(fenceData.health)}%`
                      : ' | 🚧 Rào Hỏng!';
             }
             emptyPlotActionInfo.textContent = `Độ phì nhiêu: ${fertilityText}${barrenPenaltyInfo}${dryTextEmpty}${fenceInfoStrModal}`; // Thêm fenceInfoStrModal

             // --- Xóa các nút cũ ---
             emptyPlotActionButtonsContainer.innerHTML = '';

             // --- Tính toán số lượng vật phẩm có sẵn ---
             let availableSeedTypesCount = 0;
             let totalFertilizerCount = 0;
             let hasFertilityBoostingFertilizer = false;
             const hasLightningRodItem = (gameState.inventory[LIGHTNING_ROD_ITEM_ID] || 0) > 0;
             const fenceCount = gameState.inventory.raobaove || 0; // Lấy số lượng rào trong kho
             const hasFenceItem = fenceCount > 0; // Kiểm tra có rào trong kho không

             for (const itemId in gameState.inventory) {
                  const item = ITEM_DATA[itemId];
                  const quantity = gameState.inventory[itemId];
                  if (item && quantity > 0) {
                      if (item.type === 'seed') {
                          availableSeedTypesCount++;
                      } else if (item.type === 'tool') {
                           if (itemId === 'fertilizer_growth' || typeof item.fertilityBoost === 'number') {
                              totalFertilizerCount += quantity;
                           }
                           if (typeof item.fertilityBoost === 'number') {
                                hasFertilityBoostingFertilizer = true;
                           }
                      }
                  }
             }
             // -----------------------------------------------------------------

             // === [LOGIC ƯU TIÊN] KIỂM TRA VÀ THÊM NÚT "GỠ RÀO HỎNG" ===
             let brokenFenceButtonAdded = false;
             if (fenceData && fenceData.health <= 0 && fenceItemInfo) {
                 const removeCost = fenceItemInfo.removeCost || 5;
                 const canAfford = gameState.currency >= removeCost;

                 const removeBrokenFenceBtn = document.createElement('button');
                 removeBrokenFenceBtn.classList.add('action-button', 'remove-broken-fence');
                 removeBrokenFenceBtn.dataset.action = 'remove_broken_fence';
                 removeBrokenFenceBtn.dataset.plotId = plotId;
                 removeBrokenFenceBtn.dataset.cost = removeCost;
                 removeBrokenFenceBtn.innerHTML = `🗑️ Gỡ Rào Hỏng (${removeCost}💰)`;
                 removeBrokenFenceBtn.disabled = !canAfford;
                 removeBrokenFenceBtn.title = canAfford
                     ? `Gỡ bỏ hàng rào đã hỏng (Tốn ${removeCost}💰)`
                     : `Không đủ tiền gỡ rào hỏng (Cần ${removeCost}💰)`;

                 emptyPlotActionButtonsContainer.appendChild(removeBrokenFenceBtn);
                 brokenFenceButtonAdded = true;
             }
             // === KẾT THÚC LOGIC KIỂM TRA RÀO HỎNG ===

             // --- Thêm các nút hành động khác (Trồng, Bón, Đặt Rod, Tưới, Thêm/Gỡ Rào...) ---

             // Nút 1: Trồng cây hoặc Mua hạt giống
             if (availableSeedTypesCount > 0) {
                 const plantBtn = document.createElement('button');
                 plantBtn.classList.add('action-button', 'plant'); plantBtn.dataset.action = 'plant'; plantBtn.dataset.plotId = plotId;
                 plantBtn.innerHTML = `🌱 Trồng Cây (Có ${availableSeedTypesCount} loại)`; plantBtn.title = "Chọn hạt giống từ kho để trồng";
                 emptyPlotActionButtonsContainer.appendChild(plantBtn);
             } else {
                  const buySeedBtn = document.createElement('button');
                  buySeedBtn.classList.add('action-button', 'shop'); buySeedBtn.dataset.action = 'shop_seed'; buySeedBtn.dataset.plotId = plotId;
                  buySeedBtn.innerHTML = '🛒 Mua Hạt Giống'; buySeedBtn.title = "Mở cửa hàng mua hạt giống";
                  emptyPlotActionButtonsContainer.appendChild(buySeedBtn);
             }

             // Nút 2: Bón phân
             if (plotData.fertility < BASE_FERTILITY) {
                 const fertilizeBtn = document.createElement('button');
                 fertilizeBtn.classList.add('action-button', 'fertilize'); fertilizeBtn.dataset.action = 'fertilize'; fertilizeBtn.dataset.plotId = plotId;
                 fertilizeBtn.innerHTML = `💩 Bón Phân (Có ${totalFertilizerCount})`;
                 fertilizeBtn.disabled = !hasFertilityBoostingFertilizer; // Chỉ bật nếu có loại phân tăng phì
                 fertilizeBtn.title = hasFertilityBoostingFertilizer ? `Chọn phân bón tăng phì (Tổng: ${totalFertilizerCount})` : `Hết phân bón tăng phì (Tổng: ${totalFertilizerCount})`;
                 emptyPlotActionButtonsContainer.appendChild(fertilizeBtn);
             } else {
                  const infoText = document.createElement('p'); infoText.textContent = "(Đất đã max phì nhiêu)"; infoText.style.cssText = 'text-align: center; font-size: 0.8em; color: #3b7554; margin-top: 5px;';
                  emptyPlotActionButtonsContainer.appendChild(infoText);
             }

             // Nút 3: Đặt Cột Thu Lôi (Chỉ hiển thị nếu có vật phẩm)
             if (hasLightningRodItem) {
                 const placeRodBtn = document.createElement('button');
                 placeRodBtn.classList.add('action-button', 'place-rod'); placeRodBtn.dataset.action = 'place_rod'; placeRodBtn.dataset.plotId = plotId;
                 placeRodBtn.innerHTML = `⚡ Đặt Cột Thu Lôi (${gameState.inventory[LIGHTNING_ROD_ITEM_ID] || 0})`;
                 placeRodBtn.disabled = false;
                 placeRodBtn.title = "Đặt cột thu lôi vào ô này";
                 placeRodBtn.style.backgroundColor = '#607d8b';
                 emptyPlotActionButtonsContainer.appendChild(placeRodBtn);
             }

             // Nút 4: Tưới Nước
             const waterButton = document.createElement('button');
             waterButton.id = 'modal-content-Tuoinuoc'; waterButton.classList.add('action-button');
             waterButton.textContent = '💧 Tưới Nước'; waterButton.disabled = !plotData.isDry;
             waterButton.title = plotData.isDry ? 'Tưới nước ô đất khô này' : 'Ô đất không cần tưới.';
             waterButton.dataset.action = 'water_empty'; waterButton.dataset.plotId = plotId;
             emptyPlotActionButtonsContainer.appendChild(waterButton);

             // === [START] CẬP NHẬT LOGIC HÀNG RÀO ===
             // Nút 5: Thêm Rào (Chỉ hiển thị nếu CHƯA CÓ RÀO và CÓ ITEM trong kho)
             if (!fenceData && hasFenceItem) {
                 const addFenceBtn = document.createElement('button');
                 addFenceBtn.classList.add('action-button');
                 addFenceBtn.style.backgroundColor = '#009688'; // Màu Teal
                 addFenceBtn.dataset.action = 'add_fence_empty';
                 addFenceBtn.dataset.plotId = plotId;
                 addFenceBtn.textContent = `🚧 Thêm Rào (${fenceCount})`;
                 addFenceBtn.title = `Dùng 1 Rào bảo vệ cho ô này (Còn: ${fenceCount})`;
                 addFenceBtn.disabled = false;
                 emptyPlotActionButtonsContainer.appendChild(addFenceBtn);
             }
             // Nút 6: Gỡ Rào Lành Lặn (Chỉ hiển thị nếu CÓ RÀO và KHÔNG BỊ HỎNG)
             else if (fenceData && fenceData.health > 0) { // Điều kiện là có rào và máu > 0
                 const removeHealthyFenceBtn = document.createElement('button');
                 removeHealthyFenceBtn.classList.add('action-button');
                 removeHealthyFenceBtn.style.backgroundColor = '#7f8c8d'; // Màu xám trung tính
                 removeHealthyFenceBtn.dataset.action = 'remove_healthy_fence'; // Action mới để phân biệt
                 removeHealthyFenceBtn.dataset.plotId = plotId;
                 removeHealthyFenceBtn.dataset.cost = 0; // Gỡ rào lành mạnh là miễn phí
                 removeHealthyFenceBtn.textContent = '🗑️ Gỡ Rào (Miễn phí)';
                 removeHealthyFenceBtn.title = 'Gỡ bỏ hàng rào bảo vệ khỏi ô này (Miễn phí)';
                 removeHealthyFenceBtn.disabled = false;
                 emptyPlotActionButtonsContainer.appendChild(removeHealthyFenceBtn);
             }
             // === [END] CẬP NHẬT LOGIC HÀNG RÀO ===

         } // --- Kết thúc hàm updateEmptyPlotActionModal ---


        // --- Các Hàm Hành Động Người Chơi ---
        // ==================================

        /** Xử lý click trong danh sách vật phẩm cửa hàng (ủy quyền). */
        function handleShopItemClick(event) {
        console.log("[V10 Buy Fix handleShopItemClick] Click detected inside shop list. Target:", event.target);
        const target = event.target;

        // Tìm nút buy gần nhất (dùng class chung 'buy-button' rồi kiểm tra data-item-id)
        const buyButton = target.closest('.buy-button[data-item-id]');

        // Nếu không click vào nút buy hoặc nút bị disabled, bỏ qua
        if (!buyButton) {
            console.log("[V10 Buy Fix handleShopItemClick] Click was not on a buy button with data-item-id.");
            return;
        }
        if (buyButton.disabled) {
            console.log("[V10 Buy Fix handleShopItemClick] Clicked a disabled buy button.");
            showMessage("Không thể mua, nút đang bị vô hiệu hóa (thiếu tiền, điều kiện chưa đủ hoặc số lượng không hợp lệ).", "warning");
            return;
        }

        const itemId = buyButton.dataset.itemId;
        console.log(`[V10 Buy Fix handleShopItemClick] Clicked Buy Button for itemId: ${itemId}`);

        // Lấy thông tin item
        const item = ITEM_DATA[itemId];
        if (!item) {
            console.error(`[V10 Buy Fix handleShopItemClick] Invalid item data for itemId: ${itemId}`);
            showMessage("Lỗi: Vật phẩm không tồn tại.", "error");
            return;
        }

        // Tìm thẻ cha .item-card
        const itemCard = buyButton.closest('.item-card');
        if (!itemCard) {
            console.error(`[V10 Buy Fix handleShopItemClick] Could not find parent .item-card for button with itemId: ${itemId}`);
            return;
        }
         console.log(`[V10 Buy Fix handleShopItemClick] Found parent .item-card for ${itemId}.`);

        // Xử lý dựa trên loại nút (Upgrade hay Seed/Tool)
        if (buyButton.classList.contains('buy-upgrade-button')) {
            console.log(`[V10 Buy Fix handleShopItemClick] Identified as UPGRADE button. Calling buyInventoryUpgrade...`);
            buyInventoryUpgrade(itemId); // Hàm xử lý nâng cấp riêng
        }
        else if (buyButton.classList.contains('buy-seed-button')) { // Giả định seed và tool dùng chung class này
            console.log(`[V10 Buy Fix handleShopItemClick] Identified as SEED/TOOL button. Proceeding to get quantity...`);
            // Tìm input số lượng bằng ID duy nhất
            const quantityInput = itemCard.querySelector(`#qty-${itemId}`);
             console.log(`[V10 Buy Fix handleShopItemClick] Found quantity input #qty-${itemId}:`, quantityInput);

            if (!quantityInput) {
                console.error(`[V10 Buy Fix handleShopItemClick] Could not find quantity input #qty-${itemId} for item type ${item.type}.`);
                // Nếu là tool/seed mà không có input là lỗi cấu trúc -> báo lỗi
                showMessage("Lỗi giao diện: Không tìm thấy ô nhập số lượng.", "error");
                return;
            }

            // Lấy và validate số lượng
            let quantity = parseInt(quantityInput.value);
            const maxQuantity = parseInt(quantityInput.max) || 99;
             console.log(`[V10 Buy Fix handleShopItemClick] Raw quantity value: '${quantityInput.value}', Parsed: ${quantity}, Max allowed: ${maxQuantity}`);

            if (isNaN(quantity) || quantity < 1) {
                console.warn(`[V10 Buy Fix handleShopItemClick] Invalid quantity (${quantityInput.value}), defaulting to 1.`);
                quantity = 1;
                quantityInput.value = 1; // Sửa lại trên UI
            } else if (quantity > maxQuantity) {
                console.warn(`[V10 Buy Fix handleShopItemClick] Quantity (${quantity}) exceeds max (${maxQuantity}), setting to max.`);
                quantity = maxQuantity;
                quantityInput.value = maxQuantity; // Sửa lại trên UI
            }

            console.log(`[V10 Buy Fix handleShopItemClick] Calling buyItem with itemId: ${itemId}, quantity: ${quantity}`);
            buyItem(itemId, quantity); // Gọi hàm mua chung

        } else {
            console.warn(`[V10 Buy Fix handleShopItemClick] Buy button for ${itemId} doesn't have a recognized type class (buy-upgrade-button or buy-seed-button).`);
        }
    }

         /** Xử lý thay đổi trường input số lượng hạt giống (ủy quyền) */
        function handleShopQuantityChange(event) {
        const target = event.target;
        // Chỉ xử lý nếu target là input số lượng chúng ta quan tâm
        if (target.classList.contains('seed-quantity-input') && target.id && target.id.startsWith('qty-')) {
            console.log(`[V10 Buy Fix handleShopQuantityChange] Quantity input changed for: ${target.id}`);
            const itemCard = target.closest('.item-card');
            const itemId = target.dataset.itemId; // Lấy itemId từ data attribute của input
            if (itemCard && itemId) {
                 console.log(`[V10 Buy Fix handleShopQuantityChange] Calling updateSeedTotalCost for itemId: ${itemId}`);
                try {
                    updateSeedTotalCost(itemId, itemCard);
                } catch (e) {
                    console.error(`[V10 Buy Fix handleShopQuantityChange] Error calling updateSeedTotalCost:`, e);
                }
            } else {
                 console.warn(`[V10 Buy Fix handleShopQuantityChange] Could not find itemCard or itemId for input:`, target);
            }
        }
    }


         /** Cập nhật tổng chi phí hiển thị và trạng thái nút mua cho một thẻ hạt giống */
         function updateSeedTotalCost(itemId, itemCardElement) {
        // console.log(`[V10 Buy Fix updateSeedTotalCost] Updating cost for itemId: ${itemId}`); // Giảm log ở đây vì gọi nhiều
        const item = ITEM_DATA[itemId];

        // Kiểm tra dữ liệu cơ bản
        if (!item || !itemCardElement) {
            console.error(`[V10 Buy Fix updateSeedTotalCost] Error: Missing item data or itemCardElement for itemId: ${itemId}`);
            return;
        }
        // Chỉ thực hiện cho seed và tool có input số lượng
        if (item.type !== 'seed' && item.type !== 'tool') {
            // console.log(`[V10 Buy Fix updateSeedTotalCost] Skipping cost update for non-seed/tool item: ${itemId}`);
            return;
        }

        // Tìm các phần tử con quan trọng
        const quantityInput = itemCardElement.querySelector(`#qty-${itemId}`);
        const totalCostElement = itemCardElement.querySelector(`#total-${itemId}`);
        const buyButton = itemCardElement.querySelector(`.buy-seed-button[data-item-id="${itemId}"]`); // Dùng class chung cho seed/tool

        // Kiểm tra sự tồn tại của các phần tử
        if (!quantityInput || !totalCostElement || !buyButton) {
            console.error(`[V10 Buy Fix updateSeedTotalCost] Error: Could not find required elements (input, total, button) for itemId: ${itemId} inside card.`);
            // Làm nút bị disabled nếu thiếu thành phần
            const anyButton = itemCardElement.querySelector('.buy-button');
            if(anyButton) anyButton.disabled = true;
            return;
        }

        // Lấy và xử lý số lượng
        let quantity = parseInt(quantityInput.value);
        const rawValue = quantityInput.value;
        const maxQuantity = parseInt(quantityInput.max) || 99;

        // Chỉ tính toán nếu quantity hợp lệ, nếu không thì coi như quantity là 0 hoặc 1 để disable nút
        let validQuantityForCalc = 0; // Mặc định là 0 nếu input không hợp lệ
        let isInputInvalidOrEmpty = true; // Mặc định là không hợp lệ

        if (!isNaN(quantity) && quantity >= 1 && quantity <= maxQuantity) {
             validQuantityForCalc = quantity;
             isInputInvalidOrEmpty = false; // Hợp lệ
        } else if (!isNaN(quantity) && quantity > maxQuantity) {
             validQuantityForCalc = maxQuantity; // Dùng max để tính giá nếu người dùng nhập quá cao
             isInputInvalidOrEmpty = false; // Vẫn coi là hợp lệ về mặt định dạng số
        }
        // Nếu quantity < 1 hoặc NaN, validQuantityForCalc vẫn là 0, isInputInvalidOrEmpty là true

        // Tính toán tổng chi phí (dựa trên số lượng hợp lệ)
        const totalCost = (item.price || 0) * validQuantityForCalc;
        // console.log(`[V10 Buy Fix updateSeedTotalCost] itemId: ${itemId}, validQuantity: ${validQuantityForCalc}, totalCost: ${totalCost}`);

        // Cập nhật hiển thị tổng tiền
        totalCostElement.textContent = `Giá bán: ${totalCost}💰`;

        // Cập nhật trạng thái nút Mua
        const cannotAfford = gameState.currency < totalCost;
        buyButton.disabled = cannotAfford || isInputInvalidOrEmpty; // Disable nếu không đủ tiền HOẶC số lượng nhập không hợp lệ
        // console.log(`[V10 Buy Fix updateSeedTotalCost] itemId: ${itemId}, isInvalid: ${isInputInvalidOrEmpty}, cannotAfford: ${cannotAfford} -> disabled: ${buyButton.disabled}`);
    }


        /** Xử lý click trong khu vực vườn (Ủy quyền sự kiện) */
       function handleGardenClick(event) {
         const clickedPlotElement = event.target.closest('.plot');
         if (!clickedPlotElement) return;
         const plotId = parseInt(clickedPlotElement.dataset.plotId);
         if (isNaN(plotId) || plotId < 0) { console.error("ID ô đất click không hợp lệ:", clickedPlotElement.dataset.plotId); return; }
         const isLocked = clickedPlotElement.classList.contains('locked');

         if (isLocked) {
             handleLockedPlotClick(plotId);
         } else if (isPlotWithRod(plotId)) { // <<< KIỂM TRA NẾU LÀ Ô CÓ ROD
             handleLightningRodClick(plotId); // <<< GỌI HÀM XỬ LÝ RIÊNG CHO ROD
         } else {
              // --- Phần xử lý ô không khóa và không có rod (Giữ nguyên logic cũ) ---
              const plotData = gameState.plots[plotId];
              if (!plotData) { console.error("Không tìm thấy dữ liệu cho ô đất ID:", plotId); return; }
              // Ưu tiên xử lý click dọn cây chết do sâu trước
              if (plotData.seedId && plotData.health <= 0 && plotData.causeOfDeath === 'pest') {
                  handleDeadPlotClick(plotId, clickedPlotElement);
              }
              // Nếu không phải chết do sâu, hoặc trống, hoặc đang sống -> Mở modal
              else if (!plotData.seedId) { // Ô trống (và không có rod)
                  handleEmptyPlotClick(plotId);
              }
              else if (plotData.seedId) { // Có cây (sống hoặc chết tự nhiên/khô/sét/lốc - không phải sâu) (và không có rod)
                   currentActionPlotId = plotId;
                   updatePlantActionModalButtons(plotId); // Cập nhật modal trước khi mở
                   openModal('plant-action-modal');
              } else {
                  console.warn("Trạng thái click ô đất không được xử lý cho ô:", plotId, plotData);
              }
         }
     
     }

        /** Xử lý click vào ô đất trống đã mở khóa -> Mở modal hành động ô trống */
        function handleEmptyPlotClick(plotId) {
             const plot = gameState.plots[plotId];
             if (!plot || plotId >= gameState.maxUnlockedPlots || plot.seedId) { console.warn(`handleEmptyPlotClick được gọi cho ô ${plotId} không trống/bị khóa/không hợp lệ.`); return; }
            currentActionPlotId = plotId;
            updateEmptyPlotActionModal(plotId);
            openModal('empty-plot-action-modal');

             if(plot.fertility <= 0) {
                 let barrenMsg = `Ô ${plotId+1} đất đã CẰN KIỆT (0%)! Cây trồng sẽ mọc RẤT chậm.`;
                 if (plot.barrenHarvestPenaltyFactor > 1.0) {
                     barrenMsg += ` (Lần tới x${plot.barrenHarvestPenaltyFactor.toFixed(2)})`;
                 }
                  barrenMsg += " Hãy bón phân!";
                 setTimeout(() => showMessage(barrenMsg, "error", MESSAGE_DISPLAY_TIME * 1.5), 200);
             } else if(plot.fertility < LOW_FERTILITY_THRESHOLD) {
                 setTimeout(() => showMessage(`Đất ô ${plotId+1} khá cằn (${Math.round(plot.fertility)}%), cân nhắc bón phân!`, "warning", MESSAGE_DISPLAY_TIME * 1.2), 200);
             }
        }

        /** Xử lý click vào nút trong modal hành động ô trống (Ủy quyền sự kiện) */
        function handleEmptyPlotActionClick(event) {
          const actionButton = event.target.closest('.action-button');
          if (!actionButton || actionButton.disabled) return;
          const action = actionButton.dataset.action;
          const plotId = parseInt(actionButton.dataset.plotId);

          if (isNaN(plotId)) {
              console.error("Không lấy được plotId từ nút hành động ô trống.");
              closeModal('empty-plot-action-modal'); currentActionPlotId = null; return;
          }
          currentActionPlotId = plotId; // Lưu plotId đang thao tác

          switch (action) {
              case 'plant':
                 selectPlotForPlanting(plotId); break;
              case 'fertilize':
                 openFertilizerSelectionModal(plotId); closeModal('empty-plot-action-modal'); break;
              case 'shop_seed':
                 switchShopTab('seeds'); openModal('shop-modal'); closeModal('empty-plot-action-modal'); currentActionPlotId = null; break;
              case 'place_rod':
                  placeLightningRod(plotId); closeModal('empty-plot-action-modal'); currentActionPlotId = null; break;
              case 'shop_tool':
                  switchShopTab('tools'); openModal('shop-modal'); closeModal('empty-plot-action-modal'); currentActionPlotId = null; break;
              case 'water_empty':
                 const plotToWater = gameState.plots[plotId];
                 if (plotToWater && !plotToWater.seedId && plotToWater.isDry) {
                     plotToWater.isDry = false; renderGarden(); saveGame();
                     showMessage(`Đã tưới nước cho ô đất trống ${plotId + 1}.`, "success");
                     logAction('water_empty', plotId, `Tưới nước ô đất trống ${plotId + 1}.`, '💧', null);
                     closeModal('empty-plot-action-modal'); currentActionPlotId = null;
                 } else {
                     console.warn(`Nút tưới ô trống click cho ô ${plotId} không khô hoặc không trống.`);
                     showMessage("Ô đất này không cần tưới nước.", "info");
                     updateEmptyPlotActionModal(plotId); // Cập nhật lại modal
                 }
                 break;
              case 'remove_broken_fence':
                 const costStr = actionButton.dataset.cost;
                 const costBroken = parseInt(costStr); // Đổi tên biến để tránh trùng lặp
                 if (isNaN(costBroken) || costBroken < 0) {
                     console.error("Chi phí gỡ rào hỏng không hợp lệ:", costStr);
                     showMessage("Lỗi: Không thể xác định chi phí gỡ rào.", "error");
                 } else {
                     removeFence(plotId, costBroken); // Gọi hàm removeFence với chi phí
                 }
                 closeModal('empty-plot-action-modal');
                 currentActionPlotId = null;
                 break;
              case 'add_fence_empty':
                 addFence(plotId);
                 closeModal('empty-plot-action-modal');
                 currentActionPlotId = null;
                 break;

              // === [START] CASE MỚI CHO NÚT GỠ RÀO LÀNH LẶN ===
              case 'remove_healthy_fence':
                 const costHealthyStr = actionButton.dataset.cost; // Lấy chi phí từ nút (sẽ là 0)
                 let costHealthy = parseInt(costHealthyStr);
                 // Kiểm tra lại chi phí, nếu lỗi thì mặc định là 0
                 if (isNaN(costHealthy) || costHealthy < 0) {
                     console.warn(`Chi phí gỡ rào lành lặn không hợp lệ (${costHealthyStr}), đặt về 0.`);
                     costHealthy = 0;
                 }
                 removeFence(plotId, costHealthy); // Gọi hàm removeFence với chi phí là 0
                 closeModal('empty-plot-action-modal'); // Đóng modal
                 currentActionPlotId = null; // Reset ID
                 break;
              // === [END] CASE MỚI ===

              default:
                 console.warn("Hành động ô trống không xác định:", action);
                 closeModal('empty-plot-action-modal'); currentActionPlotId = null;
          }
     } // --- Kết thúc hàm handleEmptyPlotActionClick ---


        /** Mở modal chọn phân bón cho một ô đất cụ thể */
         function openFertilizerSelectionModal(plotId) {
    // --- Kiểm tra đầu vào cơ bản (giữ nguyên) ---
    if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
        console.warn(`openFertilizerSelectionModal gọi cho ô ${plotId} không hợp lệ.`);
        currentActionPlotId = null;
        return;
    }
    const plot = gameState.plots[plotId];

    // --- Kiểm tra nếu đất đã max phì nhiêu (giữ nguyên) ---
    // Lưu ý: Có thể bỏ qua kiểm tra này nếu Phân Bón Tăng Trưởng không cần kiểm tra max phì
    // Tuy nhiên, giữ lại vẫn ổn vì nó sẽ chặn các loại phân bón tăng phì khác
    if (plot.fertility >= BASE_FERTILITY && !Object.keys(gameState.inventory).some(id => id === 'fertilizer_growth' && gameState.inventory[id] > 0)) {
         showMessage(`Ô đất ${plotId+1} đã có độ phì nhiêu tối đa và bạn không có Phân Bón Tăng Trưởng!`, "info");
         if (plantActionModal.style.display === 'block') updatePlantActionModalButtons(plotId);
         if (emptyPlotActionModal.style.display === 'block') updateEmptyPlotActionModal(plotId);
         currentActionPlotId = null;
         return;
    }


    // --- SỬA LỖI: Kiểm tra xem có bất kỳ loại phân bón nào (tăng phì HOẶC tăng trưởng) ---
    const hasAnyFertilizer = Object.keys(gameState.inventory).some(itemId => {
        const item = ITEM_DATA[itemId];
        // Điều kiện mới: là tool, VÀ (có fertilityBoost HOẶC là fertilizer_growth), VÀ số lượng > 0
        return item && item.type === 'tool' &&
               (typeof item.fertilityBoost === 'number' || itemId === 'fertilizer_growth') && // <<< SỬA LỖI Ở ĐÂY
               gameState.inventory[itemId] > 0;
    });
    // --- KẾT THÚC SỬA LỖI ---

    // --- Xử lý nếu không có phân bón nào (giữ nguyên) ---
    if (!hasAnyFertilizer) {
        showMessage("Bạn không có loại phân bón nào (trong kho đã mua)! Hãy mua thêm ở cửa hàng.", "error");
        if (plantActionModal.style.display === 'block') closeModal('plant-action-modal');
        if (emptyPlotActionModal.style.display === 'block') closeModal('empty-plot-action-modal');
        switchShopTab('tools');
        openModal('shop-modal');
        currentActionPlotId = null;
        return;
    }

    // --- Mở modal chọn phân bón (giữ nguyên) ---
    currentActionPlotId = plotId; // Lưu plotId đang thao tác
    populateFertilizerSelection(); // Điền các loại phân bón có sẵn
    openModal('fertilizer-selection-modal'); // Mở modal lựa chọn
    // Không đóng modal gốc ở đây
}


        /** Xử lý click trong Modal Hành Động Cây Trồng (Ủy quyền sự kiện) */
       function handlePlantActionClick(event) {
    const actionButton = event.target.closest('.action-button');
    // Phải có plotId đã lưu từ trước (currentActionPlotId) và nút phải được enable
    if (!actionButton || currentActionPlotId === null || actionButton.disabled) {
        // console.log("[DEBUG handlePlantActionClick] Ignored click (no button, no plotId, or button disabled)."); // Bỏ comment nếu cần debug chi tiết
        return;
    }

    const plotId = currentActionPlotId; // Lấy plotId đã lưu từ khi mở modal
    const actionId = actionButton.id; // Lấy ID của nút được click

    console.log(`[DEBUG handlePlantActionClick] Action button clicked! PlotId: ${plotId}, ActionId: ${actionId}`);

    const plotData = gameState.plots[plotId];
    // Kiểm tra plotData cơ bản cho hầu hết các hành động
    if (actionId !== 'action-open-shop' && (!plotData || plotId >= gameState.maxUnlockedPlots)) { // Kiểm tra cả plotId hợp lệ
        console.warn(`[handlePlantActionClick] Dữ liệu ô đất ${plotId} cho hành động "${actionId}" không hợp lệ hoặc ô đất không tồn tại.`);
        closeModal('plant-action-modal'); currentActionPlotId = null;
        return;
    }
    // Kiểm tra cây trồng nếu hành động yêu cầu (Trừ Shop, Clear, Water, Add/Remove Fence)
    const actionsRequiringPlant = ['action-harvest-plant', 'action-sell-now', 'action-treat-pest', 'action-select-fertilizer'];
    if (actionsRequiringPlant.includes(actionId) && (!plotData || !plotData.seedId)) { // Thêm kiểm tra plotData tồn tại
        console.warn(`[handlePlantActionClick] Ô đất ${plotId} không có cây trồng hợp lệ cho hành động "${actionId}".`);
        closeModal('plant-action-modal'); currentActionPlotId = null;
        return;
    }

    // Xử lý các hành động
    switch (actionId) {
        case 'action-harvest-plant':
            console.log(`[DEBUG handlePlantActionClick] Harvest button clicked for plotId: ${plotId}. Calling harvestPlant...`); // Log trước khi gọi
            harvestPlant(plotId); // <<< GỌI HÀM THU HOẠCH >>>
            // Đóng modal và reset plotId SAU KHI hàm harvestPlant được gọi (giả định nó không bị lỗi chặn)
            closeModal('plant-action-modal');
            currentActionPlotId = null;
            break; // <<< Đảm bảo có break >>>

        case 'action-sell-now':
            console.log(`[DEBUG handlePlantActionClick] Sell Now button clicked for plotId: ${plotId}. Calling sellPlantDirectly...`);
            sellPlantDirectly(plotId);
            closeModal('plant-action-modal'); currentActionPlotId = null;
            break;

        case 'action-treat-pest':
            console.log(`[DEBUG handlePlantActionClick] Treat Pest button clicked for plotId: ${plotId}. Calling treatPest...`);
            treatPest(plotId);
            // treatPest sẽ tự đóng modal và reset nếu cần mở shop
            // Nếu không mở shop, cần đóng ở đây
            if (plantActionModal.style.display === 'block') { // Chỉ đóng nếu treatPest không đóng nó
                 closeModal('plant-action-modal');
                 currentActionPlotId = null;
            }
            break;

        case 'action-select-fertilizer':
            console.log(`[DEBUG handlePlantActionClick] Select Fertilizer button clicked for plotId: ${plotId}. Opening selection modal...`);
            openFertilizerSelectionModal(plotId); // Hàm này sẽ lưu plotId và mở modal chọn
            closeModal('plant-action-modal'); // Đóng modal hành động hiện tại
            // currentActionPlotId không reset ở đây, sẽ reset sau khi chọn phân bón hoặc đóng modal chọn
            break;

        case 'modal-content-Tuoinuoc':
            console.log(`[DEBUG handlePlantActionClick] Water Plant button clicked for plotId: ${plotId}.`);
            if (plotData && plotData.isDry && plotData.health > 0) {
                plotData.isDry = false;
                renderGarden();
                showMessage(`Đã tưới nước cho ${ITEM_DATA[plotData.seedId]?.name || 'cây'} ở ô ${plotId + 1}!`, "success");
                saveGame();
                logAction('water', plotId, `Đã tưới nước cho ${ITEM_DATA[plotData.seedId]?.name || 'cây'}.`, '💧', plotData.seedId); // Thêm seedId vào log
                closeModal('plant-action-modal'); currentActionPlotId = null;
            } else {
                console.warn(`[handlePlantActionClick] Water button clicked but plot ${plotId} not dry or plant dead.`);
                showMessage("Cây này không cần tưới nước hoặc đã chết.", "info");
                if (plantActionModal.style.display === 'block') updatePlantActionModalButtons(plotId); // Cập nhật lại nút
            }
            break;

        case 'action-clear-plant':
            console.log(`[DEBUG handlePlantActionClick] Clear Plant button clicked for plotId: ${plotId}. Calling handleClearPlantAction...`);
            handleClearPlantAction(plotId); // Hàm này sẽ xử lý logic dọn và đóng modal nếu cần
            break;

        case 'action-open-shop':
            console.log(`[DEBUG handlePlantActionClick] Open Shop button clicked.`);
            switchShopTab('seeds'); // Mặc định mở tab hạt giống
            openModal('shop-modal');
            closeModal('plant-action-modal'); currentActionPlotId = null;
            break;

        case 'action-add-fence':
             console.log(`[DEBUG handlePlantActionClick] Add Fence button clicked for plotId: ${plotId}.`);
             addFence(plotId);
             closeModal('plant-action-modal'); currentActionPlotId = null;
             break;

        case 'action-remove-fence':
             console.log(`[DEBUG handlePlantActionClick] Remove Fence button clicked for plotId: ${plotId}.`);
             const costToRemove = parseInt(actionButton.dataset.removeCost || '0');
             removeFence(plotId, costToRemove);
             closeModal('plant-action-modal'); currentActionPlotId = null;
             break;

        default:
            console.warn("[handlePlantActionClick] Unknown action button clicked:", actionId);
            closeModal('plant-action-modal'); currentActionPlotId = null; // Đóng modal nếu không rõ hành động
    }
}

		function addFence(plotId) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) return;
            const plot = gameState.plots[plotId];
            const fenceItem = ITEM_DATA.raobaove;

            // Kiểm tra điều kiện
           // if (!plot.seedId || plot.health <= 0) {
           //     showMessage("Chỉ có thể thêm rào cho cây đang sống.", "warning"); return;
           // }
            if (plot.fenceData) {
                showMessage("Ô này đã có rào bảo vệ rồi.", "info"); return;
            }
            if (!fenceItem) {
                showMessage("Lỗi: Không tìm thấy dữ liệu vật phẩm Rào bảo vệ.", "error"); return;
            }
            const fenceCount = gameState.inventory.raobaove || 0;
            if (fenceCount <= 0) {
                showMessage("Bạn đã hết Rào bảo vệ trong kho!", "error");
                return;
            }

            // --- Thực hiện thêm rào ---
            gameState.inventory.raobaove--; // Trừ khỏi kho
            plot.fenceData = {
                id: 'raobaove',
                health: fenceItem.health // Đặt máu tối đa ban đầu
            };

            // Cập nhật UI và Lưu game
            renderGarden(); // Vẽ lại vườn để hiện rào
            if (inventoryModal.style.display === 'block') renderInventory(); // Cập nhật số lượng trong kho
            saveGame();

            showMessage(`Đã thêm Rào bảo vệ cho ô ${plotId + 1}!`, "success");
            logAction('add_fence', plotId, `Thêm Rào bảo vệ vào ô ${plotId + 1}.`, '🚧', 'raobaove');
        }
		
		function removeFence(plotId, costToRemove) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) return;
            const plot = gameState.plots[plotId];

            // Kiểm tra điều kiện cơ bản: Phải có hàng rào
            if (!plot.fenceData) {
                showMessage("Ô này không có hàng rào để gỡ.", "warning"); return;
            }
            const isBroken = plot.fenceData.health <= 0;
            const fenceItem = ITEM_DATA.raobaove; // Lấy thông tin cấu hình rào (không bắt buộc nhưng tốt để log)

            // Kiểm tra xem chi phí truyền vào có hợp lệ không
            const actualCost = parseInt(costToRemove);
            if (isNaN(actualCost) || actualCost < 0) {
                 console.error(`Chi phí gỡ rào không hợp lệ: ${costToRemove}`);
                 showMessage("Lỗi: Không thể xác định chi phí gỡ rào.", "error");
                 return;
            }

            // Kiểm tra tiền nếu có chi phí
            if (actualCost > 0 && gameState.currency < actualCost) {
                showMessage(`Không đủ tiền gỡ rào! Cần ${actualCost}💰.`, "error"); return;
            }

            // --- Thực hiện gỡ bỏ ---
            if (actualCost > 0) {
                gameState.currency -= actualCost; // Trừ phí nếu có
            }
            plot.fenceData = null; // Xóa dữ liệu hàng rào

            // Cập nhật UI và Lưu game
            renderUI(); // Cập nhật tiền
            renderGarden(); // Vẽ lại vườn
            saveGame();

            // Hiển thị thông báo thành công
            let successMessage = `Đã gỡ bỏ hàng rào ${isBroken ? 'hỏng ' : ''}ở ô ${plotId + 1}`;
            if (actualCost > 0) {
                 successMessage += ` (-${actualCost}💰).`;
            } else {
                 successMessage += ` (Miễn phí).`;
            }
            showMessage(successMessage, "success");

            // Log hành động
            const logIcon = isBroken ? '🗑️🚧' : '🚧➖'; // Icon khác nhau cho gỡ hỏng và gỡ lành
            let logDetails = `Gỡ bỏ Rào bảo vệ ${isBroken ? 'hỏng ' : ''}ở ô ${plotId + 1}`;
            if (actualCost > 0) logDetails += ` (-${actualCost}💰).`;
            else logDetails += ` (Miễn phí).`;
            logAction('remove_fence', plotId, logDetails, logIcon, 'raobaove');
        }

		

        /** [MỚI] Hành động: Gỡ bỏ hàng rào bị hỏng (tốn phí). */
        function removeBrokenFence(plotId) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) return;
            const plot = gameState.plots[plotId];
            const fenceItem = ITEM_DATA.raobaove;

            // Kiểm tra điều kiện
            if (!plot.fenceData || plot.fenceData.health > 0) {
                showMessage("Hàng rào này không bị hỏng hoặc không tồn tại.", "warning"); return;
            }
            if (!fenceItem) {
                showMessage("Lỗi: Không tìm thấy dữ liệu vật phẩm Rào bảo vệ.", "error"); return;
            }
            const removeCost = fenceItem.removeCost || 5;
            if (gameState.currency < removeCost) {
                showMessage(`Không đủ tiền gỡ rào! Cần ${removeCost}💰.`, "error"); return;
            }

            // --- Thực hiện gỡ bỏ ---
            gameState.currency -= removeCost; // Trừ phí
            plot.fenceData = null; // Xóa dữ liệu hàng rào

            // Cập nhật UI và Lưu game
            renderUI(); // Cập nhật tiền
            renderGarden(); // Vẽ lại vườn
            updatePlantActionModalButtons(plotId); // Cập nhật lại modal nếu còn mở
            saveGame();

            showMessage(`Đã gỡ bỏ hàng rào hỏng ở ô ${plotId + 1} (-${removeCost}💰).`, "success");
            logAction('remove_fence', plotId, `Gỡ bỏ Rào bảo vệ hỏng ở ô ${plotId + 1} (-${removeCost}💰).`, '🗑️🚧', 'raobaove');
        }





        /** Xử lý hành động 'Dọn Cây', bao gồm xác nhận và kiểm tra chi phí hoặc click miễn phí */
         function handleClearPlantAction(plotId) {
            // 1. Kiểm tra đầu vào cơ bản
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                console.error(`handleClearPlantAction: plotId không hợp lệ: ${plotId}`);
                // Đóng modal nếu đang mở và có lỗi
                if (plantActionModal.style.display === 'block') {
                    closeModal('plant-action-modal');
                    currentActionPlotId = null;
                }
                return;
            }
            const plotData = gameState.plots[plotId];

            // 2. Kiểm tra xem có thực sự có cây để dọn không (phòng trường hợp logic lỗi)
            if (!plotData.seedId) {
                console.warn(`handleClearPlantAction được gọi cho ô ${plotId} nhưng không có cây để dọn.`);
                // Có thể đóng modal hoặc cập nhật lại
                closeModal('plant-action-modal');
                currentActionPlotId = null;
                return;
            }

            // 3. Lấy thông tin cần thiết
            const plantName = ITEM_DATA[plotData.seedId]?.name || 'cây'; // Lấy tên cây, fallback 'cây'
            const isDead = plotData.health <= 0;
            const needsCost = isDead && plotData.causeOfDeath === 'pest'; // Chỉ tốn phí khi chết do sâu
            const canPay = gameState.currency >= DEAD_PEST_CLEANUP_COST;
            let confirmMsg = '';

            // 4. Xây dựng thông báo xác nhận
            if (needsCost) { // Trường hợp chết do sâu
                if (canPay) { // Có đủ tiền trả phí
                    confirmMsg = `Dọn ${plantName} chết do sâu ở ô ${plotId + 1} tốn ${DEAD_PEST_CLEANUP_COST}💰. Bạn có chắc?`;
                } else { // Không đủ tiền, hướng dẫn click
                    const clicksRemaining = DEAD_PEST_FREE_CLEANUP_CLICKS - (plotData.pestDeathClickCount || 0);
                    // Sử dụng \n để xuống dòng trong alert/confirm
                    confirmMsg = `Bạn không đủ tiền (${gameState.currency}/${DEAD_PEST_CLEANUP_COST}💰) để dọn ô này!\nHãy đóng cửa sổ này và click trực tiếp vào ô đất ${clicksRemaining} lần để dọn miễn phí.`;
                    // Hiển thị thông báo này bằng showMessage vì confirm() không hiển thị đẹp \n
                    showMessage(confirmMsg, "warning", MESSAGE_DISPLAY_TIME * 2.5); // Kéo dài thời gian hiển thị
                    // Đóng modal hành động để người dùng có thể click trực tiếp vào ô đất
                    closeModal('plant-action-modal');
                    currentActionPlotId = null;
                    return; // Dừng lại, không hiển thị confirm()
                }
            } else if (isDead) { // Chết do nguyên nhân khác (không phải sâu)
                confirmMsg = `Dọn ${plantName} đã chết (tự nhiên/khác) ở ô ${plotId + 1}? (Miễn phí)`;
            } else { // Cây đang sống
                confirmMsg = `Bạn có chắc muốn xới bỏ ${plantName} đang sống ở ô ${plotId + 1} không? Hành động này không thể hoàn tác và sẽ không thu hoạch được gì.`;
            }

            // 5. Hiển thị hộp thoại xác nhận và xử lý kết quả
            // Chỉ hiển thị confirm nếu không phải trường hợp không đủ tiền dọn sâu chết
            if (confirm(confirmMsg)) {
                // Người dùng nhấn OK
                if (needsCost && canPay) { // Trường hợp tốn phí dọn sâu và đủ tiền
                    gameState.currency -= DEAD_PEST_CLEANUP_COST; // Trừ tiền
                    renderUI(); // Cập nhật hiển thị tiền
                    showMessage(`Đã chi ${DEAD_PEST_CLEANUP_COST}💰 để dọn ô đất ${plotId+1} bị sâu phá hoại.`, "info");
                    // --- GỌI HÀM MỚI ---
                    clearPlantOnly(plotId); // Chỉ xóa cây, giữ hàng rào
                    // --------------------
                } else if (!needsCost) { // Trường hợp dọn cây chết tự nhiên hoặc cây đang sống (đã xác nhận)
                    // --- GỌI HÀM MỚI ---
                    clearPlantOnly(plotId); // Chỉ xóa cây, giữ hàng rào
                    // --------------------
                }
                 // Đóng modal sau khi thực hiện hành động thành công (hoặc đã xác nhận)
                 // Không cần đóng lại ở đây vì clearPlantOnly đã làm điều đó
                 // closeModal('plant-action-modal'); // Dòng này có thể bỏ nếu clearPlantOnly luôn đóng
                 // currentActionPlotId = null; // clearPlantOnly cũng đã reset
            } else {
                // Người dùng nhấn Cancel
                console.log(`Người dùng đã hủy hành động dọn cây ô ${plotId + 1}.`);
                // Không cần đóng modal ở đây, để người dùng có thể chọn hành động khác
            }
         } // --- Kết thúc hàm handleClearPlantAction ---

         /** Hành động: Dọn sạch một ô đất, reset trạng thái cây trồng và các thuộc tính liên quan. */
        function clearPlot(plotId) {
             // 1. Kiểm tra đầu vào
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                 console.warn(`Cố gắng dọn ô không hợp lệ/bị khóa ${plotId}.`);
                 return;
             }
             const plot = gameState.plots[plotId];

             // 2. Lưu trữ thông tin *trước* khi reset để log và hiển thị thông báo
             const wasPlanted = !!plot.seedId;
             const originalSeedId = plot.seedId; // Lưu lại ID hạt giống gốc nếu có
             const plantName = wasPlanted ? (ITEM_DATA[originalSeedId]?.name || 'cây') : 'ô đất';
             const wasDead = wasPlanted && plot.health <= 0;
             const causeOfDeath = plot.causeOfDeath; // Lấy nguyên nhân chết *trước khi reset*
             const wasPestDeath = wasDead && causeOfDeath === 'pest';
             // Kiểm tra xem có phải là trường hợp dọn sâu miễn phí không
             const wasFreePestCleanup = wasPestDeath && (plot.pestDeathClickCount || 0) >= DEAD_PEST_FREE_CLEANUP_CLICKS;

             // 3. --- Reset Trạng Thái Ô Đất ---
             plot.seedId = null;               // Xóa thông tin cây trồng
             plot.plantTime = null;            // Xóa thời gian trồng
             plot.hasPest = false;             // Xóa trạng thái sâu bệnh
             plot.health = INITIAL_PLANT_HEALTH; // Phục hồi máu về đầy (cho lần trồng sau)
             plot.causeOfDeath = null;        // Xóa nguyên nhân chết
             plot.pestDeathClickCount = 0;     // Reset bộ đếm click dọn sâu
             plot.barrenHarvestPenaltyFactor = 1.0; // Reset hệ số phạt đất cằn
             plot.isDry = false; // <<< *** Quan trọng: Reset trạng thái khô hạn *** >>>
             // --- Reset Buff khi Dọn ---
             plot.fertilizerGrowthUsageCount = 0; // Reset bộ đếm khi dọn
             plot.fertilizerProtectUsageCount = 0; // Reset bộ đếm khi dọn
             plot.hasFertilizerProtectBuff = false; // Reset buff khi dọn
             // --- Kết Thúc Reset Buff ---
			 plot.fenceData = null; // <<<  Xóa dữ liệu hàng rào khi dọn ô >>>
             // *** LƯU Ý: KHÔNG reset plot.fertility (độ phì nhiêu) ***

             // 4. Cập nhật giao diện và Lưu game (nên làm trước khi hiển thị thông báo/log)
             renderGarden(); // Vẽ lại khu vườn với ô đất đã được dọn
             saveGame();     // Lưu trạng thái game mới

             // 5. <<< CẬP NHẬT LOG ACTION >>>
             let logDetails = '';
             let logIcon = '⛏️'; // Icon mặc định là xới/dọn
             if (wasPlanted) { // Chỉ log chi tiết nếu trước đó có cây
                 if (wasPestDeath) {
                     logIcon = '💀'; // Icon chết
                     logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết do sâu, ${wasFreePestCleanup ? 'miễn phí' : 'tốn phí'}).`;
                 } else if (wasDead && causeOfDeath === 'dryness') { // <<< XỬ LÝ NGUYÊN NHÂN KHÔ HẠN >>>
                     logIcon = '💀'; // Icon chết
                     logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết do khô hạn).`;
                 } else if (wasDead && causeOfDeath === 'lightning') { // <<< THÊM KIỂM TRA SÉT >>>
                     logIcon = '💀⚡'; // Icon chết + sét
                     logDetails = `Đã dọn ${plantName} (chết do sét đánh) ở ô ${plotId + 1}.`;
                 } else if (wasDead && causeOfDeath === 'tornado') { // Thêm case gió lốc
                    logIcon = '💀🌪️';
                    logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết do gió lốc).`;
                 } else if (wasDead) { // Các trường hợp chết khác (tự nhiên/không rõ)
                     logIcon = '💀';
                     logDetails = `Ô ${plotId + 1}: Dọn ${plantName} (chết tự nhiên/không rõ).`;
                 } else { // Cây đang sống bị xới bỏ
                     // Icon vẫn là ⛏️
                     logDetails = `Ô ${plotId + 1}: Xới bỏ ${plantName} (đang sống).`;
                 }
             } else {
                 // Trường hợp hiếm: Dọn một ô đất đã trống sẵn
                 logDetails = `Đã dọn/xới ô đất trống ${plotId + 1}.`;
             }
             // Ghi log hành động với thông tin chi tiết
             logAction('clear', plotId, logDetails, logIcon, originalSeedId);
             // <<< KẾT THÚC LOG ACTION >>>

             // 6. --- Hiển thị Thông báo cho người chơi (tùy chỉnh) ---
             // Không hiển thị lại message nếu là trường hợp trả phí dọn sâu (đã có msg trước đó)
             if (!(wasPestDeath && !wasFreePestCleanup)) {
                 if (wasFreePestCleanup) {
                     // Message cho dọn sâu miễn phí đã hiển thị khi đủ click, không cần thêm ở đây
                 } else if (wasDead && causeOfDeath === 'dryness') { // <<< THÔNG BÁO CHẾT KHÔ >>>
                     showMessage(`Đã dọn ${plantName} chết khô khỏi ô ${plotId + 1}.`, "info");
                 } else if (wasDead && causeOfDeath === 'lightning') { // <<< THÔNG BÁO CHẾT SÉT >>>
                     showMessage(`Đã dọn ${plantName} chết do sét đánh khỏi ô ${plotId + 1}.`, "info");
                 } else if (wasDead && causeOfDeath === 'tornado') { showMessage(`Đã dọn ${plantName} chết do gió lốc khỏi ô ${plotId + 1}.`, "info"); }
                 else if (wasPlanted && !wasDead) { // Xới cây sống
                     showMessage(`Đã xới bỏ ${plantName} đang sống ở ô ${plotId + 1}.`, "warning");
                 } else if (wasDead) { // Dọn cây chết tự nhiên/không rõ
                     showMessage(`Đã dọn ${plantName} chết khỏi ô ${plotId + 1}.`, "info");
                 }
                 // Không cần thông báo đặc biệt khi dọn ô đã trống.
             }

             // 7. Đóng modal hành động nếu nó đang mở cho ô này
             if (plantActionModal.style.display === 'block' && currentActionPlotId === plotId) {
                 closeModal('plant-action-modal');
                 currentActionPlotId = null; // Reset ID đang hành động
             }
         } // --- Kết thúc hàm clearPlot ---

        /** Hành động: Xử lý khi click trực tiếp vào cây chết (kiểm tra phí hoặc click miễn phí) */
         function handleDeadPlotClick(plotId, plotElement) {
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || !gameState.plots[plotId].seedId || gameState.plots[plotId].health > 0) return;
             const plot = gameState.plots[plotId];
             const plotInfoElement = plotElement ? plotElement.querySelector('.plot-info') : null;

             if (plot.causeOfDeath === 'pest') {
                 const hasEnoughMoney = gameState.currency >= DEAD_PEST_CLEANUP_COST;
                 if (hasEnoughMoney) {
                      // Mở modal để xác nhận trả phí
                      currentActionPlotId = plotId;
                      updatePlantActionModalButtons(plotId);
                      openModal('plant-action-modal');
                      // Thông báo phụ trợ
                      setTimeout(() => showMessage(`Cây chết do sâu. Click "Dọn Sạch" trong cửa sổ vừa mở (tốn ${DEAD_PEST_CLEANUP_COST}💰) hoặc click trực tiếp vào ô đất này ${DEAD_PEST_FREE_CLEANUP_CLICKS} lần nếu bạn đổi ý/hết tiền.`, "warning", MESSAGE_DISPLAY_TIME * 1.8), 100);
                 } else {
                     // Tiến hành click miễn phí
                     plot.pestDeathClickCount++;
                     const clicksRemaining = DEAD_PEST_FREE_CLEANUP_CLICKS - plot.pestDeathClickCount;
                     if (clicksRemaining <= 0) {
                         showMessage(`Yeah! Đã click đủ ${DEAD_PEST_FREE_CLEANUP_CLICKS} lần! Dọn ô đất ${plotId+1} miễn phí!`, "success");
                         clearPlot(plotId); // Dọn ngay khi đủ click
                     }
                     else {
                         showMessage(`Còn ${clicksRemaining} lần click nữa để dọn ô ${plotId+1} miễn phí!`, "info");
                          // Cập nhật text trên ô đất ngay lập tức
                          if (plotInfoElement) {
                              plotInfoElement.textContent = `💀 Chết (Sâu)! Click ${clicksRemaining} lần...`;
                              plotInfoElement.classList.add('free-cleanup-progress');
                              plotInfoElement.classList.remove('needs-cleanup-fee');
                          }
                         // Không cần saveGame() mỗi lần click, sẽ save khi dọn xong hoặc auto save
                     }
                 }
             } else { // Chết tự nhiên -> Mở modal để dọn miễn phí
                 currentActionPlotId = plotId;
                 updatePlantActionModalButtons(plotId);
                 openModal('plant-action-modal');
                 setTimeout(() => showMessage(`Cây đã chết tự nhiên. Click "Xới Đất" trong cửa sổ vừa mở để dọn miễn phí.`, "info"), 100);
             }
         }


        /** Hành động: Sử dụng thuốc trừ sâu từ kho ĐÃ MUA. */
        function treatPest(plotId) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                console.warn(`treatPest được gọi cho ô ${plotId} không hợp lệ.`);
                return;
            }
            const plot = gameState.plots[plotId];
            const plantName = plot.seedId ? (ITEM_DATA[plot.seedId]?.name || 'cây') : 'ô đất'; // Lấy tên cây nếu có

            if (!plot.hasPest) {
                showMessage(`Cây ${plantName} này hiện không có sâu.`, "info");
                return;
            }
            if (plot.health <= 0) {
                showMessage(`Cây ${plantName} đã chết, không thể trị sâu!`, "warning");
                return;
            }

            const currentPesticide = gameState.inventory.pesticide || 0;
            if (currentPesticide > 0) {
                // --- Thực hiện trị sâu ---
                gameState.inventory.pesticide--; // Trừ thuốc khỏi kho đã mua
                plot.hasPest = false; // Loại bỏ trạng thái sâu

                // Cập nhật UI và Lưu game
                renderUI(); // Cập nhật tiền (không đổi)
                renderGarden(); // Vẽ lại để bỏ icon sâu và hiệu ứng viền đỏ
                if (inventoryModal.style.display === 'block') renderInventory(); // Cập nhật kho nếu đang mở
                saveGame();

                // Hiển thị thông báo
                showMessage(`Đã dùng ${ITEM_DATA.pesticide.name} cho ${plantName} ở ô ${plotId + 1}.`, "success");

                // <<< THÊM LOG ACTION >>>
                logAction('pest', plotId, `Ô ${plotId + 1}: Dùng ${ITEM_DATA.pesticide.name} cho ${plantName}.`, '💊', 'pesticide'); 
				// <<< KẾT THÚC LOG ACTION >>>

                // Cập nhật lại modal hành động nếu nó đang mở cho ô này
                if (plantActionModal.style.display === 'block' && currentActionPlotId === plotId) {
                    updatePlantActionModalButtons(plotId);
                }

            } else { // Hết thuốc
                showMessage(`Hết ${ITEM_DATA.pesticide.name} (trong kho đã mua) rồi! 😭 Hãy mua thêm ở cửa hàng.`, "error");
                // Đóng modal hành động (nếu mở) và mở cửa hàng
                if (plantActionModal.style.display === 'block') closeModal('plant-action-modal');
                currentActionPlotId = null;
                switchShopTab('tools');
                openModal('shop-modal');
            }
        }

         /** Xử lý chọn phân bón từ modal (Ủy quyền sự kiện) */
      function handleFertilizerSelection(event) {
    const useButton = event.target.closest('.use-button');
    // Phải có plotId đã lưu từ trước và nút phải được enable
    if (!useButton || currentActionPlotId === null || useButton.disabled) return;

    const fertilizerId = useButton.dataset.fertilizerId;
    if (!fertilizerId || !ITEM_DATA[fertilizerId]) {
        console.error("ID phân bón không hợp lệ:", fertilizerId);
        // Vẫn đóng modal nếu có lỗi ID
        closeModal('fertilizer-selection-modal');
        currentActionPlotId = null;
        return;
    }

    const plotIdToFertilize = currentActionPlotId; // Lấy plotId đã lưu

    // Gọi hàm áp dụng phân bón. Hàm này sẽ hiển thị thông báo thành công/thất bại.
    applyFertilizer(plotIdToFertilize, fertilizerId);

    // Luôn đóng modal chọn phân bón sau khi đã cố gắng áp dụng.
    closeModal('fertilizer-selection-modal');

    // Reset ID ô đất đang được thao tác. Lưu ý: applyFertilizer cũng có thể đã reset nếu thành công.
    // Việc reset ở đây đảm bảo nó luôn được reset sau khi modal lựa chọn đóng.
    currentActionPlotId = null;
}


        /** Hành động: Áp dụng phân bón đã chọn vào ô đất mục tiêu. */
          function applyFertilizer(plotId, itemId) {
    if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
        console.warn(`applyFertilizer gọi trên ô ${plotId} không hợp lệ/bị khóa.`);
        return;
    }
    const plot = gameState.plots[plotId];
    const item = ITEM_DATA[itemId];

    if (!item || item.type !== 'tool') { // Chỉ cần là tool
        console.warn(`applyFertilizer gọi với itemId ${itemId} không hợp lệ (không phải tool).`);
        return;
    }

    if ((gameState.inventory[itemId] || 0) <= 0) {
        showMessage(`Bạn không có ${item.name} (trong kho đã mua)!`, "error");
        currentActionPlotId = null; // Reset plotId nếu không có vật phẩm
        return;
    }

    // Kiểm tra điều kiện sử dụng CHUNG: không dùng cho cây chết
    // Ngoại trừ bón cho đất trống để tăng phì (chỉ áp dụng cho loại có fertilityBoost > 0 và không phải fertilizer_protect)
    if (plot.seedId && plot.health <= 0) {
        showMessage(`Không thể bón phân cho cây đã chết!`, "warning");
        return;
    }
    // Ngăn bón phân bảo vệ cho đất trống
    if (itemId === 'fertilizer_protect' && !plot.seedId) {
         showMessage(`${item.name} chỉ dùng được cho cây đang trồng.`, "warning"); return;
    }

    let itemApplied = false;
    let successMessage = '';

    // --- Xử lý Phân Bón Tăng Trưởng ---
    if (itemId === 'fertilizer_growth') {
        if (!plot.seedId) { showMessage(`${item.name} chỉ dùng được cho cây đang trồng.`, "warning"); return; }
        // Logic fertilizer_growth giữ nguyên (kiểm tra giới hạn, tăng máu, giảm thời gian...)
        const currentGrowthUsage = plot.fertilizerGrowthUsageCount || 0;
        const growthLimit = FERTILIZER_GROWTH_MAX_USES; // Hoặc item.usageLimitPerPlant nếu có trong ITEM_DATA
        if (currentGrowthUsage >= growthLimit) {
             showMessage(`Đã dùng ${item.name} tối đa ${growthLimit} lần cho cây này.`, "warning"); return;
        }
        // Thực hiện hiệu ứng...
        gameState.inventory[itemId]--;
        itemApplied = true;
        let messagesGrowth = [];
        const now = Date.now();
        const stageInfoBeforeGrowth = getPlantStageInfo(plot, now);
        if (stageInfoBeforeGrowth && !stageInfoBeforeGrowth.isMature && stageInfoBeforeGrowth.effectiveGrowthTimeSec > 0 && typeof item.growthTimeReductionPercent === 'number') {
             const effectiveGrowthTimeMsGrowth = stageInfoBeforeGrowth.effectiveGrowthTimeSec * 1000;
             const elapsedTimeSoFarGrowth = now - plot.plantTime;
             const remainingTimeMsGrowth = Math.max(0, effectiveGrowthTimeMsGrowth - elapsedTimeSoFarGrowth);
             const timeToSubtractGrowth = remainingTimeMsGrowth * item.growthTimeReductionPercent;
             const oldPlantTimeGrowth = plot.plantTime;
             plot.plantTime = Math.min(now, plot.plantTime + timeToSubtractGrowth);
             const actualReductionMsGrowth = plot.plantTime - oldPlantTimeGrowth;
             if (actualReductionMsGrowth > 0) messagesGrowth.push(`thời gian lớn giảm ~${formatTime(actualReductionMsGrowth, true)}`);
             const stageInfoAfterGrowth = getPlantStageInfo(plot, now);
             if (stageInfoAfterGrowth && stageInfoAfterGrowth.isMature && !stageInfoBeforeGrowth.isMature) messagesGrowth.push("cây đã TRƯỞNG THÀNH!");
        } else if (stageInfoBeforeGrowth && stageInfoBeforeGrowth.isMature) { messagesGrowth.push("không ảnh hưởng thời gian (đã lớn)"); }
        else { messagesGrowth.push("không ảnh hưởng thời gian (lỗi/không áp dụng)"); }
        const healthBoostAmountGrowth = INITIAL_PLANT_HEALTH * (item.healthBoostPercent || 0);
        const oldHealthGrowth = plot.health;
        plot.health = Math.min(INITIAL_PLANT_HEALTH, plot.health + healthBoostAmountGrowth);
        const actualHealthBoostGrowth = plot.health - oldHealthGrowth;
        if (actualHealthBoostGrowth > 0) messagesGrowth.push(`máu tăng +${actualHealthBoostGrowth.toFixed(0)}`);
        plot.fertilizerGrowthUsageCount = currentGrowthUsage + 1;
        messagesGrowth.push(`(đã dùng ${plot.fertilizerGrowthUsageCount}/${growthLimit} lần)`);
        successMessage = `Đã dùng ${item.name}: ${messagesGrowth.join(', ')}.`;
    }
    // --- Xử lý Phân Bón Bảo Vệ ---
    else if (itemId === 'fertilizer_protect') {
        // Điều kiện đã kiểm tra ở đầu (phải có cây sống)
        const currentProtectUsage = plot.fertilizerProtectUsageCount || 0;
        const protectLimit = item.usageLimitPerPlant || 3;
        if (currentProtectUsage >= protectLimit) {
            showMessage(`Đã dùng ${item.name} tối đa ${protectLimit} lần cho cây này.`, "warning"); return;
        }

        // Thực hiện hiệu ứng
        gameState.inventory[itemId]--;
        itemApplied = true;
        let messagesProtect = [];

        // 1. Tăng độ phì nhiêu
        const boostAmountProtect = (item.fertilityBoost || 0) * BASE_FERTILITY;
        if (plot.fertility < BASE_FERTILITY && boostAmountProtect > 0) {
             const oldFertilityProtect = plot.fertility;
             plot.fertility = Math.min(BASE_FERTILITY, plot.fertility + boostAmountProtect);
             const actualBoostProtect = plot.fertility - oldFertilityProtect;
             messagesProtect.push(`độ phì +${actualBoostProtect.toFixed(0)}%`);
             if (oldFertilityProtect <= 0 && plot.fertility > 0) {
                 plot.barrenHarvestPenaltyFactor = 1.0;
                 messagesProtect.push("(đất hết cằn)");
             }
        } else {
            messagesProtect.push("độ phì đã tối đa");
        }

        // 2. Kích hoạt buff bảo vệ & tăng bộ đếm
        plot.hasFertilizerProtectBuff = true;
        plot.fertilizerProtectUsageCount = currentProtectUsage + 1;
        messagesProtect.push(`🛡️ được bảo vệ khỏi sâu`);
        messagesProtect.push(`(đã dùng ${plot.fertilizerProtectUsageCount}/${protectLimit} lần)`);

        successMessage = `Đã dùng ${item.name}: ${messagesProtect.join(', ')}.`;
    }
    // --- Xử lý Phân Bón Tăng Phì Nhiêu CŨ ---
    else if (typeof item.fertilityBoost === 'number') {
        if (plot.fertility >= BASE_FERTILITY) {
            showMessage(`Ô đất ${plotId + 1} đã có độ phì nhiêu tối đa!`, "info");
            return;
        }
        gameState.inventory[itemId]--;
        itemApplied = true;
        const boostAmountOld = (item.fertilityBoost || 0) * BASE_FERTILITY;
        const oldFertilityOld = plot.fertility;
        plot.fertility = Math.min(BASE_FERTILITY, plot.fertility + boostAmountOld);
        const actualBoostOld = plot.fertility - oldFertilityOld;
        let barrenRecoveryMsgOld = '';
        if (oldFertilityOld <= 0 && plot.fertility > 0) {
            plot.barrenHarvestPenaltyFactor = 1.0;
            barrenRecoveryMsgOld = `\nĐất đã phục hồi từ cằn!`;
        }
        successMessage = `Đã bón ${item.name} cho ô ${plotId + 1}. Độ phì tăng +${actualBoostOld.toFixed(0)}% (${Math.round(plot.fertility)}%).${barrenRecoveryMsgOld}`;
    } else {
        showMessage(`Vật phẩm ${item.name} không có hiệu ứng bón phân.`, "warning");
        return;
    }

    // --- Cập nhật chung nếu vật phẩm đã được sử dụng ---
    if (itemApplied) {
	
	
	
		updateDailyQuestProgress('fertilize', 1, itemId); // Cập nhật NV sử dụng phân bón
        renderUI();
        renderGarden();
        if (inventoryModal.style.display === 'block') renderInventory();
        saveGame();
        showMessage(successMessage, "success", successMessage.includes('\n') ? MESSAGE_DISPLAY_TIME + 1000 : MESSAGE_DISPLAY_TIME);

        // Cập nhật Log Action
        let logIcon = '💩'; // Mặc định
        let logDetails = `Ô ${plotId + 1}: Dùng ${item.name}.`;
        if (itemId === 'fertilizer_growth') {
             logIcon = '✨';
             logDetails += ` HP: ${plot.health.toFixed(0)}%, Lần dùng: ${plot.fertilizerGrowthUsageCount}.`;
        } else if (itemId === 'fertilizer_protect') {
            logIcon = '🛡️';
            logDetails += ` Phì -> ${plot.fertility.toFixed(0)}%. Bảo vệ sâu bệnh kích hoạt. Lần dùng: ${plot.fertilizerProtectUsageCount}.`;
        } else if (typeof item.fertilityBoost === 'number') {
             const actualBoostLog = Math.max(0, plot.fertility - (plot.fertility / (1 + item.fertilityBoost))); // Ước tính boost
             logDetails += ` Phì: +${actualBoostLog.toFixed(0)}% -> ${plot.fertility.toFixed(0)}%.`;
        }
        logAction('fertilize', plotId, logDetails, logIcon, itemId);

        // Cập nhật lại modal hành động gốc (nếu có và plotId khớp)
        if (currentActionPlotId === plotId) {
            if (plantActionModal.style.display === 'block') { updatePlantActionModalButtons(plotId); }
            else if (emptyPlotActionModal.style.display === 'block') { updateEmptyPlotActionModal(plotId); }
        }
    }
 }
// --- Kết thúc hàm applyFertilizer ---


         /** Hành động: Thu hoạch cây, thêm vào kho "Đã Thu Hoạch", và cập nhật hệ số phạt nếu cần. */
          function harvestPlant(plotId) {
            console.log(`[HARVEST] Function called for plotId: ${plotId}`); // Log khi hàm bắt đầu

            // --- Bước 1: Kiểm tra đầu vào ---
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || !gameState.plots[plotId].seedId || !gameState.plots[plotId].plantTime) {
                console.warn(`[HARVEST] Invalid input check failed. plotId: ${plotId}, maxPlots: ${gameState.maxUnlockedPlots}, plotData exists: ${!!gameState.plots[plotId]}, seedId: ${gameState.plots[plotId]?.seedId}, plantTime: ${gameState.plots[plotId]?.plantTime}`);
                showMessage("Lỗi: Dữ liệu ô đất không hợp lệ để thu hoạch.", "error");
                return; // Thoát nếu đầu vào không hợp lệ
            }
            const plot = gameState.plots[plotId];
            const seedInfo = ITEM_DATA[plot.seedId];
            if (!seedInfo || seedInfo.type !== 'seed') {
                console.error(`[HARVEST] Invalid seed data for seedId: ${plot.seedId}. Clearing plot.`);
                showMessage("Lỗi: Dữ liệu hạt giống không hợp lệ. Đang dọn ô đất.", "error");
                clearPlot(plotId); // Dọn ô nếu dữ liệu hạt giống lỗi
                return;
            }
            console.log(`[HARVEST] Input and seed data validated for plot ${plotId} (${seedInfo.name}).`);

            // --- Bước 2: Kiểm tra điều kiện thu hoạch (độ chín, sâu bệnh, máu) ---
            const now = Date.now();
            const stageInfo = getPlantStageInfo(plot, now);
            console.log(`[HARVEST] Plot ${plotId} - Stage Info: isMature=${stageInfo?.isMature}, hasPest=${plot.hasPest}, health=${plot.health}, isError=${stageInfo?.isError}`); // Log thông tin giai đoạn

            if (!stageInfo || stageInfo.isError || !stageInfo.isMature || plot.hasPest || plot.health <= 0) {
                let reason = "không rõ";
                if (!stageInfo || stageInfo.isError) reason = "lỗi dữ liệu cây";
                else if (!stageInfo.isMature) reason = "cây chưa chín";
                else if (plot.hasPest) reason = "cây đang bị sâu";
                else if (plot.health <= 0) reason = "cây đã chết";
                console.warn(`[HARVEST] Cannot harvest plot ${plotId}. Reason: ${reason}`);
                showMessage(`Không thể thu hoạch ${seedInfo.name} vì ${reason === "cây chưa chín" ? "cây chưa chín" : reason === "cây đang bị sâu" ? "cây đang bị sâu" : reason === "cây đã chết" ? "cây đã chết" : "lỗi dữ liệu cây"}!`, "warning");
                return; // <<< Thoát nếu không đủ điều kiện
            }
            console.log(`[HARVEST] Plot ${plotId} conditions met (Mature, No Pest, Alive).`);

            // --- Bước 3: Tính toán chất lượng dựa trên máu ---
            const currentHealthPercent = plot.health;
            const qualityTier = getQualityTier(currentHealthPercent);
            if (!qualityTier) {
                console.error(`[HARVEST] Cannot determine quality tier for plot ${plotId} with HP: ${currentHealthPercent}`);
                showMessage("Lỗi: Không thể xác định chất lượng thu hoạch.", "error");
                return;
            }
            const qualityDisplayName = QUALITY_DISPLAY_NAMES[qualityTier] || 'Không rõ';
            console.log(`[HARVEST] Plot ${plotId} - Determined Quality: ${qualityTier} (${qualityDisplayName}) based on HP ${currentHealthPercent.toFixed(1)}%`);

            // --- Bước 4: Kiểm tra giới hạn kho đồ ---
            const currentTotalCount = getTotalInventoryCount(); // Hàm này cần tính cả kho mua và kho thu hoạch
            const harvestQuantity = 1;
            console.log(`[HARVEST] Inventory check: Current Total=${currentTotalCount}, Max Capacity=${gameState.maxInventoryCapacity}, Harvesting=${harvestQuantity}`);
            if (currentTotalCount + harvestQuantity > gameState.maxInventoryCapacity) {
                console.warn(`[HARVEST] Inventory full. Current: ${currentTotalCount}, Max: ${gameState.maxInventoryCapacity}. Cannot harvest plot ${plotId}.`);
                showMessage(`Kho đồ đã đầy (${currentTotalCount}/${gameState.maxInventoryCapacity})! Không thể thu hoạch ${seedInfo.name}.`, "error");
                return; // <<< Thoát nếu kho đầy
            }
            console.log(`[HARVEST] Inventory has space. Proceeding with harvest.`);

            // --- Bước 5: Thực hiện thu hoạch và lưu trữ chất lượng ---
            const harvestedItemId = plot.seedId; // Lưu ID trước khi reset plot
            const harvestedPlantName = seedInfo.name; // Lưu tên trước khi reset plot
            const fertilityBeforeHarvest = plot.fertility; // Lưu độ phì trước khi reset
            let penaltyFactorBeforeHarvest = plot.barrenHarvestPenaltyFactor || 1.0; // Lưu penalty trước khi reset

            // Đảm bảo harvestedItems[id] là object trước khi truy cập
            if (!gameState.harvestedItems[harvestedItemId] || typeof gameState.harvestedItems[harvestedItemId] !== 'object') {
                console.log(`[HARVEST] Initializing quality data for ${harvestedItemId}.`);
                gameState.harvestedItems[harvestedItemId] = {
                    [QUALITY_TIERS.PERFECT]: 0, [QUALITY_TIERS.GOOD]: 0,
                    [QUALITY_TIERS.FAIR]: 0, [QUALITY_TIERS.POOR]: 0
                };
            }
            // Đảm bảo tier tồn tại trước khi tăng
            if (gameState.harvestedItems[harvestedItemId].hasOwnProperty(qualityTier)) {
                 gameState.harvestedItems[harvestedItemId][qualityTier]++;
            } else {
                 console.warn(`[HARVEST] Quality tier ${qualityTier} not found in harvested data for ${harvestedItemId}. Setting to 1.`);
                 gameState.harvestedItems[harvestedItemId][qualityTier] = 1; // Khởi tạo nếu chưa có (phòng lỗi)
            }
            console.log(`[HARVEST] Added 1 unit of ${qualityTier} ${harvestedPlantName} (ID: ${harvestedItemId}) to harvestedItems. New count for tier: ${gameState.harvestedItems[harvestedItemId][qualityTier]}`);

            // --- Bước 6: Reset trạng thái ô đất (Giữ độ phì và hàng rào) ---
            const fenceDataBeforeReset = plot.fenceData; // Lưu lại fenceData nếu có
            plot.seedId = null;
            plot.plantTime = null;
            plot.hasPest = false;
            plot.health = INITIAL_PLANT_HEALTH; // Reset máu cho lần trồng sau
            plot.causeOfDeath = null;
            plot.pestDeathClickCount = 0;
            plot.isDry = false; // Hết khô sau khi thu hoạch
            // --- Reset Buff khi Thu Hoạch ---
            plot.fertilizerGrowthUsageCount = 0; // Reset bộ đếm khi thu hoạch
            plot.fertilizerProtectUsageCount = 0; // Reset bộ đếm khi thu hoạch
            plot.hasFertilizerProtectBuff = false; // Reset buff khi thu hoạch
            // --- Kết Thúc Reset Buff ---
            // plot.fertility KHÔNG đổi
            plot.fenceData = fenceDataBeforeReset; // <<< GÁN LẠI FENCEDATA >>>
            console.log(`[HARVEST] Plot ${plotId} state reset. Fertility: ${plot.fertility.toFixed(1)}%, FenceData kept: ${!!plot.fenceData}`);

            // Xử lý penalty đất cằn
            let penaltyApplied = false;
            if (fertilityBeforeHarvest <= 0) {
                plot.barrenHarvestPenaltyFactor = penaltyFactorBeforeHarvest * BARREN_HARVEST_PENALTY_MULTIPLIER;
                penaltyApplied = true;
                console.log(`[HARVEST] Harvested on barren soil. Barren penalty factor increased to ${plot.barrenHarvestPenaltyFactor.toFixed(2)}`);
            } else {
                // Chỉ reset nếu nó đang khác 1.0
                if (plot.barrenHarvestPenaltyFactor !== 1.0) {
                     plot.barrenHarvestPenaltyFactor = 1.0;
                     console.log(`[HARVEST] Harvested on non-barren soil. Barren penalty factor reset to 1.0`);
                }
            }



			updateDailyQuestProgress('harvest', 1, harvestedItemId); // Cập nhật NV thu hoạch cụ thể và bất kỳ
            // --- Bước 7: Cập nhật UI và Lưu game ---
            console.log("[HARVEST] Updating UI (renderUI, renderGarden, renderInventory if open) and Saving Game...");
            renderUI(); // Cập nhật tiền (không đổi) và số ô
            renderGarden(); // Vẽ lại vườn với ô đất trống (và hàng rào nếu có)
            if (inventoryModal.style.display === 'block') {
                renderInventory(); // Cập nhật kho nếu đang mở
            }
            saveGame(); // Lưu trạng thái mới

            // --- Bước 8: Hiển thị thông báo thu hoạch ---
            let harvestMessage = `Đã thu hoạch ${harvestedPlantName} (Chất lượng: ${qualityDisplayName})! Thêm vào kho.`;
            const fertilityAfterHarvest = plot.fertility; // Lấy độ phì sau khi đã reset plot (vẫn giữ nguyên)
            harvestMessage += `\nĐộ phì còn lại: ${fertilityAfterHarvest.toFixed(0)}%.`;
            if (fertilityAfterHarvest <= 0) {
                harvestMessage += `\nCẢNH BÁO: Đất đã CẰN KIỆT!`;
                if (penaltyApplied) { // Chỉ thêm thông báo penalty nếu nó thực sự được áp dụng
                    harvestMessage += ` Lần trồng tới sẽ mọc chậm x${plot.barrenHarvestPenaltyFactor.toFixed(2)}!`;
                }
            } else if (fertilityAfterHarvest < LOW_FERTILITY_THRESHOLD) {
                harvestMessage += `\nCẢNH BÁO: Đất khá cằn!`;
            }
            showMessage(harvestMessage, "success", harvestMessage.includes('\n') ? MESSAGE_DISPLAY_TIME + 1500 : MESSAGE_DISPLAY_TIME);

            // --- Bước 9: Log Action ---
            logAction('harvest', plotId, `Ô ${plotId + 1}: Thu hoạch ${harvestedPlantName} (Chất lượng: ${qualityDisplayName}).`, '🧺', harvestedItemId);
            console.log(`[HARVEST] Harvest successful for plot ${plotId}. Message shown, action logged.`);

            // Không cần đóng modal hay reset currentActionPlotId ở đây vì nó đã được xử lý trong handlePlantActionClick
        }
         /** Hành động: Bán cây trực tiếp từ ô đất, và cập nhật hệ số phạt nếu cần. */
         function sellPlantDirectly(plotId) {
             // --- Phần kiểm tra đầu vào (giữ nguyên) ---
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || !gameState.plots[plotId].seedId || !gameState.plots[plotId].plantTime) {
                 console.warn(`sellPlantDirectly được gọi cho ô ${plotId} không hợp lệ.`);
                 return;
             }
             const plot = gameState.plots[plotId];
             const seedInfo = ITEM_DATA[plot.seedId];
             if (!seedInfo || seedInfo.type !== 'seed') {
                 console.error(`Dữ liệu hạt giống ${plot.seedId} không hợp lệ khi bán trực tiếp.`);
                 clearPlot(plotId); // Dọn ô nếu dữ liệu cây bị lỗi
                 return;
             }

             const now = Date.now();
             const stageInfo = getPlantStageInfo(plot, now);

             if (!stageInfo || stageInfo.isError || !stageInfo.isMature || plot.hasPest || plot.health <= 0) {
                 let reason = "không rõ";
                 if (!stageInfo || stageInfo.isError) reason = "lỗi dữ liệu cây";
                 else if (!stageInfo.isMature) reason = "cây chưa chín";
                 else if (plot.hasPest) reason = "cây đang bị sâu";
                 else if (plot.health <= 0) reason = "cây đã chết";
                 showMessage(`Không thể bán ngay ${seedInfo.name} vì ${reason}!`, "warning");
                 return;
             }

             // --- Thực hiện bán trực tiếp ---
             const quantitySold = 1;
             // Giá trị bán = Số lượng * (Tỉ lệ máu/100 * Giá trị gốc) - làm tròn
             const healthMultiplier = plot.health / 100;
             const baseYield = seedInfo.harvestYield || 0;
             const earnings = Math.round(quantitySold * healthMultiplier * baseYield);
             const fertilityBeforeSell = plot.fertility;
             let penaltyFactorBeforeSell = plot.barrenHarvestPenaltyFactor || 1.0;
             const fenceDataBeforeResetSell = plot.fenceData; // <<<< Lưu fenceData

             // Cộng tiền
             gameState.currency += earnings;

             // --- [CẬP NHẬT] Reset ô đất giống hệt thu hoạch, GIỮ LẠI fenceData ---
             const soldItemId = plot.seedId;
             plot.seedId = null;
             plot.plantTime = null;
             plot.hasPest = false;
             plot.health = INITIAL_PLANT_HEALTH;
             plot.causeOfDeath = null;
             plot.pestDeathClickCount = 0;
             plot.isDry = false; // <<<< Thêm reset khô hạn
             // --- Reset Buff khi Bán Ngay ---
             plot.fertilizerGrowthUsageCount = 0; // Reset bộ đếm khi bán ngay
             plot.fertilizerProtectUsageCount = 0; // Reset bộ đếm khi bán ngay
             plot.hasFertilizerProtectBuff = false; // Reset buff khi bán ngay
             // --- Kết Thúc Reset Buff ---
             // plot.fertility không đổi
             plot.fenceData = fenceDataBeforeResetSell; // <<<< GÁN LẠI FENCEDATA

             // Xử lý penalty đất cằn
             let penaltyAppliedSell = false;
             if (fertilityBeforeSell <= 0) {
                 plot.barrenHarvestPenaltyFactor = penaltyFactorBeforeSell * BARREN_HARVEST_PENALTY_MULTIPLIER;
                 penaltyAppliedSell = true;
                 console.log(`Ô ${plotId} bán trên đất cằn. Penalty factor tăng lên ${plot.barrenHarvestPenaltyFactor.toFixed(2)}`);
             } else {
                 // Chỉ reset nếu đang khác 1.0
                 if(plot.barrenHarvestPenaltyFactor !== 1.0) {
                     plot.barrenHarvestPenaltyFactor = 1.0; // Reset nếu đất không cằn
                 }
             }
             // --- Kết thúc Reset ---

			 updateDailyQuestProgress('sell_direct', 1, soldItemId, earnings); // Cập nhật NV bán trực tiếp và kiếm tiền
             // Cập nhật UI và Lưu game
             renderUI();
             updateShopButtons();
             renderGarden(); // Vẽ lại vườn, hàng rào (nếu có) sẽ vẫn hiển thị trên ô trống
             saveGame();

             // Hiển thị thông báo bán
             let sellMessage = `Đã bán trực tiếp ${quantitySold} ${seedInfo.name}! +${earnings}💰.`;
             const fertilityAfterSell = plot.fertility;
             sellMessage += `\nĐộ phì nhiêu còn lại: ${fertilityAfterSell.toFixed(0)}%.`;
              if (fertilityAfterSell <= 0) {
                   sellMessage += `\nCẢNH BÁO: Đất đã CẰN KIỆT!`;
                   if(penaltyAppliedSell) {
                        sellMessage += ` Lần trồng tới sẽ mọc chậm x${plot.barrenHarvestPenaltyFactor.toFixed(2)}!`;
                   }
              }
              else if (fertilityAfterSell < LOW_FERTILITY_THRESHOLD) sellMessage += `\nCẢNH BÁO: Đất khá cằn!`;

             showMessage(sellMessage, "success", sellMessage.includes('\n') ? MESSAGE_DISPLAY_TIME + 1500 : MESSAGE_DISPLAY_TIME);

             // Log Action
             logAction('sell_direct', plotId, `Ô ${plotId + 1}: Bán trực tiếp ${quantitySold} ${seedInfo.name} (+${earnings}💰).`, '💰', soldItemId);
        }

        /** Hành động: Bắt đầu quá trình trồng cây cho ô đất trống -> Mở modal chọn hạt giống. */
        function selectPlotForPlanting(plotId) {
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || gameState.plots[plotId].seedId) {
                  showMessage("Ô đất này không hợp lệ hoặc đã có cây trồng rồi.", "error");
                  console.warn(`Cố gắng trồng trên ô ${plotId} không trống/bị khóa/không hợp lệ.`);
                  closeModal('empty-plot-action-modal');
                  currentActionPlotId = null; return;
             }
             if (!checkHasSeeds(true)) {
                 closeModal('empty-plot-action-modal');
                 currentActionPlotId = null; return;
             }
             currentPlantingPlotId = plotId; // Lưu ID ô để trồng
             populateSeedSelection();
             openModal('seed-selection-modal');
             closeModal('empty-plot-action-modal'); // Đóng modal hành động ô trống
             currentActionPlotId = null; // Reset ID hành động
        }

        /** Kiểm tra xem người chơi có hạt giống trong kho ĐÃ MUA không. */
        function checkHasSeeds(showMsgIfEmpty = true) {
            let hasSeeds = Object.keys(gameState.inventory).some(itemId => {
                const item = ITEM_DATA[itemId];
                return item && item.type === 'seed' && gameState.inventory[itemId] > 0;
            });
             if (!hasSeeds && showMsgIfEmpty) {
                 showMessage("Bạn chưa có hạt giống nào (trong kho đã mua)! Hãy ghé qua cửa hàng.", "error");
                 switchShopTab('seeds');
                 openModal('shop-modal');
                 return false;
             }
             return hasSeeds;
        }


         /** Hàm chung để mua vật phẩm, thêm vào kho ĐÃ MUA (gameState.inventory). */
          function buyItem(itemId, quantity) {
        console.log(`[V10 Buy Fix buyItem] Attempting to buy itemId: ${itemId}, quantity: ${quantity}`);
        const item = ITEM_DATA[itemId];

        // 1. Validate Item
        if (!item) {
            showMessage("Lỗi: Vật phẩm không tồn tại!", "error");
            console.error(`[V10 Buy Fix buyItem] ERROR: Item data not found for ID: ${itemId}`);
            return;
        }
         console.log(`[V10 Buy Fix buyItem] Item found: ${item.name}, Price: ${item.price}, Type: ${item.type}`);

        // 2. Validate Quantity (làm lại để chắc chắn)
        let validQuantity = parseInt(quantity);
        if (isNaN(validQuantity) || validQuantity < 1) {
            console.warn(`[V10 Buy Fix buyItem] Invalid quantity (${quantity}) received, defaulting to 1.`);
            validQuantity = 1;
        }
        const maxBuyQuantity = 99; // Hoặc lấy từ cấu hình nếu có
        if (validQuantity > maxBuyQuantity) {
            showMessage(`Chỉ có thể mua tối đa ${maxBuyQuantity} "${item.name}" mỗi lần.`, "warning");
            console.warn(`[V10 Buy Fix buyItem] Quantity (${validQuantity}) clamped to max (${maxBuyQuantity}).`);
            validQuantity = maxBuyQuantity;
            // Cập nhật lại input trong shop nếu đang mở
             if (shopModal.style.display === 'block') {
                const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
                const inputEl = listContainer?.querySelector(`#qty-${itemId}`);
                if(inputEl) inputEl.value = maxBuyQuantity;
             }
        }
         console.log(`[V10 Buy Fix buyItem] Validated quantity: ${validQuantity}`);

        // 3. Calculate Cost and Check Currency
        const totalCost = (item.price || 0) * validQuantity;
         console.log(`[V10 Buy Fix buyItem] Calculated totalCost: ${totalCost}, Current currency: ${gameState.currency}`);
        if (gameState.currency < totalCost) {
            showMessage(`Không đủ tiền! Cần ${totalCost}💰, bạn chỉ có ${gameState.currency}💰.`, "error");
            console.warn(`[V10 Buy Fix buyItem] Insufficient funds.`);
            // Cập nhật lại nút trong shop để đảm bảo nó disabled
            if (shopModal.style.display === 'block') {
                const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
                const cardEl = listContainer?.querySelector(`.item-card[data-item-id="${itemId}"]`);
                if(cardEl) updateSeedTotalCost(itemId, cardEl);
            }
            return;
        }

        // 4. Check Inventory Capacity
        const currentTotalCount = getTotalInventoryCount();
        const quantityToBuy = validQuantity; // Số lượng thực tế sẽ mua
         console.log(`[V10 Buy Fix buyItem] Current inventory count: ${currentTotalCount}, Max capacity: ${gameState.maxInventoryCapacity}, Buying: ${quantityToBuy}`);
        if (currentTotalCount + quantityToBuy > gameState.maxInventoryCapacity) {
            const spaceAvailable = Math.max(0, gameState.maxInventoryCapacity - currentTotalCount); // Đảm bảo không âm
            let buyErrorMsg = `Kho đồ đã đầy (${currentTotalCount}/${gameState.maxInventoryCapacity})!`;
            if (spaceAvailable > 0) {
                buyErrorMsg += ` Chỉ có thể mua thêm tối đa ${spaceAvailable} vật phẩm.`;
                // Cập nhật input về số lượng tối đa có thể mua
                if (shopModal.style.display === 'block') {
                    const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
                    const inputEl = listContainer?.querySelector(`#qty-${itemId}`);
                    if(inputEl && parseInt(inputEl.value) > spaceAvailable) {
                        inputEl.value = spaceAvailable;
                        // Gọi lại update cost để cập nhật giá và nút
                         const cardEl = listContainer?.querySelector(`.item-card[data-item-id="${itemId}"]`);
                         if(cardEl) updateSeedTotalCost(itemId, cardEl);
                         console.log(`[V10 Buy Fix buyItem] Updated shop input to available space: ${spaceAvailable}`);
                    }
                }
            } else {
                buyErrorMsg += ` Không thể mua thêm vật phẩm.`;
                // Disable nút mua nếu đang ở shop
                 if (shopModal.style.display === 'block') {
                    const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
                    const cardEl = listContainer?.querySelector(`.item-card[data-item-id="${itemId}"]`);
                    if(cardEl) {
                        const buyBtn = cardEl.querySelector('.buy-seed-button');
                        if(buyBtn) buyBtn.disabled = true;
                        console.log(`[V10 Buy Fix buyItem] Disabled buy button due to full inventory.`);
                    }
                 }
            }
            showMessage(buyErrorMsg, "error");
            console.warn(`[V10 Buy Fix buyItem] Inventory full. Available space: ${spaceAvailable}`);
            return; // Dừng việc mua hàng
        }

        // --- 5. Perform Purchase ---
         console.log(`[V10 Buy Fix buyItem] Proceeding with purchase... Deducing ${totalCost} currency.`);
        gameState.currency -= totalCost;
        // Đảm bảo inventory là object
        if (typeof gameState.inventory !== 'object' || gameState.inventory === null) {
            gameState.inventory = {};
        }
        gameState.inventory[itemId] = (gameState.inventory[itemId] || 0) + quantityToBuy;
         console.log(`[V10 Buy Fix buyItem] Added ${quantityToBuy} to inventory for ${itemId}. New count: ${gameState.inventory[itemId]}`);
		updateDailyQuestProgress('buy_item', quantityToBuy, itemId); // Cập nhật NV mua hạt giống/phân bón


        // --- 6. Update UI & Save ---
        try {
             console.log(`[V10 Buy Fix buyItem] Updating UI elements...`);
            renderUI(); // Cập nhật tiền
            updateShopButtons(); // Cập nhật các nút trong shop (quan trọng sau khi tiền thay đổi)
            if (inventoryModal.style.display === 'block') renderInventory();
            if (seedSelectionModal.style.display === 'block' && item.type === 'seed') populateSeedSelection();
            if (fertilizerSelectionModal.style.display === 'block' && item.type === 'tool' && typeof item.fertilityBoost === 'number') populateFertilizerSelection();
            // Cập nhật các modal hành động nếu chúng đang mở
            if (currentActionPlotId !== null && gameState.plots[currentActionPlotId]) {
                 if (plantActionModal.style.display === 'block') updatePlantActionModalButtons(currentActionPlotId);
                 if (emptyPlotActionModal.style.display === 'block') updateEmptyPlotActionModal(currentActionPlotId);
                 if (lightningRodActionModal.style.display === 'block' && isPlotWithRod(currentActionPlotId)) updateLightningRodActionModal(currentActionPlotId);
            }
        } catch(e) {
             console.error("[V10 Buy Fix buyItem] Error during UI updates after purchase:", e);
        }

         console.log(`[V10 Buy Fix buyItem] Showing success message and saving game...`);
        showMessage(`Đã mua thành công ${quantityToBuy} ${item.name}! Thêm vào kho "Đã Mua".`, "success");
        saveGame(); // Lưu trạng thái mới
        logAction('buy_item', null, `Mua cửa hàng: ${quantityToBuy} ${item.name} (-${totalCost}💰).`, '🛒', itemId);

        // --- 7. Reset Input in Shop ---
        if (shopModal.style.display === 'block') {
            console.log(`[V10 Buy Fix buyItem] Resetting quantity input in shop for ${itemId}...`);
            const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
            const itemCard = listContainer?.querySelector(`.item-card[data-item-id="${itemId}"]`);
            if (itemCard) {
                const quantityInput = itemCard.querySelector(`#qty-${itemId}`);
                if (quantityInput) quantityInput.value = 1; // Reset về 1
                try {
                    updateSeedTotalCost(itemId, itemCard); // Cập nhật lại giá và nút cho số lượng 1
                     console.log(`[V10 Buy Fix buyItem] Shop input reset and cost updated for ${itemId}.`);
                } catch (e) {
                     console.error(`[V10 Buy Fix buyItem] Error calling updateSeedTotalCost after shop input reset:`, e);
                }
            } else {
                 console.warn(`[V10 Buy Fix buyItem] Could not find item card in shop to reset input for ${itemId}.`);
            }
        }
         console.log(`[V10 Buy Fix buyItem] Purchase process completed for ${itemId}.`);
    }

        /** Trồng một hạt giống cụ thể từ kho ĐÃ MUA. */
                /** Trồng một hạt giống cụ thể từ kho ĐÃ MUA. */
        function plantSeed(plotId, seedId) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || gameState.plots[plotId].seedId) {
                showMessage("Ô đất không hợp lệ hoặc đã có cây.", "error");
                console.warn(`Cố gắng trồng trên ô ${plotId} không trống/bị khóa/không hợp lệ.`);
                // Đóng modal chọn hạt giống nếu đang mở và có lỗi
                if (seedSelectionModal.style.display === 'block') closeModal('seed-selection-modal');
                currentPlantingPlotId = null; // Reset ID đang trồng
                return;
            }
            const plot = gameState.plots[plotId];
            const seed = ITEM_DATA[seedId];

            if (!seed || seed.type !== 'seed' || (gameState.inventory[seedId] || 0) <= 0) {
                 showMessage("Hạt giống không hợp lệ hoặc đã hết (trong kho đã mua).", "error");
                 if (seedSelectionModal.style.display === 'block') populateSeedSelection(); // Cập nhật lại modal nếu còn mở
                 currentPlantingPlotId = null; // Reset ID đang trồng
                 return;
            }

            // --- Thực hiện trồng ---
            gameState.inventory[seedId]--; // Trừ hạt giống khỏi kho đã mua
            plot.seedId = seedId;
            plot.plantTime = Date.now();
            plot.hasPest = false;
            plot.health = INITIAL_PLANT_HEALTH;
            plot.causeOfDeath = null;
            plot.pestDeathClickCount = 0;
            // plot.fertility và plot.barrenHarvestPenaltyFactor giữ nguyên từ trạng thái ô đất trống trước đó

            // --- Reset Buff khi Trồng Mới ---
            plot.fertilizerProtectUsageCount = 0; // Reset bộ đếm khi trồng mới
            plot.hasFertilizerProtectBuff = false; // Reset buff khi trồng mới
            // --- Kết Thúc Reset Buff ---

			

		    updateDailyQuestProgress('plant', 1, seedId); // Cập nhật NV trồng cây cụ thể và bất kỳ
            renderGarden(); // Vẽ lại để hiện cây và thanh máu
            saveGame(); // Lưu trạng thái game
            if (inventoryModal.style.display === 'block') renderInventory(); // Cập nhật kho đồ nếu đang mở

            let plantMessage = `Đã gieo hạt ${seed.name} vào ô ${plotId + 1}!`;
            const currentFertility = plot.fertility;
            const isBarren = currentFertility <= 0;
            const currentPenalty = plot.barrenHarvestPenaltyFactor || 1.0;

            // Cảnh báo nếu trồng trên đất cằn
            if (isBarren && currentPenalty > 1.0) {
                 plantMessage += `\nCẢNH BÁO: Đất CẰN KIỆT! Thời gian mọc sẽ bị NHÂN LÊN x${currentPenalty.toFixed(2)}!`;
            } else if (isBarren) {
                 plantMessage += `\nCẢNH BÁO: Đất CẰN KIỆT! Thời gian mọc có thể bị ảnh hưởng.`;
            } else if (currentFertility < LOW_FERTILITY_THRESHOLD) {
                 plantMessage += ` (Chú ý: Đất khá cằn [${Math.round(currentFertility)}%], cân nhắc bón phân!)`;
            }

            showMessage(plantMessage, isBarren ? "error" : (currentFertility < LOW_FERTILITY_THRESHOLD ? "warning" : "success"), plantMessage.includes('\n') ? MESSAGE_DISPLAY_TIME + 1500 : MESSAGE_DISPLAY_TIME);

            // <<< THÊM LOG ACTION >>>
            logAction('plant', plotId, `Ô ${plotId + 1}: Đã gieo hạt ${seed.name}.`, '🌱', seedId);
            // <<< KẾT THÚC LOG ACTION >>>

            currentPlantingPlotId = null; // Reset ID đang trồng sau khi hoàn tất
        }


        /** Tính toán chi phí để mở khóa ô đất tiếp theo */
        function calculatePlotCost(targetPlotIndex) {
            // Nếu ô đất thuộc nhóm miễn phí ban đầu, không tốn chi phí
            if (targetPlotIndex < INITIAL_PLOT_COUNT) {
                console.warn(`calculatePlotCost được gọi cho ô miễn phí: ${targetPlotIndex}`);
                return 0; // Hoặc giá trị rất lớn để không mua được
            }

            let currentCost = BASE_PLOT_COST_FOR_7TH; // Bắt đầu với giá ô thứ 7

            // Nếu mục tiêu là ô thứ 7, trả về giá gốc
            if (targetPlotIndex === INITIAL_PLOT_COUNT) {
                return Math.floor(currentCost);
            }

            // Lặp từ ô thứ 8 (index INITIAL_PLOT_COUNT + 1) đến ô mục tiêu
            // Biến i đại diện cho *index* của ô đang được tính giá trong vòng lặp
            for (let i = INITIAL_PLOT_COUNT + 1; i <= targetPlotIndex; i++) {
                let multiplier = 1.0; // Hệ số nhân mặc định (không nên xảy ra)

                // Xác định hệ số nhân dựa trên *index* của ô hiện tại (i)
                if (i === INITIAL_PLOT_COUNT + 1) { // Ô thứ 8 (index = 7)
                    multiplier = 1.3;
                } else if (i === INITIAL_PLOT_COUNT + 2) { // Ô thứ 9 (index = 8)
                    multiplier = 1.6;
                } else { // Ô thứ 10 (index = 9) trở đi
                    multiplier = 1.8;
                }

                // Nhân chi phí hiện tại với hệ số và làm tròn xuống *ở mỗi bước*
                // để khớp với ví dụ (300 -> 390 -> 624 -> 1123)
                currentCost = Math.floor(currentCost * multiplier);
            }

            return currentCost; // Trả về chi phí cuối cùng đã tính cho ô targetPlotIndex
        }

        /** Xử lý click vào ô đất bị khóa -> Thử mua ô đất mới */
        function handleLockedPlotClick(plotId) {
        // Chỉ cho phép mua ô tiếp theo liền kề
        if (plotId !== gameState.maxUnlockedPlots) {
            showMessage(`Mở khóa ô ${gameState.maxUnlockedPlots + 1} trước!`, "warning");
            return;
        }
        const cost = calculatePlotCost(plotId);
        const hasEnoughMoney = gameState.currency >= cost;

        // Cập nhật nội dung và trạng thái popup
        lockedPlotMessage.innerHTML = `Mở khóa ô đất số ${plotId + 1} với giá <strong>${cost}💰</strong>? <br>(Bạn đang có: ${gameState.currency}💰)`; // Dùng innerHTML để nhận thẻ strong
        confirmBuyPlotBtn.disabled = !hasEnoughMoney;
        confirmBuyPlotBtn.title = hasEnoughMoney ? `Chi ${cost}💰 để mở khóa` : `Không đủ tiền (Cần ${cost}💰)`;

        // Lưu thông tin cần thiết vào nút Mua để xử lý sau
        confirmBuyPlotBtn.dataset.plotId = plotId;
        confirmBuyPlotBtn.dataset.cost = cost;

        // Hiển thị popup
        openLockedPlotPopup(); // Sử dụng hàm trợ giúp mới (sẽ định nghĩa ở dưới)
    }

        /** Xử lý click vào nút Bán hoặc input số lượng trong tab Đã Thu Hoạch */
        function handleSellHarvestedClick(event) {
    const sellButton = event.target.closest('.sell-selected-button');
    const sellAllButton = event.target.closest('.sell-all-button');
    const quantityInput = event.target;

    if (sellButton) { // Xử lý nút "Bán" (số lượng đã chọn)
        const itemCard = sellButton.closest('.item-card');
        if (!itemCard) return;
        const itemId = itemCard.dataset.itemId;
        const inputElement = itemCard.querySelector(`#sell-qty-${itemId}`);
        if (!inputElement || !itemId) return;

        // Kiểm tra dữ liệu chất lượng tồn tại trước khi lấy max
        const qualityDataForMax = gameState.harvestedItems[itemId];
        if (!qualityDataForMax || typeof qualityDataForMax !== 'object') {
            console.warn(`handleSellHarvestedClick (sellButton): Missing or invalid quality data for ${itemId}`);
            // Có thể render lại inventory để xóa item lỗi
            if (inventoryModal.style.display === 'block') renderInventory();
            return;
        }
        // Tính lại max dựa trên qualityData hiện tại
        const currentMax = Object.values(qualityDataForMax).reduce((sum, count) => sum + (count || 0), 0);
        inputElement.max = currentMax; // Cập nhật max attribute trên input

        let quantityToSell = parseInt(inputElement.value);

        if (isNaN(quantityToSell) || quantityToSell < 1) {
            showMessage("Số lượng bán không hợp lệ.", "warning");
            inputElement.value = 1;
            return;
        }
        // Kiểm tra lại với max vừa cập nhật
        if (quantityToSell > currentMax) {
            showMessage(`Bạn chỉ có ${currentMax} ${ITEM_DATA[itemId]?.name || 'vật phẩm'} để bán.`, "warning");
            inputElement.value = currentMax;
            quantityToSell = currentMax;
        }
        // Gọi hàm bán với số lượng đã được kiểm tra
        sellHarvestedItem(itemId, quantityToSell);

    } else if (sellAllButton) { // [ĐÃ SỬA LỖI] Xử lý nút "Bán Hết" -> Mở xác nhận
        const itemCard = sellAllButton.closest('.item-card');
        if (!itemCard) return;
        const itemId = itemCard.dataset.itemId;
        const item = ITEM_DATA[itemId];
        // Thêm kiểm tra item hợp lệ và là hạt giống
        if (!item || !itemId || item.type !== 'seed') {
            console.error(`Sell All Error: Invalid item, itemId, or not a seed: ${itemId}`);
            return;
        }

        const qualityData = gameState.harvestedItems[itemId]; // Lấy object chất lượng

        // --- [SỬA LỖI] ---
        // Kiểm tra xem qualityData có tồn tại và là object không
        if (!qualityData || typeof qualityData !== 'object') {
            showMessage(`Không tìm thấy dữ liệu chất lượng cho ${item.name} để bán hết.`, "warning");
            // Dọn dẹp dữ liệu lỗi nếu có
            if (gameState.harvestedItems[itemId]) delete gameState.harvestedItems[itemId];
            if (inventoryModal.style.display === 'block') renderInventory(); // Render lại để cập nhật UI
            return;
        }

        // 1. Tính lại TỔNG SỐ LƯỢNG chính xác từ object chất lượng
        let totalQuantityToSellAll = 0;
        for (const tier in qualityData) {
            // Đảm bảo chỉ duyệt qua các tier hợp lệ đã định nghĩa
            if (QUALITY_TIERS[tier.toUpperCase()]) {
                totalQuantityToSellAll += (qualityData[tier] || 0);
            }
        }

        // 2. Tính lại TỔNG GIÁ TRỊ BÁN chính xác
        let correctTotalEarnings = 0;
        const baseValue = item.harvestYield || 0;
        for (const tier in qualityData) {
             // Đảm bảo chỉ duyệt qua các tier hợp lệ đã định nghĩa
            if (QUALITY_TIERS[tier.toUpperCase()]) {
                const count = qualityData[tier] || 0;
                if (count > 0) {
                    const multiplier = QUALITY_VALUE_MULTIPLIERS[tier] || 0; // Lấy hệ số nhân
                    // Giá trị của tier = số lượng * (giá gốc * hệ số) - Làm tròn ở đây
                    correctTotalEarnings += count * Math.round(baseValue * multiplier);
                }
            }
        }
        // --- [KẾT THÚC SỬA LỖI] ---

        // Kiểm tra lại tổng số lượng sau khi tính toán
        if (totalQuantityToSellAll <= 0) {
            showMessage(`Không có ${item.name} để bán hết.`, "warning");
            // Dọn dẹp nếu total là 0 nhưng entry vẫn còn
            if (gameState.harvestedItems[itemId]) delete gameState.harvestedItems[itemId];
            if (inventoryModal.style.display === 'block') renderInventory();
            return;
        }

        const itemName = item.name;

        // Mở hộp thoại xác nhận với các giá trị ĐÃ TÍNH TOÁN LẠI
        openConfirmSellAllModal(itemId, itemName, totalQuantityToSellAll, correctTotalEarnings);

    } else if (quantityInput && quantityInput.classList.contains('sell-quantity-input')) {
        // Xử lý khi người dùng thay đổi input (logic cũ giữ nguyên, nhưng kiểm tra max)
        const itemCard = quantityInput.closest('.item-card');
        const itemId = itemCard?.dataset.itemId;
        if (!itemId) return; // Cần itemId để lấy dữ liệu chất lượng

        const qualityDataForMaxUpdate = gameState.harvestedItems[itemId];
        if (!qualityDataForMaxUpdate || typeof qualityDataForMaxUpdate !== 'object') {
             console.warn(`handleSellHarvestedClick (input change): Missing or invalid quality data for ${itemId}`);
             return;
        }
        // Tính lại max dựa trên qualityData hiện tại
        const currentMaxUpdate = Object.values(qualityDataForMaxUpdate).reduce((sum, count) => sum + (count || 0), 0);
        quantityInput.max = currentMaxUpdate; // Cập nhật max attribute

        let currentValue = parseInt(quantityInput.value);
        const rawValue = quantityInput.value;

        if (rawValue === '' || isNaN(currentValue) || currentValue < 1) {
            // Không đặt lại value = 1 ngay, chỉ cảnh báo nếu cần
            // quantityInput.value = 1;
        }
        else if (currentValue > currentMaxUpdate) {
            quantityInput.value = currentMaxUpdate; // Đặt lại giá trị nếu vượt quá max
            showMessage(`Bạn chỉ có ${currentMaxUpdate} để bán.`, "warning");
        }
    }
}

        /** Bán số lượng cụ thể vật phẩm từ kho Đã Thu Hoạch */
         function sellHarvestedItem(itemId, quantityToSell) {
    const item = ITEM_DATA[itemId];
    const qualityData = gameState.harvestedItems[itemId];

    // --- Kiểm tra cơ bản ---
    if (!item || item.type !== 'seed') {
        showMessage("Lỗi: Không thể bán vật phẩm không hợp lệ.", "error"); return;
    }
    if (!qualityData) {
        showMessage(`Bạn không có ${item.name} để bán.`, "error");
        // Dọn dẹp nếu qualityData không tồn tại nhưng key có trong harvestedItems
        if (gameState.harvestedItems[itemId]) delete gameState.harvestedItems[itemId];
        if (inventoryModal.style.display === 'block') renderInventory();
        return;
    }

    // Tính tổng số lượng hiện có
    const currentTotalQuantity = (qualityData[QUALITY_TIERS.PERFECT] || 0) +
                                 (qualityData[QUALITY_TIERS.GOOD] || 0) +
                                 (qualityData[QUALITY_TIERS.FAIR] || 0) +
                                 (qualityData[QUALITY_TIERS.POOR] || 0);

    if (currentTotalQuantity <= 0) {
        showMessage(`Bạn không còn ${item.name} để bán.`, "error");
        delete gameState.harvestedItems[itemId]; // Dọn dẹp nếu cần
        if (inventoryModal.style.display === 'block') renderInventory();
        return;
    }

    // --- Validate số lượng bán ---
    let actualSellQuantity = parseInt(quantityToSell);
    if (isNaN(actualSellQuantity) || actualSellQuantity <= 0) {
        showMessage("Số lượng bán không hợp lệ.", "error");
        // Reset input nếu đang mở kho
        if (inventoryModal.style.display === 'block') {
            const inputElement = inventoryHarvestedList.querySelector(`#sell-qty-${itemId}`);
            if(inputElement) inputElement.value = 1;
        }
        return;
    }
    if (actualSellQuantity > currentTotalQuantity) {
        showMessage(`Số lượng bán (${actualSellQuantity}) vượt quá số lượng bạn có (${currentTotalQuantity}).`, "error");
        actualSellQuantity = currentTotalQuantity; // Tự động giảm về tối đa
        // Cập nhật input nếu đang mở kho
        if (inventoryModal.style.display === 'block') {
             const inputElement = inventoryHarvestedList.querySelector(`#sell-qty-${itemId}`);
             if(inputElement) inputElement.value = currentTotalQuantity;
        }
    }

    // --- Thực hiện bán, ưu tiên chất lượng thấp ---
    let remainingToSell = actualSellQuantity;
    let totalEarnings = 0;
    const tierOrderToSell = [QUALITY_TIERS.POOR, QUALITY_TIERS.FAIR, QUALITY_TIERS.GOOD, QUALITY_TIERS.PERFECT]; // Thứ tự ưu tiên bán
    const baseValue = item.harvestYield || 0;
    let soldCounts = { poor: 0, fair: 0, good: 0, perfect: 0 }; // Để log chi tiết

    for (const tier of tierOrderToSell) {
        if (remainingToSell <= 0) break; // Đã bán đủ số lượng

        const availableInTier = qualityData[tier] || 0;
        if (availableInTier > 0) {
            const sellFromThisTier = Math.min(remainingToSell, availableInTier);
            const valueMultiplier = QUALITY_VALUE_MULTIPLIERS[tier] || 0;
            const earningsFromTier = sellFromThisTier * Math.round(baseValue * valueMultiplier);

            totalEarnings += earningsFromTier;
            qualityData[tier] -= sellFromThisTier; // Giảm số lượng trong bậc này
            remainingToSell -= sellFromThisTier;
            soldCounts[tier] += sellFromThisTier; // Ghi lại số lượng đã bán từ bậc này

            // console.log(`Bán ${sellFromThisTier} x ${item.name} (Chất lượng: ${tier}) với giá ${earningsFromTier}💰`);
        }
    }

    // --- Cập nhật trạng thái game ---
    gameState.currency += totalEarnings;

    // Kiểm tra xem có cần xóa item khỏi kho không (nếu tất cả chất lượng = 0)
    const newTotalQuantity = (qualityData[QUALITY_TIERS.PERFECT] || 0) +
                             (qualityData[QUALITY_TIERS.GOOD] || 0) +
                             (qualityData[QUALITY_TIERS.FAIR] || 0) +
                             (qualityData[QUALITY_TIERS.POOR] || 0);
    if (newTotalQuantity <= 0) {
        delete gameState.harvestedItems[itemId];
        console.log(`Đã bán hết ${item.name} (ID: ${itemId}).`);
    }
	    // Lưu ý: actualSellQuantity là tổng số bán, cần điều chỉnh nếu muốn chính xác hơn
    updateDailyQuestProgress('sell_harvested', actualSellQuantity, itemId, totalEarnings); // Cập nhật NV bán từ kho và kiếm tiền
    // Cập nhật UI và Lưu game
    renderUI();
    updateShopButtons();
    renderInventory(); // Quan trọng: Cập nhật lại kho đồ
    saveGame();

    // Hiển thị thông báo
    let soldSummary = [];
    if(soldCounts.perfect > 0) soldSummary.push(`${soldCounts.perfect} Hoàn hảo`);
    if(soldCounts.good > 0) soldSummary.push(`${soldCounts.good} Tốt`);
    if(soldCounts.fair > 0) soldSummary.push(`${soldCounts.fair} Thường`);
    if(soldCounts.poor > 0) soldSummary.push(`${soldCounts.poor} Kém`);
    const summaryText = soldSummary.length > 0 ? ` (${soldSummary.join(', ')})` : '';

    showMessage(`Đã bán ${actualSellQuantity} ${item.name}${summaryText}! +${totalEarnings}💰`, "success");

    // Log Action
    logAction('sell_harvested', null, `Bán từ kho: ${actualSellQuantity} ${item.name}${summaryText} (+${totalEarnings}💰).`, '💰', itemId);
}


        // --- Các Hàm Tiện Ích & Trợ Giúp ---
		
		
		/** Hàm cập nhật tiến trình nhiệm vụ hằng ngày */
     function updateDailyQuestProgress(actionType, quantity = 1, itemId = null, earnedAmount = 0) {
        if (!gameState.dailyQuests || gameState.dailyQuests.length === 0) return; // Không có nhiệm vụ để cập nhật

        let questUpdated = false; // Cờ theo dõi xem có nhiệm vụ nào được cập nhật không

        gameState.dailyQuests.forEach((quest, index) => {
            // Bỏ qua nếu nhiệm vụ đã hoàn thành hoặc đã nhận thưởng
            if (quest.isCompleted || quest.isClaimed) return;

            let progressMade = false; // Cờ theo dõi xem quest *này* có tiến triển không

            switch (quest.type) {
                case QUEST_TYPES.PLANT_SPECIFIC:
                    if (actionType === 'plant' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.PLANT_ANY:
                    if (actionType === 'plant') {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.HARVEST_SPECIFIC:
                    if (actionType === 'harvest' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.HARVEST_ANY:
                     if (actionType === 'harvest') {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.SELL_DIRECT_SPECIFIC:
                     if (actionType === 'sell_direct' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.SELL_HARVESTED_SPECIFIC:
                    // Giả định 'quantity' là số lượng của 'itemId' được bán từ kho
                    if (actionType === 'sell_harvested' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.USE_FERTILIZER_TYPE:
                     if (actionType === 'fertilize' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.BUY_FERTILIZER:
                     // Kiểm tra xem có phải là phân bón không
                     if (actionType === 'buy_item' && ITEM_DATA[itemId]?.type === 'tool' && (typeof ITEM_DATA[itemId].fertilityBoost === 'number' || itemId === 'fertilizer_growth' || itemId === 'fertilizer_protect')) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.BUY_SEED:
                     if (actionType === 'buy_item' && ITEM_DATA[itemId]?.type === 'seed') {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.EARN_CURRENCY:
                     if ((actionType === 'sell_direct' || actionType === 'sell_harvested') && earnedAmount > 0) {
                        quest.currentProgress = Math.min(quest.targetQuantity, quest.currentProgress + earnedAmount);
                        progressMade = true;
                     }
                    break;
            }

            // Nếu có tiến triển cho nhiệm vụ này
            if (progressMade) {
                quest.currentProgress = Math.min(quest.currentProgress, quest.targetQuantity); // Đảm bảo không vượt quá mục tiêu

                // Kiểm tra xem nhiệm vụ đã hoàn thành chưa
                if (quest.currentProgress >= quest.targetQuantity) {
                    quest.isCompleted = true;
                    // Hiển thị thông báo HOÀN THÀNH Ở TRÊN CÙNG (chỉ 1 lần)
                    if (!quest.notifiedCompletion) { // Thêm cờ tạm để tránh spam thông báo
                        // ===>>> GỌI showMessage VỚI THAM SỐ 'top' <<<===
                        showMessage(`🎉 Hoàn thành nhiệm vụ: ${quest.description}`, "success", 4000, 'top');
                        quest.notifiedCompletion = true; // Đánh dấu đã thông báo
                    }
                }
                questUpdated = true; // Đánh dấu có ít nhất một nhiệm vụ được cập nhật
                console.log(`Quest Update: [${index}] ${quest.type} - Progress: ${quest.currentProgress}/${quest.targetQuantity}, Completed: ${quest.isCompleted}`);
            }
        });

        // Nếu có nhiệm vụ được cập nhật, render lại modal (nếu đang mở) và lưu game
        if (questUpdated) {
            if (dailyQuestPopup.style.display === 'block') {
                renderDailyQuests(); // Cập nhật hiển thị nếu modal đang mở
            }
            saveGame(); // Lưu trạng thái game sau khi cập nhật nhiệm vụ
        }
    }
		
		 /** Xử lý click nút nhận thưởng (Ủy quyền sự kiện) */
    function handleClaimQuestReward(event) {
        const claimButton = event.target.closest('.claim-button[data-quest-index]');
        if (!claimButton || claimButton.disabled) return;

        const questIndex = parseInt(claimButton.dataset.questIndex);
        if (isNaN(questIndex) || !gameState.dailyQuests || !gameState.dailyQuests[questIndex]) {
            console.error("Lỗi khi nhận thưởng: Index nhiệm vụ không hợp lệ.");
            return;
        }

        const quest = gameState.dailyQuests[questIndex];

        if (!quest.isCompleted) { showMessage("Nhiệm vụ chưa hoàn thành!", "warning"); return; }
        if (quest.isClaimed) { showMessage("Phần thưởng nhiệm vụ này đã được nhận rồi.", "info"); return; }

        // --- Thực hiện nhận thưởng ---
        gameState.currency += quest.rewardCurrency;
        quest.isClaimed = true; // Đánh dấu đã nhận

        // Cập nhật UI
        renderUI(); // Cập nhật tiền
        renderDailyQuests(); // Cập nhật lại danh sách nhiệm vụ (để đổi trạng thái nút)
        updateShopButtons(); // Cập nhật nút shop vì tiền thay đổi
        saveGame(); // Lưu game

        showMessage(`Nhận thưởng ${quest.rewardCurrency}💰 từ nhiệm vụ thành công!`, "success");
        logAction('claim_quest', null, `Nhận thưởng NVHN: +${quest.rewardCurrency}💰 (${quest.description})`, '🏆');
    }

    // --- Gắn Listener cho nút nhận thưởng (thêm vào attachEventListeners) ---
    const dailyQuestListElement = document.getElementById('daily-quest-list');
    if (dailyQuestListElement) {
        dailyQuestListElement.addEventListener('click', handleClaimQuestReward);
        // listenerCount++; // Tăng biến đếm nếu bạn dùng nó
    } else { console.warn("[V10 AttachListeners] Daily Quest List Element not found for claim button listener."); }

		
		/**  Render danh sách nhiệm vụ hằng ngày vào modal */
    function renderDailyQuests() {
    const questListElement = document.getElementById('daily-quest-list');
    const emptyMessageParagraph = questListElement.querySelector('p');

    if (!questListElement) return;

    questListElement.querySelectorAll('.quest-item').forEach(item => item.remove());

    // --- LOGIC SẮP XẾP MỚI ---
    // Lấy một bản sao của mảng quests để sắp xếp (tránh thay đổi trực tiếp gameState nếu không muốn)
    const questsToRender = gameState.dailyQuests ? gameState.dailyQuests.slice() : [];

    if (!questsToRender || questsToRender.length === 0) {
        if (emptyMessageParagraph) {
            emptyMessageParagraph.style.display = 'block';
        } else {
            questListElement.innerHTML = `<p style="text-align: center; padding: 20px; color: #666;">Không có nhiệm vụ nào.</p>`;
        }
        return;
    }

    // Sắp xếp mảng questsToRender bằng hàm so sánh
    questsToRender.sort(compareQuests);
    // --- KẾT THÚC LOGIC SẮP XẾP ---

    if (emptyMessageParagraph) {
        emptyMessageParagraph.style.display = 'none';
    }

    // --- QUAN TRỌNG: Lặp qua mảng ĐÃ SẮP XẾP ---
    questsToRender.forEach((quest) => { // Không cần index nữa nếu handleClaimQuestReward lấy index từ data-*
        // Tìm index gốc của quest này trong gameState.dailyQuests để nút bấm hoạt động đúng
        const originalIndex = gameState.dailyQuests.findIndex(originalQuest =>
            // Cần một cách đáng tin cậy để xác định quest gốc.
            // Sử dụng kết hợp nhiều thuộc tính. Mô tả thường là duy nhất trong một ngày.
            originalQuest.description === quest.description &&
            originalQuest.targetQuantity === quest.targetQuantity &&
            originalQuest.rewardCurrency === quest.rewardCurrency &&
            originalQuest.type === quest.type &&
            originalQuest.targetItemId === quest.targetItemId
        );

        if (originalIndex === -1) {
             console.error("Không thể tìm thấy index gốc cho nhiệm vụ đã sắp xếp:", quest);
             return; // Bỏ qua nếu không tìm thấy index gốc
        }


        const questItem = document.createElement('div');
        questItem.classList.add('quest-item');
        questItem.classList.toggle('completed', quest.isCompleted && !quest.isClaimed);

        const progressPercent = quest.targetQuantity > 0
            ? Math.min(100, (quest.currentProgress / quest.targetQuantity) * 100)
            : (quest.isCompleted ? 100 : 0);

        let rewardHtml = `<strong>${quest.rewardCurrency}💰</strong>`;

        questItem.innerHTML = `
            <div class="quest-info">
                <div class="quest-title">${quest.description}</div>
                <div class="quest-progress">
                    <span class="quest-progress-text">Tiến độ: ${quest.currentProgress} / ${quest.targetQuantity} (${progressPercent.toFixed(0)}%)</span>
                    <div style="background-color: #e0e0e0; border-radius: 4px; height: 8px; overflow: hidden; margin-top: 4px;">
                       <div style="width: ${progressPercent}%; background-color: #4caf50; height: 100%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
                <div class="quest-reward" style="margin-top: 8px;">Phần thưởng: ${rewardHtml}</div>
            </div>
            <button class="claim-button" data-quest-index="${originalIndex}" ${quest.isCompleted && !quest.isClaimed ? '' : 'disabled'}>
                ${quest.isClaimed ? 'Đã nhận' : (quest.isCompleted ? 'Nhận thưởng' : 'Chưa xong')}
            </button>
        `;
        questListElement.appendChild(questItem);
    });
}
		
		/** Lấy ngày hiện tại dưới dạng chuỗi 'YYYY-MM-DD' */
    function getCurrentDateString() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    /** Lấy ngẫu nhiên itemId của hạt giống từ ITEM_DATA */
    function getRandomSeedItemId() {
        const seedIds = Object.keys(ITEM_DATA).filter(id => ITEM_DATA[id].type === 'seed');
        if (seedIds.length === 0) return null;
        return seedIds[Math.floor(Math.random() * seedIds.length)];
    }

    /** Lấy ngẫu nhiên itemId của phân bón từ ITEM_DATA */
    function getRandomFertilizerItemId() {
        // Chỉ lấy các loại phân bón thực sự (có fertilityBoost hoặc là growth/protect)
        const fertilizerIds = Object.keys(ITEM_DATA).filter(id => {
             const item = ITEM_DATA[id];
             return item.type === 'tool' && (typeof item.fertilityBoost === 'number' || id === 'fertilizer_growth' || id === 'fertilizer_protect');
        });
        if (fertilizerIds.length === 0) return null;
        return fertilizerIds[Math.floor(Math.random() * fertilizerIds.length)];
    }

     /** Tạo danh sách nhiệm vụ hằng ngày mới */
    function generateDailyQuests() {
        console.log("Generating new daily quests...");
        const availableQuestTypes = Object.values(QUEST_TYPES);
        const selectedQuestTypes = [];
        const newQuests = [];
        const todayDate = getCurrentDateString();

        // Chọn 10 loại nhiệm vụ khác nhau ngẫu nhiên
        while (selectedQuestTypes.length < NUM_DAILY_QUESTS && availableQuestTypes.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableQuestTypes.length);
            selectedQuestTypes.push(availableQuestTypes.splice(randomIndex, 1)[0]);
        }
         // Nếu không đủ 10 loại khác nhau, thêm ngẫu nhiên từ pool ban đầu (hiếm khi xảy ra)
         const originalTypes = Object.values(QUEST_TYPES);
         while (selectedQuestTypes.length < NUM_DAILY_QUESTS && originalTypes.length > 0) {
              selectedQuestTypes.push(originalTypes[Math.floor(Math.random() * originalTypes.length)]);
         }


        // Tạo đối tượng nhiệm vụ chi tiết
        selectedQuestTypes.forEach((questType, index) => {
            const config = QUEST_CONFIG[questType];
            if (!config) { console.warn(`Missing config for quest type: ${questType}`); return; }

            const quantity = config.minQty + Math.floor(Math.random() * (config.maxQty - config.minQty + 1));
            let targetItemId = null;
            let description = '';
            let rewardMultiplier = 1; // Hệ số nhân thưởng dựa trên độ khó/item

            switch (questType) {
                case QUEST_TYPES.PLANT_SPECIFIC:
                    targetItemId = getRandomSeedItemId();
                    if (!targetItemId) return; // Bỏ qua nếu không có hạt giống
                    description = `Trồng ${quantity} cây ${ITEM_DATA[targetItemId]?.name || 'không rõ'}.`;
                    rewardMultiplier = (ITEM_DATA[targetItemId]?.price || 1) * 0.8; // Thưởng nhiều hơn cho hạt giống đắt
                    break;
                case QUEST_TYPES.PLANT_ANY:
                    description = `Trồng ${quantity} cây bất kỳ.`;
                    break;
                case QUEST_TYPES.HARVEST_SPECIFIC:
                    targetItemId = getRandomSeedItemId();
                     if (!targetItemId) return; // Bỏ qua nếu không có hạt giống
                    description = `Thu hoạch ${quantity} cây ${ITEM_DATA[targetItemId]?.name || 'không rõ'}.`;
                     rewardMultiplier = (ITEM_DATA[targetItemId]?.harvestYield || 1) * 0.5; // Thưởng dựa trên giá trị thu hoạch
                    break;
                case QUEST_TYPES.HARVEST_ANY:
                    description = `Thu hoạch ${quantity} cây bất kỳ.`;
                    break;
                case QUEST_TYPES.SELL_DIRECT_SPECIFIC:
                    targetItemId = getRandomSeedItemId();
                     if (!targetItemId) return;
                    description = `Bán trực tiếp ${quantity} cây ${ITEM_DATA[targetItemId]?.name || 'không rõ'}.`;
                     rewardMultiplier = (ITEM_DATA[targetItemId]?.harvestYield || 1) * 0.6;
                    break;
                case QUEST_TYPES.SELL_HARVESTED_SPECIFIC:
                    targetItemId = getRandomSeedItemId();
                     if (!targetItemId) return;
                    description = `Bán từ kho ${quantity} ${ITEM_DATA[targetItemId]?.name || 'không rõ'}.`;
                     rewardMultiplier = (ITEM_DATA[targetItemId]?.harvestYield || 1) * 0.4;
                    break;
                case QUEST_TYPES.USE_FERTILIZER_TYPE:
                    targetItemId = getRandomFertilizerItemId();
                     if (!targetItemId) return;
                    description = `Sử dụng ${quantity} ${ITEM_DATA[targetItemId]?.name || 'Phân bón'}.`;
                     rewardMultiplier = (ITEM_DATA[targetItemId]?.price || 5) * 0.7; // Thưởng dựa trên giá phân bón
                    break;
                case QUEST_TYPES.BUY_FERTILIZER:
                    description = `Mua ${quantity} phân bón bất kỳ từ cửa hàng.`;
                    break;
                case QUEST_TYPES.BUY_SEED:
                    description = `Mua ${quantity} hạt giống bất kỳ từ cửa hàng.`;
                    break;
                case QUEST_TYPES.EARN_CURRENCY:
                    description = `Kiếm được ${quantity}💰 từ việc bán cây trồng.`;
                    rewardMultiplier = quantity * 0.1; // Thưởng tỉ lệ với số tiền cần kiếm
                    break;
                default:
                    description = 'Nhiệm vụ không xác định.';
            }

            const reward = Math.max(1, Math.round(config.baseReward * rewardMultiplier)); // Tính thưởng cuối cùng

            newQuests.push({
                // id: `${todayDate}-${index}-${questType}`, // ID duy nhất cho instance quest
                type: questType, // Loại quest
                description: description,
                targetItemId: targetItemId,
                targetQuantity: quantity,
                rewardCurrency: reward,
                currentProgress: 0,
                isCompleted: false,
                isClaimed: false
            });
        });

        gameState.dailyQuests = newQuests;
        gameState.lastQuestResetDate = todayDate;
        console.log(`Generated ${newQuests.length} new daily quests for ${todayDate}.`);
        saveGame(); // Lưu lại state với nhiệm vụ mới
    }
    // --- Kết thúc Định nghĩa Nhiệm vụ ---
		/**  Mở Popup Nhiệm Vụ Hằng Ngày */
function openDailyQuestPopup() {
    if (dailyQuestPopup) {
        console.log("Mở popup Nhiệm vụ Hằng ngày.");
        closeMenuPopup(); // Đóng menu chính trước
        renderDailyQuests(); // <<< RENDER DANH SÁCH NHIỆM VỤ KHI MỞ >>>
        openModal('daily-quest-popup'); // Mở modal nhiệm vụ
    } else {
        console.error("Không tìm thấy phần tử DOM của popup Nhiệm vụ Hằng ngày!");
        showMessage("Lỗi: Không thể mở bảng nhiệm vụ.", "error");
    }
}
		 /** Phát âm thanh sấm sét nếu hiệu ứng được bật. */
function playLightningSound() {
    // Kiểm tra xem hiệu ứng âm thanh có được bật không
    if (!areEffectSoundsEnabled) {
        // console.log("Âm thanh hiệu ứng đang tắt, bỏ qua tiếng sét."); // Bỏ comment nếu muốn debug
        return; // Không làm gì nếu hiệu ứng tắt
    }

    // Kiểm tra xem phần tử audio có tồn tại không
    if (lightningSound) {
        lightningSound.currentTime = 0; // Tua về đầu để phát lại nếu đang chạy
        lightningSound.play().catch(error => {
            // Bắt lỗi nếu trình duyệt chặn phát âm thanh (ví dụ: chưa có tương tác người dùng)
            console.warn("Không thể phát âm thanh sấm sét:", error);
        });
    } else {
        // Log cảnh báo nếu không tìm thấy thẻ audio
        console.warn("Không tìm thấy phần tử âm thanh sấm sét (lightning-sound).");
    }
}
		function getTotalInventoryCount() {
    let totalCount = 0;
    // Tính kho đã mua (gameState.inventory) - Logic không đổi
    for (const itemId in gameState.inventory) {
        if (gameState.inventory.hasOwnProperty(itemId)) {
            totalCount += gameState.inventory[itemId] || 0;
        }
    }
    // --- [THAY ĐỔI] Tính kho đã thu hoạch (gameState.harvestedItems) ---
    for (const itemId in gameState.harvestedItems) {
        if (gameState.harvestedItems.hasOwnProperty(itemId)) {
            const qualityData = gameState.harvestedItems[itemId];
            if (qualityData && typeof qualityData === 'object') { // Chỉ xử lý nếu là object chất lượng
                // Cộng tổng số lượng từ tất cả các bậc chất lượng
                totalCount += (qualityData[QUALITY_TIERS.PERFECT] || 0) +
                              (qualityData[QUALITY_TIERS.GOOD] || 0) +
                              (qualityData[QUALITY_TIERS.FAIR] || 0) +
                              (qualityData[QUALITY_TIERS.POOR] || 0);
            }
            // Bỏ qua nếu không phải object (định dạng cũ - không nên còn sót sau loadGame)
        }
    }
    return totalCount;
}
		
		/** [MỚI] Bật/tắt nhạc nền và cập nhật nút */
function toggleBackgroundMusic() {
    // 1. Kiểm tra các phần tử cần thiết
    if (!backgroundMusic || !toggleSoundBtn) {
        console.error("Lỗi: Không tìm thấy audio nhạc nền hoặc nút âm thanh.");
        return;
    }
    // Kiểm tra các audio hiệu ứng để đảm bảo tắt/bật đồng bộ nếu cần
    if (!rainSound) console.warn("Không tìm thấy audio mưa (rainSound).");
    if (!rainySunnySound) console.warn("Không tìm thấy audio mưa nắng (rainy-sunny-sound).");

    try {
        // 2. Đảo ngược trạng thái mong muốn
        isMusicEnabled = !isMusicEnabled;
        console.log(`Người dùng chuyển trạng thái nhạc nền thành: ${isMusicEnabled}`);

        // 3. Lưu trạng thái MỚI vào localStorage (dưới dạng chuỗi 'true'/'false')
        localStorage.setItem(MUSIC_ENABLED_KEY, isMusicEnabled.toString());
        console.log(`Đã lưu trạng thái nhạc nền (${isMusicEnabled}) vào localStorage với key ${MUSIC_ENABLED_KEY}.`);

        // 4. Thực hiện hành động bật/tắt audio
        if (isMusicEnabled) {
            // --- Người dùng muốn BẬT nhạc ---
            const playPromise = backgroundMusic.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // Thành công bật nhạc nền
                    console.log("Nhạc nền đã được BẬT thành công.");
                    musicStarted = true; // Đánh dấu nhạc đã chạy ít nhất 1 lần
                    updateSoundButtonText(); // Cập nhật nút thành "Tắt"
                    // gameTick sẽ tự xử lý bật âm thanh thời tiết nếu cần và nếu hiệu ứng đang bật
                }).catch(error => {
                    // Lỗi khi cố gắng bật nhạc (thường do chưa có tương tác)
                    console.error("Lỗi khi bật nhạc nền qua nút toggle (cần tương tác?):", error);
                    showMessage("Không thể bật nhạc. Hãy thử click vào game.", "warning");
                    // Nếu lỗi, quay lại trạng thái tắt và lưu lại
                    isMusicEnabled = false;
                    localStorage.setItem(MUSIC_ENABLED_KEY, 'false');
                    musicStarted = false; // Reset cờ nếu chưa chạy được
                    updateSoundButtonText(); // Cập nhật nút thành "Bật"
                    // Đảm bảo tắt cả âm thanh thời tiết nếu có lỗi bật nhạc nền
                    if (rainSound && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
                    if (rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
                });
            } else {
                // Trình duyệt cũ không trả về Promise (hiếm gặp)
                console.log("Nhạc nền đã được BẬT (trình duyệt cũ).");
                musicStarted = true;
                updateSoundButtonText();
            }
        } else {
            // --- Người dùng muốn TẮT nhạc ---
            backgroundMusic.pause();
            console.log("Nhạc nền đã được TẮT.");
            updateSoundButtonText(); // Cập nhật nút thành "Bật"

            // Tắt cả âm thanh thời tiết đang chạy (nếu có) vì nhạc nền đã tắt
            if (rainSound && !rainSound.paused) {
                rainSound.pause(); rainSound.currentTime = 0;
                console.log("Âm thanh mưa cũng đã được TẮT.");
            }
            if (rainySunnySound && !rainySunnySound.paused) {
                rainySunnySound.pause(); rainySunnySound.currentTime = 0;
                console.log("Âm thanh mưa nắng cũng đã được TẮT.");
            }
        }
    } catch (error) {
        console.error("Lỗi không mong muốn khi xử lý bật/tắt nhạc:", error);
        showMessage("Đã xảy ra lỗi khi xử lý âm thanh.", "error");
        updateSoundButtonText(); // Cập nhật lại nút theo trạng thái thực tế của isMusicEnabled
    }
}
/**  Cập nhật văn bản nút âm thanh dựa trên trạng thái thực tế */
function updateSoundButtonText() {
    if (!toggleSoundBtn || !backgroundMusic) return;
    // Dựa vào biến trạng thái isMusicEnabled
    if (isMusicEnabled) {
        // Nếu trạng thái là Bật (mong muốn nghe nhạc)
        toggleSoundBtn.textContent = "🔇 Tắt Âm Thanh";
        toggleSoundBtn.title = "Tắt nhạc nền và âm thanh thời tiết";
        // Có thể thêm kiểm tra backgroundMusic.paused để đổi title nếu chưa play được do policy
        // if (backgroundMusic.paused) toggleSoundBtn.title += " (Chưa phát)";
    } else {
        // Nếu trạng thái là Tắt (không muốn nghe nhạc)
        toggleSoundBtn.textContent = "🔊 Bật Âm Thanh";
        toggleSoundBtn.title = "Bật nhạc nền và âm thanh thời tiết";
    }
    console.log(`Updated sound button text based on isMusicEnabled=${isMusicEnabled}`);
}

		
		
		
		    /** Mở popup xác nhận mua ô đất bị khóa */
    function openLockedPlotPopup() {
        if (lockedPlotPopup) {
            lockedPlotPopup.style.display = 'flex'; // Dùng flex để căn giữa theo CSS
            // Tự động focus nút hủy hoặc nút mua (nếu enable)
            const focusTarget = confirmBuyPlotBtn.disabled ? cancelBuyPlotBtn : confirmBuyPlotBtn;
            setTimeout(() => focusTarget?.focus(), 50); // Delay nhỏ
        }
    }

    /** Đóng popup xác nhận mua ô đất bị khóa */
    function closeLockedPlotPopup() {
        if (lockedPlotPopup) {
            lockedPlotPopup.style.display = 'none';
             // Xóa data cũ phòng trường hợp lỗi
             if (confirmBuyPlotBtn) {
                 delete confirmBuyPlotBtn.dataset.plotId;
                 delete confirmBuyPlotBtn.dataset.cost;
             }
        }
    }

    /** Xử lý khi nhấn nút Mua trong popup ô đất bị khóa */
    function handleConfirmBuyPlot() {
            // Lấy thông tin từ dataset của nút xác nhận
            const plotIdString = confirmBuyPlotBtn.dataset.plotId;
            const costString = confirmBuyPlotBtn.dataset.cost;

            // Kiểm tra xem dataset có tồn tại và hợp lệ không
            if (plotIdString === undefined || costString === undefined) {
                 console.error("Lỗi: Không tìm thấy dữ liệu plotId hoặc cost trên nút xác nhận.");
                 showMessage("Lỗi! Không thể xử lý yêu cầu mua ô đất.", "error");
                 closeLockedPlotPopup();
                 return;
            }

            const plotId = parseInt(plotIdString);
            const cost = parseInt(costString);

            // Kiểm tra tính hợp lệ của plotId và cost
            if (isNaN(plotId) || isNaN(cost) || plotId < 0 || cost <= 0) {
                 console.error(`Lỗi dữ liệu không hợp lệ: plotId=${plotId}, cost=${cost}`);
                 showMessage("Lỗi! Dữ liệu mua ô đất không hợp lệ.", "error");
                 closeLockedPlotPopup();
                 return;
            }

            // Kiểm tra xem có đúng là mua ô tiếp theo không
            if (plotId !== gameState.maxUnlockedPlots) {
                console.error(`Lỗi logic: Đang cố mua ô ${plotId} nhưng ô tiếp theo phải là ${gameState.maxUnlockedPlots}`);
                showMessage(`Lỗi! Chỉ có thể mở khóa ô số ${gameState.maxUnlockedPlots + 1} tiếp theo.`, "error");
                closeLockedPlotPopup();
                return;
            }

            // Kiểm tra tiền
            if (gameState.currency >= cost) {
                // --- Thực hiện mua ---
                gameState.currency -= cost;
                gameState.maxUnlockedPlots++;
                initializePlotsData(); // Quan trọng: Khởi tạo dữ liệu cho ô mới mở khóa
                renderUI();           // Cập nhật hiển thị tiền và số ô
                renderGarden();       // Vẽ lại vườn với ô mới
                updateShopButtons(); // Cập nhật nút shop vì tiền thay đổi
                showMessage(`Chúc mừng! Đã mở khóa ô đất số ${plotId + 1}!`, "success");
                saveGame(); // Lưu game sau khi mua thành công

                // <<< THÊM LOG ACTION >>>
                logAction('buy_plot', plotId, `Mở khóa ô ${plotId + 1} (-${cost}💰).`, '🏞️', null);
			   // <<< KẾT THÚC LOG ACTION >>>

            } else {
                // Thông báo không đủ tiền (kiểm tra lại lần nữa)
                showMessage(`Không đủ tiền! Cần ${cost}💰, bạn chỉ có ${gameState.currency}💰.`, "error");
            }
            closeLockedPlotPopup(); // Luôn đóng popup sau khi xử lý
        }
	function handleEscapeKey(event) {
    if (event.key === 'Escape') {
        let modalOrPopupClosed = false;
        const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
        const savegamePopupElement = document.getElementById('menu-savegame-popup');

        // Ưu tiên 1: Đóng popup xác nhận khôi phục nếu đang mở
        if (confirmRestorePopup && confirmRestorePopup.style.display !== 'none') {
            handleCancelRestore(); // Hủy bỏ và đóng popup xác nhận, xóa underlay
            modalOrPopupClosed = true;
        }
        // Ưu tiên 2: Đóng popup Lưu/Nhập nếu đang mở (và không bị che)
        else if (savegamePopupElement && savegamePopupElement.style.display !== 'none' && !savegamePopupElement.classList.contains('popup-underlay')) {
             closeSavegamePopup();
             modalOrPopupClosed = true;
        }
        // Tiếp tục với các popup xác nhận khác (đã được ưu tiên xử lý trong hàm đóng tương ứng)
        else if (confirmRepairRodPopup && confirmRepairRodPopup.style.display !== 'none') { closeConfirmRepairPopup(); modalOrPopupClosed = true; }
        else if (confirmRemoveRodPopup && confirmRemoveRodPopup.style.display !== 'none') { closeConfirmRemovePopup(); modalOrPopupClosed = true; }
        else if (discardItemPopup && discardItemPopup.style.display !== 'none') { closeDiscardItemPopup(); modalOrPopupClosed = true; }
        else if (hatNgocTroiRewardPopup && hatNgocTroiRewardPopup.style.display !== 'none') { closeRewardPopup(); modalOrPopupClosed = true; }
        else if (hatNgocTroiPopup && hatNgocTroiPopup.style.display !== 'none') { closeHatNgocTroiPopup(); modalOrPopupClosed = true; }
        else if (confirmSellAllModal && confirmSellAllModal.style.display !== 'none') { closeConfirmSellAllModal(); modalOrPopupClosed = true; }
        // Popup menu và khóa ô đất
        else if (menuPopup && menuPopup.style.display !== 'none') { closeMenuPopup(); modalOrPopupClosed = true; }
        else if (lockedPlotPopup && lockedPlotPopup.style.display !== 'none') { closeLockedPlotPopup(); modalOrPopupClosed = true; }
        // Modal hành động cột thu lôi
        else if (lightningRodActionModal && lightningRodActionModal.style.display !== 'none') { closeModal('lightning-rod-action-modal'); currentActionPlotId = null; modalOrPopupClosed = true; }
        // Các modal chung khác
        else {
            const openModals = document.querySelectorAll('.modal[style*="display: block"]:not(.popup-underlay), .modal[style*="display: flex"]:not(.popup-underlay)'); // Chỉ tìm modal không bị che
            if (openModals.length > 0) {
                 const lastModal = openModals[openModals.length - 1];
                 const modalId = lastModal.id;
                 // Danh sách các ID đã xử lý ở trên
                 const specificPopupIds = [
                     'popup-confirm-restoregame', 'savegamePopup', 'confirmRepairRodPopup', 'confirmRemoveRodPopup',
                     'discard-item-popup', 'hat-ngoc-troi-reward-popup', 'hat-ngoc-troi-popup',
                     'confirm-sell-all-modal', 'menu-popup', 'locked-plot-popup',
                     'lightning-rod-action-modal'
                 ];
                 if (modalId && !specificPopupIds.includes(modalId)) {
                      closeModal(modalId);
                      if (modalId === 'seed-selection-modal') currentPlantingPlotId = null;
                      if (['fertilizer-selection-modal', 'plant-action-modal', 'empty-plot-action-modal'].includes(modalId)) currentActionPlotId = null;
                      modalOrPopupClosed = true;
                 } else if (!modalId) {
                      console.warn("Escape key: Found an open modal without an ID.");
                 }
            }
        }

        // Kiểm tra và ẩn lớp phủ (logic này vẫn đúng)
        if (modalOrPopupClosed) {
             setTimeout(() => {
                 const anyModalOpen = document.querySelector('.modal[style*="display: block"], .modal[style*="display: flex"]');
                 if (!anyModalOpen && darkOverlayElement && darkOverlayElement.classList.contains('visible')) {
                     hideDarkOverlay();
                 }
             }, 50);
        }
    }
}

    // --- Cập nhật Listener click nền ---
     /** Xử lý click bên ngoài nội dung modal/popup để đóng */
    function handleModalBackgroundClick(event) {
    let modalOrPopupClosed = false;
    const target = event.target;
    const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
    const savegamePopupElement = document.getElementById('menu-savegame-popup');

    // Ưu tiên 1: Click vào nền của popup xác nhận khôi phục
    if (target === confirmRestorePopup) {
        handleCancelRestore(); // Đóng popup xác nhận, xóa underlay
        modalOrPopupClosed = true;
    }
    // Ưu tiên 2: Click vào nền của popup lưu/nhập *chỉ khi* nó không bị che
    else if (target === savegamePopupElement && !savegamePopupElement.classList.contains('popup-underlay')) {
        closeSavegamePopup();
        modalOrPopupClosed = true;
    }
    // Tiếp tục với các popup/modal cụ thể khác
    else {
        const specificPopups = {
            'confirmRepairRodPopup': closeConfirmRepairPopup,
            'confirmRemoveRodPopup': closeConfirmRemovePopup,
            'discard-item-popup': closeDiscardItemPopup,
            'hat-ngoc-troi-reward-popup': closeRewardPopup,
            'hat-ngoc-troi-popup': closeHatNgocTroiPopup,
            'confirm-sell-all-modal': closeConfirmSellAllModal,
            'menu-popup': closeMenuPopup,
            'locked-plot-popup': closeLockedPlotPopup,
            'lightning-rod-action-modal': () => { closeModal('lightning-rod-action-modal'); currentActionPlotId = null; }
        };
        let handledSpecific = false;
        for (const popupId in specificPopups) {
            const popupElement = document.getElementById(popupId);
            // Chỉ đóng nếu click vào nền của nó VÀ nó không bị che (trừ trường hợp đặc biệt nếu cần)
            if (target === popupElement && !popupElement.classList.contains('popup-underlay')) {
                specificPopups[popupId]();
                modalOrPopupClosed = true;
                handledSpecific = true;
                break;
            }
        }

        // Nếu không phải popup cụ thể, kiểm tra modal chung
        if (!handledSpecific && target.classList.contains('modal') && !target.classList.contains('popup-underlay')) {
             const modalId = target.id;
             const specificIdsList = Object.keys(specificPopups).concat(['popup-confirm-restoregame', 'savegamePopup']); // Danh sách đầy đủ
             if (!specificIdsList.includes(modalId)) {
                 closeModal(modalId);
                 if (modalId === 'seed-selection-modal') currentPlantingPlotId = null;
                 if (['fertilizer-selection-modal', 'plant-action-modal', 'empty-plot-action-modal'].includes(modalId)) currentActionPlotId = null;
                 modalOrPopupClosed = true;
             }
        }
    }

    // Kiểm tra và ẩn lớp phủ (logic này vẫn đúng)
    if (modalOrPopupClosed) {
         setTimeout(() => {
             const anyModalOpen = document.querySelector('.modal[style*="display: block"], .modal[style*="display: flex"]');
             if (!anyModalOpen && darkOverlayElement && darkOverlayElement.classList.contains('visible')) {
                 hideDarkOverlay();
             }
         }, 50);
    }
}
	/** Xử lý click nút Lịch sử trồng cây */
function handlePlantingHistoryClick() {
    console.log("Chuyển đến trang Lịch sử trồng cây...");
    // Lưu game lần cuối trước khi chuyển trang để đảm bảo lịch sử mới nhất được lưu
    saveGame();
    // Chuyển hướng người dùng đến trang history-menu.html
    window.location.href = 'history-menu.html';
    // Không cần đóng menu ở đây vì trang sẽ chuyển đi
}
		
		
		
		
        // ==================================

        /** Lưu trạng thái game hiện tại vào localStorage. */
         function saveGame() {
    try {
        const now = Date.now();
        // Tính và cộng dồn thời gian chơi
        if (gameState.lastUpdateTimestamp && now > gameState.lastUpdateTimestamp) {
            if (tickCounter > 0 || gameState.totalPlayTime === 0) {
                gameState.totalPlayTime += (now - gameState.lastUpdateTimestamp);
            }
        }
        // Cập nhật timestamp cuối cùng *trước* khi lưu
        gameState.lastUpdateTimestamp = now;

        // === Tạo một bản sao sâu của gameState để validate và chỉnh sửa trước khi lưu ===
        // Sử dụng JSON.parse(JSON.stringify(...)) để tạo bản sao sâu an toàn
        let stateToSave;
        try {
            stateToSave = JSON.parse(JSON.stringify(gameState));
        } catch (stringifyError) {
            console.error("Lỗi nghiêm trọng khi tạo bản sao gameState để lưu:", stringifyError);
            showMessage("Lỗi nghiêm trọng khi chuẩn bị lưu game!", "error", MESSAGE_DISPLAY_TIME * 2);
            return; // Không thể tiếp tục nếu không tạo được bản sao
        }


        // === Validate và làm sạch dữ liệu trước khi lưu ===

        // 1. Validate các thuộc tính cơ bản
        stateToSave.currency = (typeof stateToSave.currency === 'number' && stateToSave.currency >= 0) ? Math.floor(stateToSave.currency) : 0; // Làm tròn xuống và đảm bảo không âm
        stateToSave.maxUnlockedPlots = (typeof stateToSave.maxUnlockedPlots === 'number' && stateToSave.maxUnlockedPlots >= INITIAL_PLOT_COUNT) ? stateToSave.maxUnlockedPlots : INITIAL_PLOT_COUNT;
        stateToSave.totalPlayTime = (typeof stateToSave.totalPlayTime === 'number' && stateToSave.totalPlayTime >= 0) ? stateToSave.totalPlayTime : 0;
        stateToSave.gameStartTime = (typeof stateToSave.gameStartTime === 'number' && stateToSave.gameStartTime > 0) ? stateToSave.gameStartTime : now; // Dùng now nếu không hợp lệ
        stateToSave.lastUpdateTimestamp = (typeof stateToSave.lastUpdateTimestamp === 'number' && stateToSave.lastUpdateTimestamp > 0) ? stateToSave.lastUpdateTimestamp : now;

        // 2. Validate Inventory (Đã Mua)
        if (typeof stateToSave.inventory !== 'object' || stateToSave.inventory === null) stateToSave.inventory = {};
        const validatedInventory = {};
        for (const itemId in stateToSave.inventory) {
            if (ITEM_DATA[itemId]) { // Chỉ lưu những item còn tồn tại trong dữ liệu game
                const quantity = parseInt(stateToSave.inventory[itemId]);
                if (!isNaN(quantity) && quantity > 0) {
                    validatedInventory[itemId] = quantity;
                }
            } else {
                console.warn(`saveGame: Loại bỏ item ID không tồn tại '${itemId}' khỏi inventory.`);
            }
        }
        stateToSave.inventory = validatedInventory;
        // Đảm bảo key 'pesticide' tồn tại nếu cần thiết bởi logic game khác
        if (stateToSave.inventory.pesticide === undefined && ITEM_DATA['pesticide']) {
             stateToSave.inventory.pesticide = 0;
        }

        // 3. Validate Harvested Items (Đã Thu Hoạch - Định dạng Chất lượng) và DỌN DẸP
        if (typeof stateToSave.harvestedItems !== 'object' || stateToSave.harvestedItems === null) {
            stateToSave.harvestedItems = {};
        }
        const validatedHarvestedClean = {}; // Tạo object mới để chứa dữ liệu sạch
        for (const itemId in stateToSave.harvestedItems) {
            // Chỉ lưu lại nếu là hạt giống hợp lệ và còn tồn tại trong ITEM_DATA
            if (ITEM_DATA[itemId] && ITEM_DATA[itemId].type === 'seed') {
                const qualityData = stateToSave.harvestedItems[itemId];
                // Chỉ lưu lại nếu là object chất lượng hợp lệ
                if (qualityData && typeof qualityData === 'object') {
                    const cleanQualityData = {
                        [QUALITY_TIERS.PERFECT]: Math.max(0, parseInt(qualityData[QUALITY_TIERS.PERFECT] || 0)),
                        [QUALITY_TIERS.GOOD]:    Math.max(0, parseInt(qualityData[QUALITY_TIERS.GOOD] || 0)),
                        [QUALITY_TIERS.FAIR]:    Math.max(0, parseInt(qualityData[QUALITY_TIERS.FAIR] || 0)),
                        [QUALITY_TIERS.POOR]:    Math.max(0, parseInt(qualityData[QUALITY_TIERS.POOR] || 0))
                    };
                    // Chỉ thêm vào object sạch nếu tổng số lượng > 0
                    const totalQty = Object.values(cleanQualityData).reduce((sum, count) => sum + count, 0);
                    if (totalQty > 0) {
                        validatedHarvestedClean[itemId] = cleanQualityData;
                    } else {
                         console.log(`saveGame: Loại bỏ harvested item ${itemId} vì tổng số lượng là 0.`);
                    }
                } else {
                     console.warn(`saveGame: Dữ liệu harvested item ${itemId} không phải object chất lượng hợp lệ, loại bỏ.`);
                }
            } else {
                 console.warn(`saveGame: Loại bỏ harvested item ID không tồn tại hoặc không phải hạt giống '${itemId}'.`);
            }
        }
        stateToSave.harvestedItems = validatedHarvestedClean; // Gán lại object đã được lọc sạch

        // 4. Validate Plots (chỉ lưu các ô đã mở khóa)
        if (!Array.isArray(stateToSave.plots)) stateToSave.plots = [];
        // Cắt bỏ các ô chưa mở khóa hoặc dư thừa so với maxUnlockedPlots
        stateToSave.plots = stateToSave.plots.slice(0, stateToSave.maxUnlockedPlots);
        // Tạo trạng thái mặc định cho plot để sử dụng khi validate
         const defaultPlotStateForSave = {
             seedId: null, plantTime: null, hasPest: false, health: INITIAL_PLANT_HEALTH, fertility: BASE_FERTILITY, causeOfDeath: null, pestDeathClickCount: 0, barrenHarvestPenaltyFactor: 1.0, isDry: false
         };
        stateToSave.plots = stateToSave.plots.map((plot, index) => {
            // Nếu plot không tồn tại, không phải object, hoặc ID không đúng -> Tạo plot mặc định
            if (!plot || typeof plot !== 'object' || typeof plot.id !== 'number' || plot.id !== index) {
                console.warn(`saveGame: Dữ liệu plot không hợp lệ tại index ${index}, tạo plot mặc định.`);
                // Quan trọng: Tạo bản sao sâu của trạng thái mặc định
                return { id: index, ...JSON.parse(JSON.stringify(defaultPlotStateForSave)) };
            }
            // Tạo plot sạch dựa trên dữ liệu gốc
            const cleanPlot = { id: index }; // Bắt đầu với ID đúng
            cleanPlot.seedId = (plot.seedId && ITEM_DATA[plot.seedId]) ? plot.seedId : null;
            cleanPlot.plantTime = (typeof plot.plantTime === 'number' && plot.plantTime > 0 && cleanPlot.seedId) ? plot.plantTime : null; // Chỉ giữ plantTime nếu seedId hợp lệ
            cleanPlot.hasPest = typeof plot.hasPest === 'boolean' ? plot.hasPest : false;
            // Đảm bảo health và fertility trong khoảng hợp lệ
            cleanPlot.health = (typeof plot.health === 'number') ? Math.max(0, Math.min(INITIAL_PLANT_HEALTH, plot.health)) : INITIAL_PLANT_HEALTH;
            cleanPlot.fertility = (typeof plot.fertility === 'number') ? Math.max(0, Math.min(BASE_FERTILITY, plot.fertility)) : BASE_FERTILITY;
            cleanPlot.causeOfDeath = (typeof plot.causeOfDeath === 'string' || plot.causeOfDeath === null) ? plot.causeOfDeath : null; // Cho phép null hoặc string
            cleanPlot.pestDeathClickCount = (typeof plot.pestDeathClickCount === 'number' && plot.pestDeathClickCount >= 0) ? plot.pestDeathClickCount : 0;
            cleanPlot.barrenHarvestPenaltyFactor = (typeof plot.barrenHarvestPenaltyFactor === 'number' && plot.barrenHarvestPenaltyFactor >= 1.0) ? plot.barrenHarvestPenaltyFactor : 1.0;
            cleanPlot.isDry = typeof plot.isDry === 'boolean' ? plot.isDry : false;
			 cleanPlot.fertilizerProtectUsageCount = (typeof plot.fertilizerProtectUsageCount === 'number' && plot.fertilizerProtectUsageCount >= 0) ? plot.fertilizerProtectUsageCount : 0;
            cleanPlot.hasFertilizerProtectBuff = (typeof plot.hasFertilizerProtectBuff === 'boolean' && cleanPlot.seedId && cleanPlot.health > 0) ? plot.hasFertilizerProtectBuff : false; // Buff chỉ active khi có cây sống
            // Đảm bảo count và buff đồng bộ (nếu buff on thì count > 0)
            if (cleanPlot.hasFertilizerProtectBuff && cleanPlot.fertilizerProtectUsageCount <= 0) {
                cleanPlot.hasFertilizerProtectBuff = false; // Tắt buff nếu count = 0
            }
			
			
			cleanPlot.fertilizerGrowthUsageCount = (typeof plot.fertilizerGrowthUsageCount === 'number' && plot.fertilizerGrowthUsageCount >= 0) ? plot.fertilizerGrowthUsageCount : 0;
			// <<< THÊM: Validate và làm sạch fenceData >>>
        if (plot.fenceData && typeof plot.fenceData === 'object' && plot.fenceData.id === 'raobaove' && ITEM_DATA.raobaove) {
            const fenceHealthSave = parseInt(plot.fenceData.health);
            // Chỉ lưu nếu health hợp lệ (kể cả khi bằng 0 - tức là bị hỏng)
            if (!isNaN(fenceHealthSave) && fenceHealthSave >= 0 && fenceHealthSave <= ITEM_DATA.raobaove.health) {
                cleanPlot.fenceData = { id: 'raobaove', health: fenceHealthSave };
            } else {
                cleanPlot.fenceData = null; // Không lưu nếu health không hợp lệ
            }
        } else {
            cleanPlot.fenceData = null; // Không lưu nếu không có hoặc ID không đúng
        }
        // <<< KẾT THÚC: Validate fenceData >>>
			
			
			
			
            return cleanPlot;
        });
         // Đảm bảo mảng plots có đủ số lượng ô tương ứng với maxUnlockedPlots
         while (stateToSave.plots.length < stateToSave.maxUnlockedPlots) {
             const newIndex = stateToSave.plots.length;
             console.warn(`saveGame: Thêm plot mặc định cho index ${newIndex} bị thiếu.`);
             stateToSave.plots.push({ id: newIndex, ...JSON.parse(JSON.stringify(defaultPlotStateForSave)) });
         }


        // 5. Validate Action History (chỉ lưu tối đa MAX_HISTORY_ENTRIES)
        if (!Array.isArray(stateToSave.actionHistory)) stateToSave.actionHistory = [];
        // Giữ lại các mục mới nhất nếu vượt quá giới hạn
        if (stateToSave.actionHistory.length > MAX_HISTORY_ENTRIES) {
            stateToSave.actionHistory = stateToSave.actionHistory.slice(0, MAX_HISTORY_ENTRIES);
        }
        // Lọc bỏ các entry không hợp lệ (thiếu timestamp hoặc không phải object)
        stateToSave.actionHistory = stateToSave.actionHistory.filter(entry => entry && typeof entry === 'object' && typeof entry.timestamp === 'number');

        // 6. Validate Weather Data and Timestamps
        // Đảm bảo currentWeather là một object hợp lệ từ WEATHER_DATA
        if (!stateToSave.currentWeather || typeof stateToSave.currentWeather !== 'object' || !WEATHER_DATA.some(w => w.id === stateToSave.currentWeather.id)) {
            console.warn("saveGame: Thời tiết không hợp lệ, đặt lại về mặc định.");
            // Lấy trạng thái mặc định từ defaultState đã định nghĩa ở loadGame (hoặc định nghĩa lại ở đây)
             const defaultWeather = WEATHER_DATA[0]; // Lấy cái đầu tiên làm mặc định
             stateToSave.currentWeather = JSON.parse(JSON.stringify(defaultWeather));
        }
        // Đảm bảo các timestamp là số dương hợp lệ
        stateToSave.nextWeatherChangeTimestamp = (typeof stateToSave.nextWeatherChangeTimestamp === 'number' && stateToSave.nextWeatherChangeTimestamp > 0) ? stateToSave.nextWeatherChangeTimestamp : now + WEATHER_CHANGE_INTERVAL_MS;
        stateToSave.currentWeatherStartTime = (typeof stateToSave.currentWeatherStartTime === 'number' && stateToSave.currentWeatherStartTime > 0) ? stateToSave.currentWeatherStartTime : stateToSave.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS;
         // Đảm bảo currentWeatherStartTime hợp lý so với nextWeatherChangeTimestamp
        if (stateToSave.currentWeatherStartTime > stateToSave.nextWeatherChangeTimestamp || stateToSave.currentWeatherStartTime <= 0) {
             stateToSave.currentWeatherStartTime = Math.max(1, stateToSave.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS);
        }
        stateToSave.nextDryCheckTimestamp = (typeof stateToSave.nextDryCheckTimestamp === 'number' && stateToSave.nextDryCheckTimestamp > 0) ? stateToSave.nextDryCheckTimestamp : now + (15 + Math.random() * 30) * 1000; // Lên lịch lại nếu không hợp lệ

        // 7. Validate Tornado Data (chỉ lưu active tornadoes chưa hết hạn)
        if (!Array.isArray(stateToSave.activeTornadoes)) stateToSave.activeTornadoes = [];
        const currentMaxPlotsSave = stateToSave.maxUnlockedPlots; // Dùng max plot đã validate
        stateToSave.activeTornadoes = stateToSave.activeTornadoes.filter(t =>
            t && typeof t === 'object' && // Đảm bảo là object
            typeof t.plotId === 'number' && t.plotId >= 0 && t.plotId < currentMaxPlotsSave &&
            typeof t.expireTimestamp === 'number' && t.expireTimestamp > now && // Chỉ lưu những cái chưa hết hạn tại thời điểm LƯU
            typeof t.isDestruction === 'boolean' &&
            typeof t.targetType === 'string' // Đảm bảo các trường cần thiết tồn tại và đúng kiểu
        );
        stateToSave.nextTornadoEventTimestamp = (typeof stateToSave.nextTornadoEventTimestamp === 'number' && stateToSave.nextTornadoEventTimestamp >= 0) ? stateToSave.nextTornadoEventTimestamp : 0; // Chỉ cần >= 0

        // 8. Validate Lightning Rods
        if (!Array.isArray(stateToSave.lightningRods)) {
            console.warn("saveGame: gameState.lightningRods không phải mảng, đặt lại thành rỗng.");
            stateToSave.lightningRods = [];
        } else {
            // Lọc bỏ dữ liệu không hợp lệ TRƯỚC KHI LƯU
            stateToSave.lightningRods = stateToSave.lightningRods.filter(rod =>
               rod && typeof rod === 'object' && // Đảm bảo là object
               typeof rod.plotId === 'number' && rod.plotId >= 0 && rod.plotId < currentMaxPlotsSave && // Dùng max plot đã validate
               typeof rod.health === 'number' && rod.health >= 0 && rod.health <= LIGHTNING_ROD_MAX_HEALTH &&
               typeof rod.repairCost === 'number' && rod.repairCost >= LIGHTNING_ROD_INITIAL_REPAIR_COST
            );
        }
		
		 // === [MỚI] VALIDATE VÀ LÀM SẠCH dailyQuests và lastQuestResetDate ===
           if (!Array.isArray(stateToSave.dailyQuests)) stateToSave.dailyQuests = [];
           // Lọc bỏ các quest không hợp lệ hoặc đã hoàn thành và nhận thưởng (tùy chọn, có thể giữ lại để hiển thị)
           stateToSave.dailyQuests = stateToSave.dailyQuests.filter(q => q && QUEST_TYPES[q.type?.toUpperCase()]).map(q => ({
               // Chỉ lưu các thuộc tính cần thiết
               type: q.type,
               description: q.description || 'N/A',
               targetItemId: q.targetItemId || null,
               targetQuantity: Math.max(1, parseInt(q.targetQuantity || 1)),
               rewardCurrency: Math.max(1, parseInt(q.rewardCurrency || 1)),
               currentProgress: Math.max(0, parseInt(q.currentProgress || 0)),
               isCompleted: !!q.isCompleted,
               isClaimed: !!q.isClaimed
           }));
           // Đảm bảo có đúng 10 quest, nếu không thì có lỗi -> có thể reset khi load
           if (stateToSave.dailyQuests.length > NUM_DAILY_QUESTS) {
               stateToSave.dailyQuests = stateToSave.dailyQuests.slice(0, NUM_DAILY_QUESTS);
           }

           // Validate date string format (đơn giản)
           const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
           if (typeof stateToSave.lastQuestResetDate !== 'string' || !dateRegex.test(stateToSave.lastQuestResetDate)) {
               console.warn("saveGame: lastQuestResetDate không hợp lệ, đặt thành null.");
               stateToSave.lastQuestResetDate = null; // Sẽ được reset khi load
           }
           // =============================================================
		

		// 9. Validate maxInventoryCapacity
stateToSave.maxInventoryCapacity = (typeof stateToSave.maxInventoryCapacity === 'number' && stateToSave.maxInventoryCapacity >= INITIAL_MAX_INVENTORY_CAPACITY)
                                 ? stateToSave.maxInventoryCapacity
                                 : INITIAL_MAX_INVENTORY_CAPACITY;



        // --- Chuyển đổi state đã làm sạch thành JSON ---
        const saveData = JSON.stringify(stateToSave);

        // --- Lưu vào localStorage ---
        localStorage.setItem(GAME_SAVE_KEY, saveData);

        // Lưu lịch sử hành động (riêng biệt - lấy từ gameState gốc vì nó đã được giới hạn khi thêm)
        try {
            // Lọc lại lịch sử một lần nữa trước khi lưu để đảm bảo không có lỗi
            const historyToSave = gameState.actionHistory.filter(entry => entry && typeof entry === 'object' && typeof entry.timestamp === 'number');
            const historyData = JSON.stringify(historyToSave);
            localStorage.setItem(HISTORY_SAVE_KEY, historyData);
        } catch (historyError) {
             console.error("Lỗi khi lưu lịch sử hành động:", historyError);
        }

        // console.log("Trạng thái game (đã validate và dọn dẹp) đã lưu.");

    } catch (error) {
        console.error("Lỗi nghiêm trọng khi lưu game:", error);
        showMessage("Lỗi: Không thể lưu game! Dữ liệu có thể không hợp lệ.", "error", MESSAGE_DISPLAY_TIME * 1.5);
    }
}


        /** Tải trạng thái game từ localStorage và thực hiện mô phỏng offline nếu cần. */
       function loadGame() {
    console.log(`Đang cố tải trạng thái game từ khóa: ${GAME_SAVE_KEY}`);
    let loadedState = null;
    const nowForLoad = Date.now();

    // --- Trạng thái mặc định đầy đủ (cho gameState) ---
    const defaultState = {
        currency: INITIAL_CURRENCY, plots: [], maxUnlockedPlots: INITIAL_PLOT_COUNT,
        inventory: { pesticide: INITIAL_PESTICIDE }, harvestedItems: {},
        lastUpdateTimestamp: nowForLoad, gameStartTime: nowForLoad, totalPlayTime: 0,
        actionHistory: [], currentWeather: WEATHER_DATA[0], // Mặc định là phần tử đầu tiên
        nextWeatherChangeTimestamp: nowForLoad + WEATHER_CHANGE_INTERVAL_MS,
        currentWeatherStartTime: nowForLoad,
        nextDryCheckTimestamp: nowForLoad + (15 + Math.random() * 30) * 1000,
        activeTornadoes: [], nextTornadoEventTimestamp: 0, lightningRods: [],
		maxInventoryCapacity: INITIAL_MAX_INVENTORY_CAPACITY,
    };
     const defaultPlotStateForLoad = {
        seedId: null, plantTime: null, hasPest: false, health: INITIAL_PLANT_HEALTH,
        fertility: BASE_FERTILITY, causeOfDeath: null, pestDeathClickCount: 0,
        barrenHarvestPenaltyFactor: 1.0, isDry: false
    };

    // --- Tải Trạng Thái Âm Thanh TỪ LOCALSTORAGE ---
    // Đọc giá trị đã lưu hoặc null nếu chưa có
    const savedMusicEnabled = localStorage.getItem(MUSIC_ENABLED_KEY);
    const savedEffectsEnabled = localStorage.getItem(EFFECTS_ENABLED_KEY);

    // Gán giá trị cho biến toàn cục isMusicEnabled
    // Nếu chưa có gì lưu (null), sử dụng giá trị mặc định là true (bật)
    // Nếu có giá trị lưu, chuyển đổi chuỗi 'true'/'false' thành boolean
    isMusicEnabled = (savedMusicEnabled === null) ? true : (savedMusicEnabled === 'true');

    // Gán giá trị cho biến toàn cục areEffectSoundsEnabled tương tự
    areEffectSoundsEnabled = (savedEffectsEnabled === null) ? true : (savedEffectsEnabled === 'true');

    // Log giá trị đã tải để kiểm tra
    console.log(`SOUND LOAD: Music Setting read from localStorage ('${savedMusicEnabled}') => isMusicEnabled = ${isMusicEnabled}`);
    console.log(`SOUND LOAD: Effects Setting read from localStorage ('${savedEffectsEnabled}') => areEffectSoundsEnabled = ${areEffectSoundsEnabled}`);
    // --- Kết thúc tải trạng thái âm thanh ---

    // --- Tải Trạng Thái Game Chính (gameState) ---
    try {
        const savedDataString = localStorage.getItem(GAME_SAVE_KEY);
        if (savedDataString) {
            loadedState = JSON.parse(savedDataString);
            console.log("Đã tìm thấy và phân tích dữ liệu game đã lưu.");

            // --- Hợp nhất trạng thái game cơ bản ---
            gameState.currency = (typeof loadedState.currency === 'number' && loadedState.currency >= 0) ? Math.floor(loadedState.currency) : defaultState.currency;
            gameState.maxUnlockedPlots = (typeof loadedState.maxUnlockedPlots === 'number' && loadedState.maxUnlockedPlots >= INITIAL_PLOT_COUNT) ? loadedState.maxUnlockedPlots : defaultState.maxUnlockedPlots;
            gameState.lastUpdateTimestamp = (typeof loadedState.lastUpdateTimestamp === 'number' && loadedState.lastUpdateTimestamp > 0) ? loadedState.lastUpdateTimestamp : defaultState.lastUpdateTimestamp;
            gameState.gameStartTime = (typeof loadedState.gameStartTime === 'number' && loadedState.gameStartTime > 0) ? loadedState.gameStartTime : defaultState.gameStartTime;
            gameState.totalPlayTime = (typeof loadedState.totalPlayTime === 'number' && loadedState.totalPlayTime >= 0) ? loadedState.totalPlayTime : defaultState.totalPlayTime;

			// <<< Tải maxInventoryCapacity >>>
gameState.maxInventoryCapacity = (typeof loadedState.maxInventoryCapacity === 'number' && loadedState.maxInventoryCapacity >= INITIAL_MAX_INVENTORY_CAPACITY)
                                 ? loadedState.maxInventoryCapacity
                                 : INITIAL_MAX_INVENTORY_CAPACITY;

            // --- Tải Inventory (Đã Mua) ---
            const loadedInventory = (typeof loadedState.inventory === 'object' && loadedState.inventory !== null) ? loadedState.inventory : {};
            gameState.inventory = {};
            for (const itemId in loadedInventory) {
                if (ITEM_DATA[itemId]) {
                    const quantity = parseInt(loadedInventory[itemId]);
                    if (!isNaN(quantity) && quantity > 0) gameState.inventory[itemId] = quantity;
                }
            }
            if (gameState.inventory.pesticide === undefined && ITEM_DATA['pesticide']) gameState.inventory.pesticide = 0;

             // --- Tải Harvested Items (Hỗ trợ định dạng cũ/mới) ---
             const loadedHarvested = (typeof loadedState.harvestedItems === 'object' && loadedState.harvestedItems !== null) ? loadedState.harvestedItems : {};
             gameState.harvestedItems = {};
             for (const itemId in loadedHarvested) {
                 if (ITEM_DATA[itemId] && ITEM_DATA[itemId].type === 'seed') {
                     const itemData = loadedHarvested[itemId];
                     // Định dạng MỚI
                     if (typeof itemData === 'object' && itemData !== null && (itemData.hasOwnProperty(QUALITY_TIERS.PERFECT) || /*...*/ itemData.hasOwnProperty(QUALITY_TIERS.POOR))) {
                         const newItemQualityData = {
                             [QUALITY_TIERS.PERFECT]: Math.max(0, parseInt(itemData[QUALITY_TIERS.PERFECT] || 0)),
                             [QUALITY_TIERS.GOOD]:    Math.max(0, parseInt(itemData[QUALITY_TIERS.GOOD] || 0)),
                             [QUALITY_TIERS.FAIR]:    Math.max(0, parseInt(itemData[QUALITY_TIERS.FAIR] || 0)),
                             [QUALITY_TIERS.POOR]:    Math.max(0, parseInt(itemData[QUALITY_TIERS.POOR] || 0))
                         };
                         const totalQtyCheck = Object.values(newItemQualityData).reduce((sum, count) => sum + count, 0);
                         if (totalQtyCheck > 0) gameState.harvestedItems[itemId] = newItemQualityData;
                     }
                     // Định dạng CŨ
                     else if (typeof itemData === 'number' || (typeof itemData === 'string' && !isNaN(parseInt(itemData)))) {
                         const quantity = parseInt(itemData);
                         if (!isNaN(quantity) && quantity > 0) {
                             console.warn(`loadGame: Chuyển đổi harvestedItem định dạng cũ ${itemId} (${quantity}) sang chất lượng "Thường".`);
                             gameState.harvestedItems[itemId] = { [QUALITY_TIERS.PERFECT]: 0, [QUALITY_TIERS.GOOD]: 0, [QUALITY_TIERS.FAIR]: quantity, [QUALITY_TIERS.POOR]: 0 };
                         }
                     }
                 }
             }

            // --- Tải plots ---
            const loadedPlots = Array.isArray(loadedState.plots) ? loadedState.plots : [];
            gameState.plots = [];
            const plotsToLoadCount = Math.min(loadedPlots.length, gameState.maxUnlockedPlots);
            console.log(`Sẽ tải dữ liệu cho ${plotsToLoadCount} ô đất.`);
            for (let i = 0; i < plotsToLoadCount; i++) {
                const savedPlot = loadedPlots[i] || {};
                const newPlot = { id: i, ...JSON.parse(JSON.stringify(defaultPlotStateForLoad)) };
                // Gán và validate từng thuộc tính plot (seedId, plantTime, hasPest, health, fertility, ...)
                newPlot.seedId = (savedPlot.seedId && ITEM_DATA[savedPlot.seedId]) ? savedPlot.seedId : null;
                newPlot.plantTime = (typeof savedPlot.plantTime === 'number' && savedPlot.plantTime > 0 && newPlot.seedId) ? savedPlot.plantTime : null;
                newPlot.hasPest = typeof savedPlot.hasPest === 'boolean' ? savedPlot.hasPest : false;
                newPlot.health = (typeof savedPlot.health === 'number') ? Math.max(0, Math.min(INITIAL_PLANT_HEALTH, savedPlot.health)) : INITIAL_PLANT_HEALTH;
                newPlot.fertility = (typeof savedPlot.fertility === 'number') ? Math.max(0, Math.min(BASE_FERTILITY, savedPlot.fertility)) : BASE_FERTILITY;
                newPlot.causeOfDeath = (typeof savedPlot.causeOfDeath === 'string' || savedPlot.causeOfDeath === null) ? savedPlot.causeOfDeath : null;
                newPlot.pestDeathClickCount = (typeof savedPlot.pestDeathClickCount === 'number' && savedPlot.pestDeathClickCount >= 0) ? savedPlot.pestDeathClickCount : 0;
                newPlot.barrenHarvestPenaltyFactor = (typeof savedPlot.barrenHarvestPenaltyFactor === 'number' && savedPlot.barrenHarvestPenaltyFactor >= 1.0) ? savedPlot.barrenHarvestPenaltyFactor : 1.0;
                newPlot.isDry = typeof savedPlot.isDry === 'boolean' ? savedPlot.isDry : false;
				
				  newPlot.fertilizerProtectUsageCount = (typeof savedPlot.fertilizerProtectUsageCount === 'number' && savedPlot.fertilizerProtectUsageCount >= 0) ? savedPlot.fertilizerProtectUsageCount : 0;
            // Load buff, đảm bảo nó chỉ bật nếu có cây sống và count > 0
            newPlot.hasFertilizerProtectBuff = (typeof savedPlot.hasFertilizerProtectBuff === 'boolean' && newPlot.seedId && newPlot.health > 0 && newPlot.fertilizerProtectUsageCount > 0) ? savedPlot.hasFertilizerProtectBuff : false;
				
				
				// Tải fertilizerGrowthUsageCount
             newPlot.fertilizerGrowthUsageCount = (typeof savedPlot.fertilizerGrowthUsageCount === 'number' && savedPlot.fertilizerGrowthUsageCount >= 0) ? savedPlot.fertilizerGrowthUsageCount : 0;
             //đã thêm/kết thúc cập nhật
				
				
				// <<< THÊM: Tải và validate fenceData >>>
            if (savedPlot.fenceData && savedPlot.fenceData.id === 'raobaove' && ITEM_DATA.raobaove) {
                 const fenceHealthLoad = parseInt(savedPlot.fenceData.health);
                 if (!isNaN(fenceHealthLoad) && fenceHealthLoad >= 0 && fenceHealthLoad <= ITEM_DATA.raobaove.health) {
                     newPlot.fenceData = { id: 'raobaove', health: fenceHealthLoad };
                 } else {
                      newPlot.fenceData = null;
                 }
            } else {
                 newPlot.fenceData = null;
            }
            // <<< KẾT THÚC: Tải fenceData >>>
				
				
                if (newPlot.seedId === null) { newPlot.plantTime = null; }
                gameState.plots[i] = newPlot;
            }
            // Đảm bảo đủ số ô
            while (gameState.plots.length < gameState.maxUnlockedPlots) {
                 const newIndex = gameState.plots.length;
                 console.warn(`loadGame: Thêm plot mặc định cho index ${newIndex} bị thiếu.`);
                 gameState.plots.push({ id: newIndex, ...JSON.parse(JSON.stringify(defaultPlotStateForLoad)) });
            }

            // --- Tải lịch sử hành động ---
            const savedHistoryString = localStorage.getItem(HISTORY_SAVE_KEY);
            if (savedHistoryString) {
                try {
                    gameState.actionHistory = JSON.parse(savedHistoryString);
                    if (!Array.isArray(gameState.actionHistory)) throw new Error("History is not an array");
                    // Giới hạn và lọc entry không hợp lệ
                    if (gameState.actionHistory.length > MAX_HISTORY_ENTRIES * 1.5) gameState.actionHistory = gameState.actionHistory.slice(0, MAX_HISTORY_ENTRIES);
                    gameState.actionHistory = gameState.actionHistory.filter(entry => entry && typeof entry === 'object' && typeof entry.timestamp === 'number');
                } catch (e) { gameState.actionHistory = []; console.warn("Lỗi parse lịch sử, reset.", e); }
            } else { gameState.actionHistory = []; }

            // --- Tải Thời Tiết, Timestamps, Tornadoes, Rods ---
            // Validate và gán currentWeather
            let weatherSet = false;
            if (typeof loadedState.currentWeather === 'object' && loadedState.currentWeather !== null && loadedState.currentWeather.id) {
                const foundWeather = WEATHER_DATA.find(data => data.id === loadedState.currentWeather.id);
                if (foundWeather) { gameState.currentWeather = JSON.parse(JSON.stringify(foundWeather)); weatherSet = true; }
            }
            if (!weatherSet) { gameState.currentWeather = JSON.parse(JSON.stringify(defaultState.currentWeather)); }
            // Validate và gán các timestamps
            gameState.nextWeatherChangeTimestamp = (typeof loadedState.nextWeatherChangeTimestamp === 'number' && loadedState.nextWeatherChangeTimestamp > 0) ? loadedState.nextWeatherChangeTimestamp : defaultState.nextWeatherChangeTimestamp;
            gameState.currentWeatherStartTime = (typeof loadedState.currentWeatherStartTime === 'number' && loadedState.currentWeatherStartTime > 0) ? loadedState.currentWeatherStartTime : defaultState.currentWeatherStartTime;
            // Điều chỉnh startTime nếu không hợp lệ
            if (gameState.currentWeatherStartTime > gameState.nextWeatherChangeTimestamp || gameState.currentWeatherStartTime < gameState.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS - 10000) {
                gameState.currentWeatherStartTime = Math.max(1, gameState.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS);
            }
            // Tua nhanh nextWeatherChangeTimestamp nếu đã qua
            if(gameState.nextWeatherChangeTimestamp <= gameState.lastUpdateTimestamp){
                 const cyclesPassed = Math.floor((gameState.lastUpdateTimestamp - gameState.nextWeatherChangeTimestamp) / WEATHER_CHANGE_INTERVAL_MS) + 1;
                 gameState.nextWeatherChangeTimestamp += cyclesPassed * WEATHER_CHANGE_INTERVAL_MS;
                 gameState.currentWeatherStartTime = gameState.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS;
            }
            gameState.nextDryCheckTimestamp = (typeof loadedState.nextDryCheckTimestamp === 'number' && loadedState.nextDryCheckTimestamp > gameState.lastUpdateTimestamp)
                 ? loadedState.nextDryCheckTimestamp : gameState.lastUpdateTimestamp + (15 + Math.random() * 30) * 1000;
            // Validate activeTornadoes
            gameState.activeTornadoes = Array.isArray(loadedState.activeTornadoes) ? loadedState.activeTornadoes : [];
            const currentMaxPlotsTornadoLoad = gameState.maxUnlockedPlots;
            gameState.activeTornadoes = gameState.activeTornadoes.filter(t => t && typeof t.plotId === 'number' && t.plotId >= 0 && t.plotId < currentMaxPlotsTornadoLoad && typeof t.expireTimestamp === 'number' && t.expireTimestamp > nowForLoad && typeof t.isDestruction === 'boolean' && typeof t.targetType === 'string');
            gameState.nextTornadoEventTimestamp = (typeof loadedState.nextTornadoEventTimestamp === 'number' && loadedState.nextTornadoEventTimestamp >= 0) ? loadedState.nextTornadoEventTimestamp : 0;
            // Validate lightningRods
            gameState.lightningRods = Array.isArray(loadedState.lightningRods) ? loadedState.lightningRods : [];
            const currentMaxPlotsRodLoad = gameState.maxUnlockedPlots;
            gameState.lightningRods = gameState.lightningRods.filter(rod => rod && typeof rod.plotId === 'number' && rod.plotId >= 0 && rod.plotId < currentMaxPlotsRodLoad && typeof rod.health === 'number' && rod.health >= 0 && rod.health <= LIGHTNING_ROD_MAX_HEALTH && typeof rod.repairCost === 'number' && rod.repairCost >= LIGHTNING_ROD_INITIAL_REPAIR_COST);

			// === TẢI VÀ KIỂM TRA NHIỆM VỤ HẰNG NGÀY ===
            const loadedQuests = Array.isArray(loadedState.dailyQuests) ? loadedState.dailyQuests : [];
            const loadedResetDate = typeof loadedState.lastQuestResetDate === 'string' ? loadedState.lastQuestResetDate : null;
            const currentDateStr = getCurrentDateString();

            if (loadedResetDate !== currentDateStr || loadedQuests.length !== NUM_DAILY_QUESTS) {
                // Nếu ngày khác HOẶC số lượng quest không đúng -> Tạo mới
                console.log(`Quest reset needed. Saved date: ${loadedResetDate}, Current date: ${currentDateStr}, Quest count: ${loadedQuests.length}`);
                generateDailyQuests(); // Hàm này sẽ cập nhật gameState.dailyQuests và gameState.lastQuestResetDate
            } else {
                // Ngày giống nhau và số lượng đúng -> Sử dụng quest đã tải
                console.log(`Quests are up-to-date for ${currentDateStr}. Loading saved quests.`);
                // Validate từng quest đã tải (phòng lỗi)
                gameState.dailyQuests = loadedQuests.filter(q => q && QUEST_TYPES[q.type?.toUpperCase()]).map(q => ({
                    ...q, // Giữ lại các thuộc tính
                    currentProgress: Math.max(0, parseInt(q.currentProgress || 0)),
                    targetQuantity: Math.max(1, parseInt(q.targetQuantity || 1)),
                    rewardCurrency: Math.max(1, parseInt(q.rewardCurrency || 1)),
                    isCompleted: !!q.isCompleted, // Đảm bảo là boolean
                    isClaimed: !!q.isClaimed      // Đảm bảo là boolean
                }));
                 // Nếu sau khi lọc không đủ 10 quest, tạo lại từ đầu
                 if(gameState.dailyQuests.length < NUM_DAILY_QUESTS) {
                    console.warn("Số lượng quest hợp lệ sau khi load ít hơn mong đợi, đang tạo lại...");
                    generateDailyQuests();
                 } else {
                     gameState.lastQuestResetDate = loadedResetDate; // Giữ ngày đã lưu
                 }
            }
            // ==================================================




            // --- Mô phỏng Tiến trình Offline ---
            const timeDiff = nowForLoad - gameState.lastUpdateTimestamp;
            let stateChangedByOfflineSim = false;
            if (timeDiff > TICK_INTERVAL * 1.5 && gameState.lastUpdateTimestamp > 0) {
                console.log(`Phát hiện thời gian offline: ${formatTime(timeDiff)}. Bắt đầu mô phỏng.`);
                gameState.totalPlayTime += timeDiff; // Cộng dồn thời gian offline
                stateChangedByOfflineSim = simulateOfflineProgress(gameState.lastUpdateTimestamp, nowForLoad);
                gameState.lastUpdateTimestamp = nowForLoad; // Cập nhật lại timestamp sau mô phỏng
            } else { // Thời gian offline ngắn hoặc lần đầu chơi
                 if (timeDiff > 0 && gameState.lastUpdateTimestamp > 0) gameState.totalPlayTime += timeDiff;
                 gameState.lastUpdateTimestamp = nowForLoad; // Cập nhật timestamp
            }

            // --- Cập nhật lại các timers nếu cần sau mô phỏng ---
            if (gameState.nextDryCheckTimestamp <= nowForLoad) { gameState.nextDryCheckTimestamp = nowForLoad + (15 + Math.random() * 30) * 1000; }
            if (gameState.currentWeather.id === 'windy' && gameState.nextTornadoEventTimestamp <= nowForLoad) {
                 const nextInterval = TORNADO_EVENT_MIN_INTERVAL_MS_WINDY + Math.random() * (TORNADO_EVENT_MAX_INTERVAL_MS_WINDY - TORNADO_EVENT_MIN_INTERVAL_MS_WINDY);
                 gameState.nextTornadoEventTimestamp = nowForLoad + nextInterval;
            }
            const tornadoesBeforeFinalFilter = gameState.activeTornadoes.length;
            gameState.activeTornadoes = gameState.activeTornadoes.filter(t => t.expireTimestamp > nowForLoad);
            if (gameState.activeTornadoes.length < tornadoesBeforeFinalFilter) stateChangedByOfflineSim = true;

            if (stateChangedByOfflineSim || weatherUpdateNeeded) {
                 weatherUpdateNeeded = true; // Đánh dấu cần cập nhật UI thời tiết
            }

        } else { // Không tìm thấy save game chính
            console.log("Không tìm thấy dữ liệu game đã lưu. Bắt đầu game mới.");
            gameState = JSON.parse(JSON.stringify(defaultState)); // Sử dụng default state
            gameState.lastUpdateTimestamp = nowForLoad; gameState.gameStartTime = nowForLoad; // Cập nhật timestamp
            gameState.nextWeatherChangeTimestamp = nowForLoad + WEATHER_CHANGE_INTERVAL_MS; gameState.currentWeatherStartTime = nowForLoad;
            gameState.nextDryCheckTimestamp = nowForLoad + (15 + Math.random() * 30) * 1000;
            localStorage.removeItem(HISTORY_SAVE_KEY); // Xóa lịch sử cũ nếu có
            weatherUpdateNeeded = true; // Cần cập nhật UI thời tiết lần đầu
        }
    } catch (error) { // Lỗi khi parse hoặc xử lý save game chính
        console.error("Lỗi nghiêm trọng khi phân tích hoặc xử lý trạng thái game đã lưu:", error);
        showMessage("Dữ liệu lưu của game bị lỗi. Bắt đầu game mới.", "error", MESSAGE_DISPLAY_TIME * 2);
        localStorage.removeItem(GAME_SAVE_KEY); localStorage.removeItem(HISTORY_SAVE_KEY); // Xóa dữ liệu lỗi
        gameState = JSON.parse(JSON.stringify(defaultState)); // Reset về mặc định
        // Cập nhật timestamp cho game mới
        gameState.lastUpdateTimestamp = nowForLoad; gameState.gameStartTime = nowForLoad;
        gameState.nextWeatherChangeTimestamp = nowForLoad + WEATHER_CHANGE_INTERVAL_MS; gameState.currentWeatherStartTime = nowForLoad;
        gameState.nextDryCheckTimestamp = nowForLoad + (15 + Math.random() * 30) * 1000;
        weatherUpdateNeeded = true;
    }
    console.log("Quá trình tải game hoàn tất.");
} // --- Kết thúc hàm loadGame ---
		// Cập nhật: Mô phỏng thời tiết dùng object (id, icon, name)
/**
 * Mô phỏng tiến trình game trong khoảng thời gian offline (từ startTime đến endTime).
 * Cập nhật trạng thái thời tiết và các ô đất.
 * @param {number} startTime - Timestamp (ms) bắt đầu khoảng thời gian offline.
 * @param {number} endTime - Timestamp (ms) kết thúc khoảng thời gian offline (thời điểm load).
 * @returns {boolean} True nếu trạng thái game (thời tiết hoặc ô đất) có thay đổi, False nếu không.
 */

        /** [Đơn Giản Hóa Req 3] Mô phỏng tiến trình game trong khoảng thời gian offline */
       function simulateOfflineProgress(startTime, endTime) {
            const durationMs = endTime - startTime;
            const missedTicks = Math.floor(durationMs / TICK_INTERVAL);
            if (missedTicks <= 0) return false;

            console.log(`Đang mô phỏng ${missedTicks} tick (${formatTime(durationMs)}) đã bị bỏ lỡ.`);
            let stateChanged = false;
            let weatherChangedDuringSim = false;

            // --- 1. Mô phỏng THỜI TIẾT trước ---
            let simWeatherObject = JSON.parse(JSON.stringify(gameState.currentWeather));
            let simNextWeatherChange = gameState.nextWeatherChangeTimestamp;
            let simWeatherStartTime = gameState.currentWeatherStartTime;
            let finalSimWeatherObject = simWeatherObject; // Thời tiết cuối cùng sau mô phỏng

            // Tua nhanh thời tiết nếu cần
            while (simNextWeatherChange < endTime) {
                const previousWeatherIdSim = simWeatherObject.id;
                let candidateWeather;
                do { candidateWeather = WEATHER_DATA[Math.floor(Math.random() * WEATHER_DATA.length)]; }
                while (candidateWeather.id === previousWeatherIdSim && WEATHER_DATA.length > 1); // Tránh lặp lại thời tiết cũ ngay lập tức
                simWeatherObject = candidateWeather;
                simWeatherStartTime = simNextWeatherChange; // Thời điểm bắt đầu của chu kỳ thời tiết mới này
                simNextWeatherChange += WEATHER_CHANGE_INTERVAL_MS; // Thời điểm kết thúc chu kỳ mới
                weatherChangedDuringSim = true; // Đánh dấu thời tiết đã thay đổi
                finalSimWeatherObject = simWeatherObject; // Lưu lại thời tiết cuối cùng
                console.log(`(Sim Offline) Thời tiết đổi thành ${simWeatherObject.name || simWeatherObject.icon} (ID: ${simWeatherObject.id}) vào lúc mô phỏng ${formatTime(simWeatherStartTime - gameState.gameStartTime)}`);

                // Nếu thời tiết đổi thành mưa -> Làm hết khô các ô đang khô
                const rainyWeatherIdsForDrynessSim = ['rainy', 'thunderstorm', 'rainy_sunny'];
                if (rainyWeatherIdsForDrynessSim.includes(simWeatherObject.id)) {
                    for (let k = 0; k < gameState.maxUnlockedPlots; k++) {
                        if (gameState.plots[k]?.isDry) {
                            gameState.plots[k].isDry = false;
                            stateChanged = true; // Đánh dấu có thay đổi trạng thái plot
                            // console.log(`(Sim Offline) Plot ${k} hết khô do thời tiết đổi thành mưa.`);
                        }
                    }
                }
            }
            // Cập nhật gameState với thời tiết cuối cùng sau mô phỏng
            gameState.currentWeather = JSON.parse(JSON.stringify(finalSimWeatherObject));
            gameState.nextWeatherChangeTimestamp = simNextWeatherChange;
            gameState.currentWeatherStartTime = simWeatherStartTime;
            if(weatherChangedDuringSim) weatherUpdateNeeded = true; // Đánh dấu cần cập nhật UI thời tiết khi load xong

            // --- 2. Mô phỏng Ô ĐẤT ---
            const p_no_pest_tick = 1 - PEST_APPEARANCE_CHANCE_PER_TICK_PER_PLOT;
            const p_no_pest_total = Math.pow(p_no_pest_tick, missedTicks);
            const p_get_pest_total = 1 - p_no_pest_total; // Xác suất bị sâu ít nhất 1 lần
            let plotStateChanged = false; // Cờ riêng cho plot

            // --- TÍNH TOÁN KHẢ NĂNG XẢY RA TORNADO OFFLINE ---
            let tornadoEventsOccurredOffline = 0;
            let offlineWindyDuration = 0;
            // Chỉ tính nếu thời tiết *cuối cùng* là Windy
            if (finalSimWeatherObject.id === 'windy') {
                // Tính thời gian thực sự ở trạng thái Windy trong khoảng offline
                const lastWindyStartTime = simWeatherStartTime > startTime ? simWeatherStartTime : startTime;
                offlineWindyDuration = endTime - lastWindyStartTime;
                if (offlineWindyDuration > 0) {
                    const avgTornadoInterval = (TORNADO_EVENT_MIN_INTERVAL_MS_WINDY + TORNADO_EVENT_MAX_INTERVAL_MS_WINDY) / 2;
                    const expectedTornadoEvents = offlineWindyDuration / avgTornadoInterval;
                    // Làm tròn ngẫu nhiên dựa trên phần thập phân
                    tornadoEventsOccurredOffline = Math.floor(expectedTornadoEvents) + (Math.random() < (expectedTornadoEvents % 1) ? 1 : 0);
                    if (tornadoEventsOccurredOffline > 0) {
                         console.log(`(Sim Offline) Ước tính ${tornadoEventsOccurredOffline} sự kiện tornado đã xảy ra trong ${formatTime(offlineWindyDuration)} offline (Weather: ${finalSimWeatherObject.id}).`);
                         plotStateChanged = true; // Có khả năng plot thay đổi
                    }
                }
            }
            // -----------------------------------------------------

            // --- Vòng lặp qua từng ô đất để mô phỏng ---
            for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                let plot = gameState.plots[i];
                let plotChangedThisSim = false; // Cờ thay đổi cho riêng ô này
                if (!plot) continue; // Bỏ qua nếu ô không có dữ liệu

                // --- ÁP DỤNG TÁC ĐỘNG TORNADO OFFLINE TRƯỚC ---
                let hitByOfflineTornado = false;
                 // Chỉ xét nếu có sự kiện tornado xảy ra VÀ ô không có cột thu lôi
                if (tornadoEventsOccurredOffline > 0 && !isPlotWithRod(i)) {
                    const avgPlotsPerEvent = Math.max(1, Math.min(gameState.maxUnlockedPlots, 5)); // Số plot trung bình mỗi event
                    const chancePerEvent = avgPlotsPerEvent / Math.max(1, gameState.maxUnlockedPlots); // Xác suất trúng mỗi event
                    const probNotHit = Math.pow(1 - chancePerEvent, tornadoEventsOccurredOffline); // Xác suất KHÔNG bị trúng
                    const probHitAtLeastOnce = 1 - probNotHit; // Xác suất bị trúng ÍT NHẤT 1 lần

                    // Nếu ô này được tính là bị đánh trúng
                    if (Math.random() < probHitAtLeastOnce) {
                        hitByOfflineTornado = true;
                        console.log(`(Sim Offline) Plot ${i} ước tính bị tornado đánh trúng.`);
                        let fenceTookHitSim = false; // Cờ xem rào có hứng chịu không

                        // >>> KIỂM TRA HÀNG RÀO TRƯỚC <<<
                        if (plot.fenceData && plot.fenceData.health > 0 && ITEM_DATA.raobaove) {
                            fenceTookHitSim = true; // Rào sẽ hứng chịu
                            const fenceMaxHealthSim = ITEM_DATA.raobaove.health;
                            // Quyết định loại sát thương *một lần* cho toàn bộ thời gian offline (ước tính)
                            const isDestructionOffline = Math.random() < TORNADO_DESTRUCTION_CHANCE;

                            console.log(` -> (Sim Offline) Hàng rào ô ${i} hứng chịu. Loại sự kiện ước tính: ${isDestructionOffline ? 'Phá hủy' : 'Thiệt hại nặng'}.`);

                            let fenceDamageSim = 0;
                            if (isDestructionOffline) {
                                fenceDamageSim = plot.fenceData.health; // Phá hủy hoàn toàn máu còn lại
                            } else {
                                // Ước tính thiệt hại % máu còn lại
                                fenceDamageSim = plot.fenceData.health * TORNADO_PARTIAL_DAMAGE_FACTOR;
                            }

                            const oldFenceHealthSim = plot.fenceData.health;
                            plot.fenceData.health = Math.max(0, plot.fenceData.health - fenceDamageSim); // Trừ máu rào
                            console.log(`(Sim Offline) Máu rào ô ${i} giảm từ ${oldFenceHealthSim.toFixed(0)} xuống ${plot.fenceData.health.toFixed(0)}.`);
                            if (plot.fenceData.health === 0 && oldFenceHealthSim > 0) {
                                console.warn(`(Sim Offline) Rào bảo vệ ở ô ${i} ước tính bị phá hủy!`);
                                logAction('fence_broken', i, `Rào bảo vệ ô ${i + 1} ước tính bị gió lốc phá hỏng (offline).`, '💥🚧', 'raobaove');
                            }
                            plotChangedThisSim = true; // Đánh dấu plot này đã thay đổi
                        }
                        // >>> KẾT THÚC KIỂM TRA HÀNG RÀO <<<

                        // >>> CHỈ TẤN CÔNG CÂY/ĐẤT NẾU HÀNG RÀO KHÔNG HỨNG CHỊU <<<
                        if (!fenceTookHitSim) {
                            const isDestructionOffline = Math.random() < TORNADO_DESTRUCTION_CHANCE; // Quyết định lại nếu rào không chịu
                            const plantNameSim = plot.seedId ? ITEM_DATA[plot.seedId]?.name : "Đất";
                            console.log(` -> (Sim Offline) Cây/Đất ô ${i} chịu sát thương. Loại sự kiện ước tính: ${isDestructionOffline ? 'Phá hủy' : 'Thiệt hại nặng'}.`);

                            if (isDestructionOffline) {
                                // Logic phá hủy cây/đất (áp dụng một lần cho toàn bộ thời gian offline)
                                if (plot.seedId && plot.health > 0) {
                                    const oldH = plot.health;
                                    plot.health = 0; plot.causeOfDeath = 'tornado';
                                    plot.hasPest = false; plot.isDry = false; plot.pestDeathClickCount = 0;
                                    if (plot.health !== oldH) plotChangedThisSim = true;
                                    console.warn(`(Sim Offline) ${plantNameSim} ở ô ${i} ước tính bị hủy diệt.`);
                                    logAction('plant_death', i, `${plantNameSim} ô ${i+1} chết do gió lốc (offline).`, '💀🌪️', plot.seedId);
                                } else if (!plot.seedId && plot.fertility > 0) {
                                    const oldF = plot.fertility;
                                    plot.fertility = 0; plot.barrenHarvestPenaltyFactor = 1.0; plot.isDry = false;
                                    if (plot.fertility !== oldF) plotChangedThisSim = true;
                                    console.log(`(Sim Offline) Đất trống ô ${i} ước tính thành cằn cỗi.`);
                                    logAction('soil_barren', i, `Đất ô ${i+1} thành cằn do gió lốc (offline).`, '🧱🌪️', null);
                                }
                            } else { // Thiệt hại một phần
                                // Logic thiệt hại một phần cây/đất (áp dụng một lần)
                                if (plot.seedId && plot.health > 0) {
                                    const damage = plot.health * TORNADO_PARTIAL_DAMAGE_FACTOR;
                                    const oldHealthSim = plot.health;
                                    plot.health = Math.max(0, plot.health - damage); // Trừ % máu hiện tại
                                    if (plot.health !== oldHealthSim) plotChangedThisSim = true;
                                    console.log(`(Sim Offline) ${plantNameSim} ở ô ${i} mất ${damage.toFixed(0)} HP.`);
                                    if (plot.health === 0 && oldHealthSim > 0) {
                                        plot.causeOfDeath = 'tornado';
                                        plot.hasPest = false; plot.isDry = false; plot.pestDeathClickCount = 0;
                                        console.warn(`(Sim Offline) ${plantNameSim} ở ô ${i} ước tính chết do thiệt hại nặng.`);
                                        logAction('plant_death', i, `${plantNameSim} ô ${i+1} chết do thiệt hại gió lốc (offline).`, '💀🌪️', plot.seedId);
                                    }
                                } else if (!plot.seedId && plot.fertility > 0) {
                                    const damage = plot.fertility * TORNADO_PARTIAL_DAMAGE_FACTOR;
                                    const oldFertilitySim = plot.fertility;
                                    plot.fertility = Math.max(0, plot.fertility - damage); // Trừ % độ phì hiện tại
                                    if (plot.fertility !== oldFertilitySim) plotChangedThisSim = true;
                                    console.log(`(Sim Offline) Đất ô ${i} mất ${damage.toFixed(0)}% độ phì.`);
                                    if (plot.fertility === 0 && oldFertilitySim > 0) {
                                        plot.barrenHarvestPenaltyFactor = 1.0; plot.isDry = false;
                                        console.log(`(Sim Offline) Đất ô ${i} ước tính thành cằn cỗi do thiệt hại nặng.`);
                                        logAction('soil_barren', i, `Đất ô ${i+1} thành cằn do thiệt hại gió lốc (offline).`, '🧱🌪️', null);
                                    }
                                }
                            }
                        }
                        // >>> KẾT THÚC TẤN CÔNG CÂY/ĐẤT <<<
                    } // end if (Math.random() < probHitAtLeastOnce)
                } // end if (tornadoEventsOccurredOffline > 0)

                // Nếu đã bị tornado offline, bỏ qua các xử lý khác cho ô này
                if (hitByOfflineTornado) {
                    if (plotChangedThisSim) plotStateChanged = true; // Cập nhật cờ chung nếu plot này thay đổi
                    continue; // <<<< QUAN TRỌNG: Chuyển sang ô tiếp theo
                }
                // --- Kết thúc xử lý Tornado Offline ---

                // --- Mô phỏng KHÔ HẠN (dựa trên thời tiết cuối - finalSimWeatherObject) ---
                let becameDryOffline = false;
                // Chỉ bị khô nếu thời tiết cuối là nắng VÀ ô chưa khô
                if (finalSimWeatherObject.id === 'sunny' && !plot.isDry) {
                    // Xác suất bị khô tăng theo thời gian offline (giới hạn ở 90%)
                    const dryChanceOffline = Math.min(0.9, 0.0001 * missedTicks); // Điều chỉnh 0.0001 nếu cần
                    if (Math.random() < dryChanceOffline) {
                        plot.isDry = true; becameDryOffline = true; plotChangedThisSim = true;
                        // console.log(`(Sim Offline) Plot ${i} được tính là đã bị khô do nắng.`);
                    }
                }
                // Nếu thời tiết cuối là mưa VÀ ô đang khô -> hết khô
                const rainyWeatherIdsForDrynessSim = ['rainy', 'thunderstorm', 'rainy_sunny'];
                if (rainyWeatherIdsForDrynessSim.includes(finalSimWeatherObject.id) && plot.isDry) {
                    plot.isDry = false; plotChangedThisSim = true;
                    // console.log(`(Sim Offline) Plot ${i} được tính là đã hết khô do mưa.`);
                }

                // --- Mô phỏng cây trồng (chỉ chạy nếu không bị tornado) ---
                if (plot.seedId && plot.plantTime) {
                    const seedInfo = ITEM_DATA[plot.seedId];
                    if (!seedInfo) continue; // Bỏ qua nếu dữ liệu hạt giống lỗi

                    // Tính toán tiến trình và trạng thái trưởng thành CUỐI CÙNG
                    const effectiveGrowthTimeSec = getEffectiveGrowthTime(plot);
                    const totalGrowthTimeMs = effectiveGrowthTimeSec * 1000;
                    const finalElapsedTime = endTime - plot.plantTime;
                    const finalGrowthProgress = totalGrowthTimeMs > 0 ? Math.min(1, finalElapsedTime / totalGrowthTimeMs) : 1;
                    const isMatureEstimate = finalGrowthProgress >= 1.0 - 0.0001;

                    // Mô phỏng sâu xuất hiện
                    let pestAppearedOffline = false;
                    const noPestWeatherIdsSim = ['sunny', 'cloudy', 'windy', 'lightning']; // Thời tiết không có sâu
                    // Chỉ xuất hiện nếu thời tiết cuối không nằm trong danh sách noPest, cây còn sống, chưa có sâu
                    if (!noPestWeatherIdsSim.includes(finalSimWeatherObject.id) && plot.health > 0 && !plot.hasPest) {
                        // Xác suất bị sâu tăng theo thời gian offline
                        if (Math.random() < p_get_pest_total) {
                            plot.hasPest = true; pestAppearedOffline = true; plotChangedThisSim = true;
                            console.log(`(Sim Offline) Sâu được tính là đã xuất hiện trên ô ${i} (${seedInfo.name}).`);
                            logAction('pest_appear_offline', i, `Sâu xuất hiện trên ${seedInfo.name} (offline).`, '🐛<0xF0><0x9F><0xAA><0xB2>', seedInfo.id);
                        }
                    }

                    // Mô phỏng sát thương sâu (nếu cây đang có sâu)
                    if (plot.hasPest && plot.health > 0) {
                        // Số tick bị sâu tấn công (ước tính bằng 1/2 nếu sâu vừa xuất hiện offline)
                        let damageTicks = pestAppearedOffline ? Math.floor(missedTicks / 2) : missedTicks;
                        // Sát thương mỗi tick (giảm nếu cây trưởng thành)
                        let damagePerTickSim = PEST_DAMAGE_PER_TICK * (isMatureEstimate ? PEST_DAMAGE_MATURE_REDUCTION_FACTOR : 1);
                        let totalDamageSim = damagePerTickSim * damageTicks; // Tổng sát thương ước tính
                        const oldHealth = plot.health;

                        // Giảm máu, nhưng không để chết hoàn toàn (tránh trường hợp chết hàng loạt quá dễ)
                        // Đặt máu về một mức ngẫu nhiên thấp nếu sát thương làm chết
                        const potentialHpAfterDamage = plot.health - totalDamageSim;
                        if (potentialHpAfterDamage <= 0) {
                            // Máu ngẫu nhiên từ 1 đến 20
                            plot.health = 1 + Math.random() * 19;
                            console.warn(`(Sim Offline) Ô ${i} (${seedInfo.name}) máu rất thấp do sâu (ước tính ${plot.health.toFixed(0)} HP).`);
                        } else {
                            plot.health = potentialHpAfterDamage;
                        }
                        // Đảm bảo máu không vượt quá giới hạn
                        plot.health = Math.max(1, Math.min(INITIAL_PLANT_HEALTH, plot.health));

                        if (plot.health !== oldHealth) { plotChangedThisSim = true; }
                    }

                    // Mô phỏng hồi máu (nếu không sâu, chưa max máu, không khô)
                    if (!plot.hasPest && plot.health > 0 && plot.health < INITIAL_PLANT_HEALTH && !plot.isDry) {
                        const totalRegen = HEALTH_REGEN_PER_TICK * missedTicks;
                        const oldHealth = plot.health;
                        plot.health = Math.min(INITIAL_PLANT_HEALTH, plot.health + totalRegen);
                        if (plot.health !== oldHealth) plotChangedThisSim = true;
                    }

                    // Mô phỏng giảm máu/chết do KHÔ HẠN (nếu đang khô)
                    if (plot.isDry && plot.health > 0) {
                        let changedByDrynessSim = false;
                        const healthDrainSim = DRY_HEALTH_DRAIN_PER_TICK * missedTicks;
                        const oldHealthSim = plot.health;
                        plot.health = Math.max(0, plot.health - healthDrainSim); // Giảm máu do khô
                        if (plot.health === 0 && oldHealthSim > 0) { // Nếu chết do khô
                            plot.causeOfDeath = 'dryness'; // Đặt nguyên nhân chết
                            plot.hasPest = false;         // Sâu biến mất
                            plot.isDry = false;           // Hết khô khi chết
                            console.warn(`(Sim Offline) Ô ${i} (${seedInfo.name}) được tính là CHẾT vì khô hạn.`);
                            logAction('plant_death', i, `${seedInfo.name} ô ${i+1} chết do khô hạn (offline).`, '💀🏜️', seedInfo.id);
                            changedByDrynessSim = true;
                        } else if (plot.health !== oldHealthSim) { // Nếu chỉ giảm máu
                            changedByDrynessSim = true;
                        }
                        if(changedByDrynessSim) plotChangedThisSim = true; // Đánh dấu plot thay đổi
                    }

                    // Mô phỏng giảm độ phì nhiêu do cây lớn (chỉ khi cây đang lớn)
                    if (!isMatureEstimate && plot.health > 0 && seedInfo.fertilityCost > 0 && seedInfo.growthTime > 0 && plot.fertility > 0) {
                        const baseGrowthTime = seedInfo.growthTime;
                        // Tính lượng phì giảm mỗi tick khi cây lớn
                        const fertilityDecreasePerTick = (seedInfo.fertilityCost * BASE_FERTILITY) / baseGrowthTime;
                        const totalFertilityDecrease = fertilityDecreasePerTick * missedTicks; // Tổng lượng giảm
                        if (totalFertilityDecrease > 0) {
                            const oldFertility = plot.fertility;
                            plot.fertility = Math.max(0, plot.fertility - totalFertilityDecrease); // Giảm độ phì
                            if (plot.fertility !== oldFertility) plotChangedThisSim = true; // Đánh dấu thay đổi
                            // Xử lý nếu đất thành cằn do cây lớn
                            if (oldFertility > 0 && plot.fertility <= 0) {
                                plot.barrenHarvestPenaltyFactor = 1.0; // Reset penalty
                                console.log(`(Sim Offline) Plot ${i} became barren due to plant growth.`);
                            }
                        }
                    }

                    // Kiểm tra xem cây có trưởng thành trong thời gian offline không
                    // Chỉ kiểm tra nếu cây còn sống và không có sâu
                    if (plot.health > 0 && !plot.hasPest) {
                        const stageInfoBefore = getPlantStageInfo(plot, startTime); // Trạng thái trước offline
                        // Nếu trước đó chưa trưởng thành VÀ bây giờ đã trưởng thành
                        if (stageInfoBefore && !stageInfoBefore.isMature && isMatureEstimate) {
                            console.log(`(Sim Offline) Ô ${plot.id} (${seedInfo.name}) được tính là đã trưởng thành.`);
                            plotChangedThisSim = true; // Đánh dấu thay đổi
                        }
                    }

                } else if (plot.isDry && !plot.seedId && plot.fertility > 0) { // Đất trống bị khô
                    const fertilityDrainSim = DRY_FERTILITY_DRAIN_PER_TICK * missedTicks; // Lượng phì mất
                    const oldFertilitySim = plot.fertility;
                    plot.fertility = Math.max(0, plot.fertility - fertilityDrainSim); // Giảm độ phì
                    if (plot.fertility !== oldFertilitySim) { // Nếu có thay đổi
                        plotChangedThisSim = true;
                        // Nếu đất thành cằn do khô hạn
                        if(plot.fertility === 0 && oldFertilitySim > 0) {
                            plot.barrenHarvestPenaltyFactor = 1.0; // Reset penalty
                            console.log(`(Sim Offline) Plot ${i} (trống) trở nên cằn cỗi do khô hạn.`);
                        }
                    }
                }

                // --- Cập nhật cờ trạng thái chung ---
                if(plotChangedThisSim) plotStateChanged = true; // Cập nhật cờ chung nếu plot này thay đổi

            } // Kết thúc vòng lặp for các ô đất

            // --- Mô phỏng Tăng Phì Nhiêu Do Thời Tiết Mưa ---
            const fertilityBoostingWeatherIdsSim = ['rainy', 'thunderstorm', 'rainy_sunny'];
            // Chỉ tăng nếu thời tiết *cuối cùng* là mưa
            if (fertilityBoostingWeatherIdsSim.includes(finalSimWeatherObject.id)) {
                // Thời điểm bắt đầu của chu kỳ mưa cuối cùng trong khoảng offline
                const lastRainStartTime = simWeatherStartTime > startTime ? simWeatherStartTime : startTime;
                const rainDurationMs = endTime - lastRainStartTime; // Thời gian mưa trong khoảng offline
                const numberOfRainBoosts = Math.floor(rainDurationMs / 15000); // Số lần boost (1% mỗi 15s)
                if (numberOfRainBoosts > 0) {
                    console.log(`(Sim Offline) Applying ${numberOfRainBoosts} fertility boosts (Weather: ${finalSimWeatherObject.id}).`);
                    let rainBoostChangedStateSim = false; // Cờ xem có thay đổi không
                    for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                         let plot = gameState.plots[i];
                         // Bỏ qua nếu ô đã bị hủy diệt bởi tornado offline hoặc có rod
                         let wasDestroyedByOfflineTornado = false;
                         if(hitByOfflineTornado && plot && plot.causeOfDeath === 'tornado' && plot.health <= 0) {
                            wasDestroyedByOfflineTornado = true;
                         }
                         if(wasDestroyedByOfflineTornado || isPlotWithRod(i)) continue;

                         // Chỉ tăng nếu đất chưa max phì nhiêu
                         if (plot && plot.fertility < BASE_FERTILITY) {
                            const oldFertilitySim = plot.fertility;
                            plot.fertility = Math.min(BASE_FERTILITY, plot.fertility + numberOfRainBoosts * 1); // Tăng 1% mỗi lần boost
                            if (plot.fertility !== oldFertilitySim) {
                                rainBoostChangedStateSim = true; // Đánh dấu có thay đổi
                                // Reset penalty nếu đất hết cằn nhờ mưa
                                if (oldFertilitySim <= 0 && plot.fertility > 0) {
                                    plot.barrenHarvestPenaltyFactor = 1.0;
                                }
                            }
                         }
                    }
                    if (rainBoostChangedStateSim) { plotStateChanged = true; } // Cập nhật cờ chung
                }
            }

            // Cập nhật stateChanged cuối cùng
            stateChanged = weatherChangedDuringSim || plotStateChanged;
            console.log(`Mô phỏng offline hoàn tất. Trạng thái ${stateChanged ? 'ĐÃ' : 'KHÔNG'} thay đổi.`);
            return stateChanged;
        } // --- Kết thúc hàm simulateOfflineProgress ---


        /** Hiển thị một tin nhắn tạm thời */
        function showMessage(text, type = 'info', duration = MESSAGE_DISPLAY_TIME, position = 'bottom') {
    if (messageTimeout) clearTimeout(messageTimeout);
    messageArea.textContent = text;
    const isMultiline = text.includes('\n');
    // Thêm class vị trí vào className
    messageArea.className = `show ${type} ${isMultiline ? 'multiline' : ''} position-${position}`;

    // Đặt lại vị trí top/bottom rõ ràng để tránh xung đột
    if (position === 'top') {
        messageArea.style.bottom = 'auto'; // Xóa thuộc tính bottom
        messageArea.style.top = '15px';   // Đặt vị trí ban đầu (ẩn) cho top
    } else {
        messageArea.style.top = 'auto';    // Xóa thuộc tính top
        messageArea.style.bottom = '15px'; // Đặt vị trí ban đầu (ẩn) cho bottom
    }

    // Buộc trình duyệt tính toán lại layout trước khi thêm class 'show' để animation hoạt động
    void messageArea.offsetWidth;

    // Thêm class 'show' để kích hoạt animation và hiển thị
    messageArea.classList.add('show'); // Class 'show' sẽ điều khiển vị trí cuối cùng và opacity

    messageTimeout = setTimeout(() => {
        messageArea.classList.remove('show');
        // Delay nhỏ trước khi xóa class để hoàn tất transition
        setTimeout(() => {
            if (!messageArea.classList.contains('show')) {
                messageArea.className = ''; // Xóa hết class
                // Reset style để không ảnh hưởng lần hiển thị sau
                messageArea.style.top = '';
                messageArea.style.bottom = '';
                messageArea.style.transform = '';
            }
        }, 500); // Thời gian này nên khớp với transition duration
    }, duration);
}

        /** Mở một hộp thoại modal bằng ID */
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) { modal.style.display = 'block';
                // Tự động focus vào phần tử đầu tiên có thể focus trong modal
                const focusable = modal.querySelector('button:not(:disabled), [href], input:not(:disabled), select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]), .close-button');
                if (focusable) { setTimeout(() => focusable.focus(), 50); } // Delay nhỏ để đảm bảo modal đã hiện
            } else { console.error(`Modal ID "${modalId}" không tồn tại.`); }
        }

        /** Đóng một hộp thoại modal bằng ID */
        function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal && modal.style.display === 'block') {
         modal.style.display = 'none';
         // Nếu đóng popup Hạt Ngọc Trời ban đầu qua hàm này (không nên, nhưng để phòng ngừa)
         if (modalId === 'hat-ngoc-troi-popup') {
             // Không nên tự động mở popup thưởng từ đây, logic chính là ở closeHatNgocTroiPopup()
             console.warn("Popup Hạt Ngọc Trời ban đầu bị đóng qua closeModal(), có thể không nhận thưởng.");
             // Có thể gọi startHatNgocTroiTimer() ở đây để đảm bảo timer chạy lại nếu có lỗi
             startHatNgocTroiTimer();
         }
         // Nếu đóng popup THƯỞNG Hạt Ngọc Trời qua hàm này (ví dụ: lỗi click nền không chạy đúng handler)
         else if (modalId === 'hat-ngoc-troi-reward-popup') {
             console.warn("Popup thưởng Hạt Ngọc Trời bị đóng qua closeModal(). Đảm bảo vật phẩm đã được trao.");
             // Không nên tự động trao thưởng từ đây, nút xác nhận là logic chính.
             // Nên khởi động lại timer ở đây để không bị kẹt
             startHatNgocTroiTimer();
         }
    }
}
        /** Đóng tất cả các modal đang mở */
        function closeAllModals() {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => closeModal(modal.id));
            // Reset các biến trạng thái liên quan đến modal
            currentPlantingPlotId = null;
            currentActionPlotId = null;
        }


        /** Xử lý click bên ngoài nội dung modal để đóng */
      function handleModalBackgroundClick(event) {
    // Đóng popup menu nếu click nền của nó
    if (event.target === menuPopup) { closeMenuPopup(); }
    // Đóng popup ô khóa nếu click nền của nó
    else if (event.target === lockedPlotPopup) { closeLockedPlotPopup(); }
    // Đóng popup xác nhận bán hết nếu click nền
    else if (event.target === confirmSellAllModal) { closeConfirmSellAllModal(); }
    // <<< THÊM: Đóng popup Hạt Ngọc Trời nếu click nền >>>
    else if (event.target === hatNgocTroiPopup) { closeHatNgocTroiPopup(); }
    // Đóng các modal khác nếu click nền của chúng
    else if (event.target.classList.contains('modal') && event.target !== menuPopup && event.target !== lockedPlotPopup && event.target !== confirmSellAllModal && event.target !== hatNgocTroiPopup) {
        const modalId = event.target.id;
        closeModal(modalId);
        if (modalId === 'seed-selection-modal') currentPlantingPlotId = null;
        if (modalId === 'fertilizer-selection-modal' || modalId === 'plant-action-modal' || modalId === 'empty-plot-action-modal') currentActionPlotId = null;
    }
}

        /** Cập nhật trạng thái các nút mua trong cửa hàng dựa trên tiền hiện có */
         function updateShopButtons() {
    // Kiểm tra các phần tử list có tồn tại không
    if (!shopSeedList || !shopToolList) {
        console.warn("updateShopButtons: Không tìm thấy shopSeedList hoặc shopToolList.");
        return;
    }

    const currentCurrency = gameState.currency;
    const currentInventoryCapacity = gameState.maxInventoryCapacity; // Lấy sức chứa hiện tại

    // --- Cập nhật nút mua hạt giống và công cụ thông thường ---
    // Sử dụng hàm updateSeedTotalCost đã có vì nó kiểm tra tiền và số lượng
    shopSeedList.querySelectorAll('.item-card').forEach(card => {
        const itemId = card.dataset.itemId;
        const item = ITEM_DATA[itemId];
        if (item && (item.type === 'seed')) { // Chỉ gọi cho seed ở list này
            try {
                updateSeedTotalCost(itemId, card);
            } catch (e) {
                console.error(`Lỗi khi cập nhật nút mua hạt giống ${itemId}:`, e);
            }
        }
    });

    shopToolList.querySelectorAll('.item-card').forEach(card => {
        const itemId = card.dataset.itemId;
        const item = ITEM_DATA[itemId];
        if (!item) return; // Bỏ qua nếu không tìm thấy item

        // Xử lý nút cho CÔNG CỤ (có input số lượng)
        if (item.type === 'tool') {
            try {
                updateSeedTotalCost(itemId, card); // Dùng hàm chung để cập nhật nút mua tool
            } catch (e) {
                console.error(`Lỗi khi cập nhật nút mua công cụ ${itemId}:`, e);
            }
        }
        // Xử lý nút cho NÂNG CẤP KHO ĐỒ (KHÔNG có input số lượng)
        else if (item.type === 'upgrade') {
            const buyButton = card.querySelector('.buy-upgrade-button'); // Nút riêng cho nâng cấp
            if (!buyButton) {
                console.warn(`Không tìm thấy nút '.buy-upgrade-button' cho nâng cấp ${itemId}`);
                return; // Bỏ qua nếu không tìm thấy nút
            }

            const cost = item.price || 0;
            const upgradeInfo = item.upgradeCapacity; // { from: number, to: number }

            // --- Kiểm tra các điều kiện để bật/tắt nút MUA NÂNG CẤP ---
            let disabled = false;
            let buttonText = `Mua (${cost}💰)`; // Văn bản mặc định
            let buttonTitle = `Nâng cấp kho lên ${upgradeInfo?.to || '?'} chỗ (Tốn ${cost}💰)`;

            // 1. Kiểm tra thông tin nâng cấp có hợp lệ không
            if (!upgradeInfo || typeof upgradeInfo.from !== 'number' || typeof upgradeInfo.to !== 'number') {
                disabled = true;
                buttonText = "Lỗi dữ liệu";
                buttonTitle = "Vật phẩm nâng cấp này bị lỗi dữ liệu.";
                console.error(`Lỗi dữ liệu nâng cấp cho vật phẩm: ${itemId}`);
            }
            // 2. Kiểm tra xem đã sở hữu nâng cấp này hoặc cao hơn chưa
            else if (currentInventoryCapacity >= upgradeInfo.to) {
                disabled = true;
                buttonText = "Đã sở hữu";
                buttonTitle = `Bạn đã có kho ${currentInventoryCapacity} chỗ (đã nâng cấp hoặc cao hơn).`;
            }
            // 3. Kiểm tra xem có đáp ứng yêu cầu sức chứa tối thiểu không
            else if (currentInventoryCapacity !== upgradeInfo.from) {
                disabled = true;
                buttonText = `Yêu cầu kho ${upgradeInfo.from}`;
                buttonTitle = `Cần có kho ${upgradeInfo.from} chỗ để mua nâng cấp này. Kho hiện tại: ${currentInventoryCapacity}.`;
            }
            // 4. Kiểm tra xem có đủ tiền không (chỉ kiểm tra nếu các điều kiện trên đã pass)
            else if (currentCurrency < cost) {
                disabled = true;
                buttonText = `Thiếu ${cost - currentCurrency}💰`;
                buttonTitle = `Không đủ tiền. Cần ${cost}💰, bạn có ${currentCurrency}💰.`;
            }
            // 5. Nếu tất cả điều kiện OK -> Nút được bật
            else {
                disabled = false;
                // buttonText và buttonTitle giữ nguyên giá trị mặc định
            }

            // --- Cập nhật trạng thái và nội dung nút ---
            buyButton.disabled = disabled;
            buyButton.textContent = buttonText;
            buyButton.title = buttonTitle;
        }
    });
    // console.log("Shop buttons updated."); // Bỏ comment nếu cần debug
}

        /** Định dạng mili giây thành chuỗi thời gian đọc được */
        function formatTime(ms, short = false) {
            if (isNaN(ms) || ms <= 0) return short ? "0s" : "0 giây";
            const totalSeconds = Math.max(0, Math.round(ms / 1000));
            const d = Math.floor(totalSeconds / 86400); const h = Math.floor((totalSeconds % 86400) / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60); const s = totalSeconds % 60;
            const dStr = short ? "ng" : " ngày"; const hStr = short ? "g" : " giờ";
            const mStr = short ? "ph" : " phút"; const sStr = short ? "s" : " giây"; const sep = short ? "" : " ";
            let parts = [];
            if (d > 0) parts.push(`${d}${dStr}`); if (h > 0) parts.push(`${h}${hStr}`);
            if (m > 0) parts.push(`${m}${mStr}`);
            // Hiển thị giây nếu là định dạng ngắn, hoặc nếu tổng thời gian < 1 phút, hoặc nếu không có phần nào khác
            if (s > 0 || parts.length === 0 || totalSeconds < 60 || short) {
                // Tránh hiển thị "X phút 0 giây" ở định dạng dài
                if (!(!short && parts.length > 0 && s === 0 && totalSeconds >= 60)) {
                    parts.push(`${s}${sStr}`);
                }
            }
            // Giới hạn ở 2 phần chính cho định dạng dài
            if (!short && parts.length > 2) parts = parts.slice(0, 2);
            return parts.length > 0 ? parts.join(sep) : (short ? "0s" : "0 giây");
        }


        // --- Xử Lý Tab ---
        // =================

        /** Chuyển tab cửa hàng */
        function switchShopTab(tabToShow) {
            if (!shopTabsContainer || !shopSeedList || !shopToolList) return;
            shopTabsContainer.querySelectorAll('.shop-tab-button').forEach(btn => { btn.classList.toggle('active', btn.dataset.tab === tabToShow); });
            const seedsActive = tabToShow === 'seeds';
            shopSeedList.classList.toggle('active-list', seedsActive); shopToolList.classList.toggle('active-list', !seedsActive);
            // Dùng display grid/none để đảm bảo ẩn/hiện đúng cách
            shopSeedList.style.display = seedsActive ? 'grid' : 'none';
            shopToolList.style.display = !seedsActive ? 'grid' : 'none';
        }
        /** Xử lý click tab cửa hàng */
        function handleShopTabClick(event) {
            const tabButton = event.target.closest('.shop-tab-button[data-tab]');
            if (tabButton) { const selectedTab = tabButton.dataset.tab; if (selectedTab) switchShopTab(selectedTab); }
        }

        /** Chuyển tab kho đồ */
        function switchInventoryTab(tabToShow) {
             if (!inventoryTabsContainer || !inventoryHarvestedList || !inventoryPurchasedList) return;
             inventoryTabsContainer.querySelectorAll('.inventory-tab-button').forEach(btn => {
                 btn.classList.toggle('active', btn.dataset.tab === tabToShow);
             });
             const harvestedActive = tabToShow === 'harvested';
             inventoryHarvestedList.classList.toggle('active-list', harvestedActive);
             inventoryPurchasedList.classList.toggle('active-list', !harvestedActive);
             // Kiểm tra xem list có rỗng không trước khi quyết định display
             const harvestedHasItems = inventoryHarvestedList.querySelector('.item-card');
             const purchasedHasItems = inventoryPurchasedList.querySelector('.item-card');
             inventoryHarvestedList.style.display = (harvestedActive && harvestedHasItems) ? 'grid' : 'none';
             inventoryPurchasedList.style.display = (!harvestedActive && purchasedHasItems) ? 'grid' : 'none';
             // Hiển thị thông báo trống nếu tab active không có item
             inventoryHarvestedEmptyMessage.style.display = (harvestedActive && !harvestedHasItems) ? 'block' : 'none';
             inventoryPurchasedEmptyMessage.style.display = (!harvestedActive && !purchasedHasItems) ? 'block' : 'none';
        }
        /** Xử lý click tab kho đồ */
        function handleInventoryTabClick(event) {
             const tabButton = event.target.closest('.inventory-tab-button[data-tab]');
             if (tabButton) {
                 const selectedTab = tabButton.dataset.tab;
                 if (selectedTab) switchInventoryTab(selectedTab);
             }
        }


        // --- Các Hàm Tooltip ---
        // =======================
        function showTooltip(text, targetElement) {
            if (!text || !targetElement) return; clearTimeout(tooltipTimeout); clearTimeout(tooltipHideTimeout);
            tooltipTimeout = setTimeout(() => { tooltipElement.innerHTML = text.replace(/\n/g, '<br>'); currentTooltipTarget = targetElement; positionTooltip(); tooltipElement.classList.add('visible'); }, TOOLTIP_DELAY);
        }
        function hideTooltip(delay = 0) {
             clearTimeout(tooltipTimeout); clearTimeout(tooltipHideTimeout);
             tooltipHideTimeout = setTimeout(() => { tooltipElement.classList.remove('visible'); currentTooltipTarget = null; setTimeout(() => { if (!tooltipElement.classList.contains('visible')) { tooltipElement.style.left = '-9999px'; tooltipElement.style.top = '-9999px'; } }, 200); }, delay);
        }
        function positionTooltip() {
            if (!tooltipElement.classList.contains('visible') || !currentTooltipTarget) return;
            const targetRect = currentTooltipTarget.getBoundingClientRect();
            // Tạm ẩn để lấy kích thước đúng
            tooltipElement.style.visibility = 'hidden';
            tooltipElement.style.display = 'block';
            const tooltipRect = tooltipElement.getBoundingClientRect();
            // Hiện lại
            tooltipElement.style.visibility = '';
            tooltipElement.style.display = '';

            const vpWidth = window.innerWidth; const vpHeight = window.innerHeight; const offset = 8;
            let x = targetRect.left + targetRect.width / 2 - tooltipRect.width / 2;
            let y = targetRect.top - tooltipRect.height - offset; // Mặc định ở trên

            // Nếu không đủ chỗ ở trên, thử ở dưới
            if (y < offset) {
                y = targetRect.bottom + offset;
                // Nếu ở dưới cũng không đủ, đặt ở vị trí cao nhất có thể trong viewport
                if (y + tooltipRect.height > vpHeight - offset) {
                    y = vpHeight - tooltipRect.height - offset;
                }
            }
            // Đảm bảo không tràn trái/phải
            if (x < offset) { x = offset; }
            else if (x + tooltipRect.width > vpWidth - offset) { x = vpWidth - tooltipRect.width - offset; }

            tooltipElement.style.left = `${Math.round(x)}px`;
            tooltipElement.style.top = `${Math.round(y)}px`;
        }
        /** Xử lý hover ô vườn -> hiển thị tooltip */
        function handlePlotMouseover(event) {
            const plotElement = event.target.closest('.plot');
            if (!plotElement) return;
            const plotId = parseInt(plotElement.dataset.plotId);
            if (isNaN(plotId)) return;

            let tooltipText = '';
            const isLocked = plotElement.classList.contains('locked');

            if (isLocked) {
                 const cost = calculatePlotCost(plotId);
                 tooltipText = `🔒 Ô Đất Bị Khóa\nClick để mua (Giá: ${cost}💰)`;
            } else if (isPlotWithRod(plotId)) { // Nếu là ô có cột thu lôi
                 const rodData = getRodData(plotId);
                 if (rodData) {
                     tooltipText = `⚡ Cột Thu Lôi (Ô ${plotId + 1})\nSức khỏe: ${rodData.health}/${LIGHTNING_ROD_MAX_HEALTH}`;
                     if (rodData.health <= 0) tooltipText += ` (Hỏng!)`;
                     tooltipText += `\nClick để xem chi tiết.`;
                 } else {
                     tooltipText = `Lỗi: Không tìm thấy dữ liệu cột thu lôi ô ${plotId + 1}.`;
                 }
            } else { // Ô bình thường (không khóa, không rod)
                 const plotData = gameState.plots[plotId];
                 if (!plotData) return; // Thêm kiểm tra plotData tồn tại

                 const now = Date.now();
                 const stageInfo = getPlantStageInfo(plotData, now);
                 const seedInfo = plotData.seedId ? ITEM_DATA[plotData.seedId] : null;
                 const isBarren = plotData.fertility <= 0;
                 const penaltyFactor = plotData.barrenHarvestPenaltyFactor || 1.0;
                 const itemProtectTip = ITEM_DATA['fertilizer_protect']; // Lấy thông tin item bảo vệ

                 // Chuẩn bị các phần thông tin cho tooltip
                 const fertilityInfoTip = isBarren ? `Đất: CẰN 0%` : `Đất: ${Math.round(plotData.fertility)}%`;
                 const dryTextTip = plotData.isDry ? ' (Khô!)' : '';
                 const pestTextTip = plotData.hasPest ? ' (Có sâu!)' : '';
                 const fenceTextTip = plotData.fenceData ? (plotData.fenceData.health > 0 ? ` | 🚧(${Math.round(plotData.fenceData.health)}%)` : ' | 🚧(Hỏng!)') : '';
                 let barrenPenaltyTextTip = '';
                 if (isBarren && penaltyFactor > 1.0) {
                      barrenPenaltyTextTip = `\n(Mọc chậm x${penaltyFactor.toFixed(2)})`;
                 }
                 // --- THÊM KIỂM TRA BUFF VÀO TOOLTIP ---
                 let protectTextTip = '';
                 if (plotData.hasFertilizerProtectBuff && itemProtectTip) { // Kiểm tra cả itemProtectTip tồn tại
                     const limitTip = itemProtectTip.usageLimitPerPlant || 3;
                     protectTextTip = `\n🛡️ Được bảo vệ (${plotData.fertilizerProtectUsageCount}/${limitTip})`;
                 }
                 // --- KẾT THÚC THÊM ---

                 // Xây dựng nội dung tooltip dựa trên trạng thái
                 if (plotData.fenceData && plotData.fenceData.health <= 0) { // Ưu tiên hiển thị RÀO HỎNG
                    const removeCostTip = ITEM_DATA.raobaove?.removeCost || 5;
                    tooltipText = `🚧 Rào Hỏng!${fenceTextTip}\n(${fertilityInfoTip}${dryTextTip})${barrenPenaltyTextTip}\nClick Mở Hành Động (Gỡ: ${removeCostTip}💰).${protectTextTip}`; // Thêm protectTextTip
                 } else if (plotData.seedId && stageInfo.isDead) { // Cây chết (rào không hỏng hoặc không có)
                      const plantNameDead = seedInfo?.name || 'Cây';
                      let cleanupCostText = "(Miễn phí)";
                      if(plotData.causeOfDeath === 'pest') {
                          const hasEnoughMoney = gameState.currency >= DEAD_PEST_CLEANUP_COST;
                          if (hasEnoughMoney) cleanupCostText = `(${DEAD_PEST_CLEANUP_COST}💰)`;
                          else cleanupCostText = `(Click ${DEAD_PEST_FREE_CLEANUP_CLICKS - (plotData.pestDeathClickCount||0)} lần)`;
                      }
                      tooltipText = `💀 ${plantNameDead} chết.${pestTextTip}\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick để dọn ${cleanupCostText}.${protectTextTip}`; // Thêm protectTextTip
                 } else if (plotData.hasPest) { // Có sâu (cây sống, rào không hỏng)
                      const plantNamePest = seedInfo?.name || 'Cây';
                      tooltipText = `🐛 SÂU BỆNH!${pestTextTip}\n(${plantNamePest} - HP: ${Math.round(plotData.health)}%)\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick Mở Hành Động.${protectTextTip}`; // Thêm protectTextTip
                 } else if (plotData.seedId && seedInfo && !stageInfo.isError) { // Cây sống, không sâu (rào không hỏng)
                      if (stageInfo.isMature) { // Cây trưởng thành
                           // Sửa lỗi tính sellValue: phải lấy baseYield từ seedInfo
                           const baseYieldTip = seedInfo.harvestYield || 0;
                           const sellValue = Math.round(1 * (plotData.health / 100) * baseYieldTip);
                           tooltipText = `✅ ${seedInfo.name} đã chín!\n(HP ${Math.round(plotData.health)}% - Bán: ${sellValue}💰)\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick Mở Hành Động.${protectTextTip}`; // Thêm protectTextTip
                      } else { // Cây đang lớn
                         const effectiveGrowthTimeMs = stageInfo.effectiveGrowthTimeSec * 1000;
                         const timeRemainingMs = Math.max(0, effectiveGrowthTimeMs - (now - plotData.plantTime));
                         tooltipText = `${seedInfo.name}: ${Math.round(stageInfo.growthProgress * 100)}% lớn\n(HP ${Math.round(plotData.health)}% - Còn ${formatTime(timeRemainingMs, true)})\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick Mở Hành Động.${protectTextTip}`; // Thêm protectTextTip
                      }
                 } else { // Ô trống (không rod, rào không hỏng)
                      tooltipText = `Ô đất trống\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick Mở Hành Động.${protectTextTip}`; // Thêm protectTextTip
                 }
            }
            showTooltip(tooltipText, plotElement);
        } // --- Kết thúc hàm handlePlotMouseover ---
        function handlePlotMousemove(event) { if (tooltipElement.classList.contains('visible')) { positionTooltip(); } }
        function handlePlotMouseout(event) { hideTooltip(50); } // Ẩn nhanh khi rời chuột

        // --- Các Bộ Xử Lý Sự Kiện Toàn Cục & Vòng Đời Game ---
        // ======================================================
        function handlePageUnload(event) { console.log("Sự kiện 'beforeunload': Lưu game lần cuối..."); if (gameLoopInterval) stopGameLoop(); saveGame(); }
       function handleVisibilityChange() {
    const now = Date.now();
    if (document.hidden) {
        console.log("Trạng thái trang: Ẩn. Lưu game, dừng vòng lặp và timer Hạt Ngọc Trời.");
        clearTimeout(hatNgocTroiTimeout);
        hatNgocTroiTimeout = null;
        // Dừng âm thanh nền và hiệu ứng (KHÔNG thay đổi isMusicEnabled/areEffectSoundsEnabled)
        if (backgroundMusic && !backgroundMusic.paused) { backgroundMusic.pause(); }
        if (rainSound && !rainSound.paused) { rainSound.pause(); }
        if (rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); }
        if (lightningSound && !lightningSound.paused) { lightningSound.pause(); lightningSound.currentTime = 0;} // Dừng cả sét nếu đang đánh

        if (gameLoopInterval) stopGameLoop(); // Dừng game loop (bao gồm save)

    } else {
        console.log("Trạng thái trang: Hiển thị. Mô phỏng offline (nếu cần), khởi động lại.");
        // ... (Phần mô phỏng offline giữ nguyên) ...
        const timeWasHidden = now - gameState.lastUpdateTimestamp;
        let stateChangedSim = false;
        if (timeWasHidden > TICK_INTERVAL * 1.5 && gameState.lastUpdateTimestamp > 0) {
           stateChangedSim = simulateOfflineProgress(gameState.lastUpdateTimestamp, now);
           gameState.totalPlayTime += timeWasHidden;
           gameState.lastUpdateTimestamp = now;
        } else if (timeWasHidden > 0 && gameState.lastUpdateTimestamp > 0){
           gameState.totalPlayTime += timeWasHidden;
           gameState.lastUpdateTimestamp = now;
        } else {
           gameState.lastUpdateTimestamp = now;
        }

         if (stateChangedSim) {
            renderGarden(); renderUI(); updateShopButtons(); if(inventoryModal.style.display === 'block') renderInventory();
            weatherUpdateNeeded = true;
        }

        // Khởi động lại vòng lặp game.
        startGameLoop(); // Hàm này sẽ gọi gameTick và startHatNgocTroiTimer

        // *** Cập nhật: Chỉ phát lại âm thanh nếu trạng thái tương ứng là BẬT ***
        if (isMusicEnabled && backgroundMusic && backgroundMusic.paused) {
             backgroundMusic.play().catch(e => console.warn("Resume background music error:", e));
        }
        if (areEffectSoundsEnabled && gameState.currentWeather) {
            if (rainSound && gameState.currentWeather.id === 'rainy' && rainSound.paused) {
                rainSound.play().catch(e => console.warn("Resume rain sound error:", e));
            }
            if (rainySunnySound && gameState.currentWeather.id === 'rainy_sunny' && rainySunnySound.paused) {
                 rainySunnySound.play().catch(e => console.warn("Resume rainy/sunny sound error:", e));
            }
        }
    }
}
		function openMenuPopup() {
         if (menuPopup) {
            menuPopup.style.display = 'block'; // Hoặc 'flex' nếu CSS dùng flex để căn giữa
			showDarkOverlay();
            // Tùy chọn: Focus vào nút lịch sử (nút còn lại) hoặc nút đóng
            const focusTarget = plantingHistoryBtn || closeMenuPopupBtn; // Ưu tiên focus nút lịch sử
            if (focusTarget) {
                setTimeout(() => focusTarget.focus(), 50);
            }
        } else {
            console.error("Không tìm thấy phần tử DOM của menu popup!");
        }
    }

    /** Đóng Popup Menu Chính */
    function closeMenuPopup() {
        if (menuPopup) {
            menuPopup.style.display = 'none';
			hideDarkOverlay();
        }
    }
	function populateShop() {
        console.log("[V10 Buy Fix populateShop] Populating shop items...");
        // Kiểm tra các phần tử DOM cần thiết ngay từ đầu
        if (!shopSeedList || !shopToolList || !shopSeedsEmptyMessage || !shopToolsEmptyMessage) {
            console.error("[V10 Buy Fix populateShop] FATAL ERROR: Shop list elements not found in DOM!");
            loadingIndicator.textContent = "Lỗi nghiêm trọng: Không thể tải giao diện cửa hàng.";
            return; // Không thể tiếp tục nếu thiếu các list chính
        }

        // Xóa nội dung cũ một cách an toàn
        shopSeedList.innerHTML = '';
        shopToolList.innerHTML = '';
        let seedsAvailable = false;
        let toolsAndUpgradesAvailable = false;

        // Sắp xếp Item IDs (Logic sắp xếp giữ nguyên như trước)
        const sortedItemIds = Object.keys(ITEM_DATA).sort((a, b) => {
            const itemA = ITEM_DATA[a]; const itemB = ITEM_DATA[b];
            if (!itemA) return 1; if (!itemB) return -1; // Đẩy item lỗi xuống cuối
            const typeOrder = { 'seed': 1, 'tool': 2, 'upgrade': 3 };
            const orderA = typeOrder[itemA.type] || 99;
            const orderB = typeOrder[itemB.type] || 99;
            if (orderA !== orderB) return orderA - orderB;
            if (itemA.type === 'tool' || itemA.type === 'upgrade') {
                if (itemA.id === 'pesticide') return -1; if (itemB.id === 'pesticide') return 1;
                return (itemA.price || 0) - (itemB.price || 0);
            }
            return (itemA.price || 0) - (itemB.price || 0);
        });
         console.log("[V10 Buy Fix populateShop] Sorted Item IDs:", sortedItemIds);

        // Lặp qua các vật phẩm đã sắp xếp
        sortedItemIds.forEach(itemId => {
            const item = ITEM_DATA[itemId];
            // Kiểm tra xem item có tồn tại không
            if (!item) {
                console.warn(`[V10 Buy Fix populateShop] Skipping non-existent item ID: ${itemId}`);
                return;
            }
             console.log(`[V10 Buy Fix populateShop] Processing item: ${itemId} (${item.name}), Type: ${item.type}`);

            const itemCard = document.createElement('div');
            itemCard.classList.add('item-card');
            itemCard.dataset.itemId = itemId; // Quan trọng: Gắn itemId vào thẻ cha

            let iconHtml = '';
            let detailsHtml = '';
            let buySectionHtml = '';
            let targetList = null; // List sẽ thêm thẻ item vào

            // --- Lấy Icon (an toàn hơn) ---
            let iconSrc = 'Hinhanh/Caychet.png'; // Fallback
            try {
                if (item.type === 'seed' && item.imageFolder) {
                    iconSrc = `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
                } else if ((item.type === 'tool' || item.type === 'upgrade') && item.imageFolder && item.imageFile) {
                    iconSrc = `${item.imageFolder}/${item.imageFile}`;
                }
            } catch (e) {
                 console.error(`[V10 Buy Fix populateShop] Error getting icon source for ${itemId}:`, e);
            }
            const imgTag = `<img src="${iconSrc}" alt="${item.name || 'Item'}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
            iconHtml = `<span class="item-icon">${imgTag}</span>`;

            // --- Xử lý theo loại vật phẩm ---
            if (item.type === 'seed') {
                seedsAvailable = true;
                targetList = shopSeedList;
                detailsHtml = `
                    <div class="item-details">
                        <div>🧺 Bán được: ${item.harvestYield || 0}💰/cây</div>
                        <div>⏰ Lớn: ${formatTime((item.growthTime || 0) * 1000, true)}</div>
                        <div>💩 Hao đất: -${((item.fertilityCost || 0) * 100).toFixed(0)}%</div>
                    </div>`;
                // Nút mua và input số lượng (Đảm bảo ID là duy nhất)
                buySectionHtml = `
                    <div class="seed-quantity-selector">
                        <label for="qty-${itemId}" style="font-size:0.8rem; margin-right: 5px;">SL:</label>
                        <input type="number" id="qty-${itemId}" class="seed-quantity-input" value="1" min="1" max="99" step="1" data-item-id="${itemId}" aria-label="Số lượng ${item.name}">
                    </div>
                    <div class="total-seed-cost" id="total-${itemId}">Giá bán: ${item.price || 0}💰</div>
                    <button class="buy-button buy-seed-button" data-item-id="${itemId}">Mua</button> <!-- Bỏ disabled ban đầu, để updateSeedTotalCost xử lý -->
                `;
                 console.log(`[V10 Buy Fix populateShop] Prepared SEED card for ${itemId}`);

            } else if (item.type === 'tool') {
                toolsAndUpgradesAvailable = true;
                targetList = shopToolList;
                let toolDescHtml = '';
                if (item.description) toolDescHtml += `<div>${item.description}</div>`;
                if (typeof item.fertilityBoost === 'number') toolDescHtml += `<div>💩 Phì nhiêu: +${(item.fertilityBoost * 100).toFixed(0)}%</div>`;
                if (item.id === 'raobaove' && typeof item.health === 'number') toolDescHtml += `<div>❤️ Sức khỏe: ${item.health}</div>`;
                if (item.id === 'cotthuloi' && typeof LIGHTNING_ROD_MAX_HEALTH === 'number') toolDescHtml += `<div>❤️ Chịu được: ${LIGHTNING_ROD_MAX_HEALTH} lần sét</div>`;
                detailsHtml = `<div class="item-details">${toolDescHtml || 'Công cụ hữu ích'}</div>`;
                // Nút mua và input số lượng
                buySectionHtml = `
                    <div class="seed-quantity-selector">
                        <label for="qty-${itemId}" style="font-size:0.8rem; margin-right: 5px;">SL:</label>
                        <input type="number" id="qty-${itemId}" class="seed-quantity-input" value="1" min="1" max="99" step="1" data-item-id="${itemId}" aria-label="Số lượng ${item.name}">
                    </div>
                    <div class="total-seed-cost" id="total-${itemId}">Giá bán: ${item.price || 0}💰</div>
                    <button class="buy-button buy-seed-button" data-item-id="${itemId}">Mua</button> <!-- Bỏ disabled ban đầu -->
                `;
                 console.log(`[V10 Buy Fix populateShop] Prepared TOOL card for ${itemId}`);

            } else if (item.type === 'upgrade') {
                toolsAndUpgradesAvailable = true;
                targetList = shopToolList;
                const requiredCapacity = item.upgradeCapacity?.from;
                const targetCapacity = item.upgradeCapacity?.to;
                let upgradeDesc = item.description || 'Nâng cấp quan trọng.';
                if (typeof requiredCapacity === 'number') {
                    upgradeDesc += `<br>Yêu cầu: Kho hiện tại ${requiredCapacity} chỗ.`;
                }
                detailsHtml = `<div class="item-details">${upgradeDesc}</div>`;
                // Nút mua nâng cấp (không có input số lượng)
                buySectionHtml = `
                    <div class="item-price" style="font-weight: bold; margin-bottom: 10px;">Giá: ${item.price || 0}💰</div>
                    <button class="buy-button buy-upgrade-button" data-item-id="${itemId}">Kiểm tra ĐK</button> <!-- Text và disabled sẽ được set bởi updateShopButtons -->
                `;
                 console.log(`[V10 Buy Fix populateShop] Prepared UPGRADE card for ${itemId}`);
            }

            // Thêm thẻ item vào danh sách tương ứng nếu có targetList
            if (targetList) {
                itemCard.innerHTML = `
                    ${iconHtml}
                    <div class="item-name">${item.name || 'Lỗi Tên'}</div>
                    ${detailsHtml}
                    ${buySectionHtml}
                `;
                targetList.appendChild(itemCard);
                 console.log(`[V10 Buy Fix populateShop] Appended card for ${itemId} to target list.`);
                // Quan trọng: Gọi updateSeedTotalCost NGAY SAU KHI THÊM để tính toán ban đầu và set trạng thái nút
                 if (item.type === 'seed' || item.type === 'tool') {
                    try {
                        updateSeedTotalCost(itemId, itemCard);
                         console.log(`[V10 Buy Fix populateShop] Initial cost/button state updated for ${itemId}.`);
                    } catch (e) {
                         console.error(`[V10 Buy Fix populateShop] Error calling updateSeedTotalCost for ${itemId} after append:`, e);
                    }
                 }
                 // Cập nhật nút Nâng cấp riêng biệt (trong updateShopButtons)
            } else {
                 console.warn(`[V10 Buy Fix populateShop] No target list determined for item ${itemId} (Type: ${item.type})`);
            }
        });

        // Hiển thị/ẩn thông báo trống
        shopSeedsEmptyMessage.classList.toggle('hidden', seedsAvailable);
        shopToolList.style.display = toolsAndUpgradesAvailable ? 'grid' : 'none'; // Đảm bảo list hiện ra nếu có đồ
        shopSeedsEmptyMessage.style.display = seedsAvailable ? 'none' : 'block'; // Hiện/ẩn message dựa trên cờ
        shopToolList.style.display = toolsAndUpgradesAvailable ? 'grid' : 'none';
        shopToolsEmptyMessage.style.display = toolsAndUpgradesAvailable ? 'none' : 'block';

         console.log(`[V10 Buy Fix populateShop] Seeds available: ${seedsAvailable}, Tools/Upgrades available: ${toolsAndUpgradesAvailable}`);


        // Cập nhật trạng thái tất cả các nút mua một lần cuối sau khi điền xong
        // updateShopButtons được gọi riêng sau populateShop trong initGame/openModal nên không cần gọi lại ở đây nữa.
        console.log("[V10 Buy Fix populateShop] Finished populating shop.");
    }
	
	
	
        // --- Bắt Đầu Game ---
        // =====================
        document.addEventListener('DOMContentLoaded', initGame);
        console.log("Script Vườn Cây (v9.2) đã được tải. Đang chờ DOMContentLoaded...");

    </script>

</body>
</html>
