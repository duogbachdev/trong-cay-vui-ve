
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>V∆∞·ªùn C√¢y H·∫°nh Ph√∫c - Thu Ho·∫°ch & Th√°ch Th·ª©c!</title> <!-- Thay ƒë·ªïi ti√™u ƒë·ªÅ -->
	<link rel="stylesheet" href="style-plotlocked-popup.css">
	<link rel="stylesheet" href="style-menu-button.css"> 
	<link rel="stylesheet" href="style-confirm-hatngoctroi.css">
	 <link rel="stylesheet" href="style-progressbar-thoitiet.css">
	 <link rel="stylesheet" href="style-hatngoctroi.css">
	 <link rel="stylesheet" href="style-tuido-item-bodi.css">
	 <link rel="stylesheet" href="style-popup-confirm-restoregame.css">

    <style>
		    #toggle-effects-sound-btn {
            background-color: #ff9800; /* M√†u cam (gi·ªëng n√∫t Mua) */
            color: white; /* ƒê·∫£m b·∫£o ch·ªØ d·ªÖ ƒë·ªçc */
        }

        #toggle-effects-sound-btn:hover:not(:disabled) {
            background-color: #f57c00; /* Cam ƒë·∫≠m h∆°n khi hover */
            opacity: 0.95; /* Gi·ªØ l·∫°i hi·ªáu ·ª©ng opacity n·∫øu c√≥ */
        }

        #toggle-effects-sound-btn:active:not(:disabled) {
            background-color: #e65100; /* Cam ƒë·∫≠m h∆°n n·ªØa khi active */
            transform: scale(0.98); /* Hi·ªáu ·ª©ng nh·∫•n nh·∫π */
        }

        /* Ki·ªÉu khi b·ªã disable (n·∫øu c√≥) */
        #toggle-effects-sound-btn:disabled {
            background-color: #ffcc80; /* M√†u cam nh·∫°t khi disable */
            cursor: not-allowed;
            opacity: 0.7;
            transform: none; /* B·ªè hi·ªáu ·ª©ng transform khi disable */
        }
	
		 #toggle-sound-btn {
            background-color: #4CAF50; /* M√†u xanh l√° (gi·ªëng n√∫t UI ch√≠nh) */
            color: white; /* ƒê·∫£m b·∫£o ch·ªØ m√†u tr·∫Øng d·ªÖ ƒë·ªçc */
        }

        #toggle-sound-btn:hover:not(:disabled) {
            background-color: #45a049; /* Xanh l√° ƒë·∫≠m h∆°n khi hover */
            opacity: 0.95; /* Gi·ªØ l·∫°i hi·ªáu ·ª©ng opacity n·∫øu c√≥ */
        }
        /* Ki·ªÉu khi b·ªã disable (n·∫øu c√≥) */
        #toggle-sound-btn:disabled {
            background-color: #a5d6a7; /* M√†u xanh l√° nh·∫°t khi disable */
            cursor: not-allowed;
            opacity: 0.7;
        }
	
	
	
	
	
	
	  @keyframes shake {
          0%, 100% { transform: translate(0, 0) rotate(0); }
          10%, 30%, 50%, 70%, 90% { transform: translate(-2px, -1px) rotate(-1deg); }
          20%, 40%, 60%, 80% { transform: translate(2px, 1px) rotate(1deg); }
        }

        @keyframes flash {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1.6); } /* Ph√≥ng to m·ªôt ch√∫t khi s√°ng nh·∫•t */
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.5); } /* M·ªù ƒëi v√† nh·ªè l·∫°i ch√∫t */
        }

        .plot.thunderstruck {
          /* <<<< THAY ƒê·ªîI animation-duration th√†nh 2s <<<< */
          animation: shake 1s cubic-bezier(.36,.07,.19,.97) both;
          position: relative;
          z-index: 2;
        }
		/* <<<< B·ªî SUNG CSS CHO GIF CONTAINER V√Ä IMG >>>> */
.lightning-gif-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex; /* S·ª≠ d·ª•ng flex ƒë·ªÉ cƒÉn gi·ªØa */
    justify-content: center;
    align-items: center;
    opacity: 0; /* ·∫®n m·∫∑c ƒë·ªãnh */
    visibility: hidden; /* ·∫®n ho√†n to√†n */
    transition: opacity 0.15s ease-out, visibility 0s 0.15s; /* Hi·ªáu ·ª©ng m·ªù d·∫ßn khi ·∫©n */
    pointer-events: none; /* Kh√¥ng ch·∫∑n click */
    z-index: 5; /* N·∫±m tr√™n n·ªôi dung plot, d∆∞·ªõi modal */
    overflow: hidden; /* ƒê·∫£m b·∫£o GIF kh√¥ng tr√†n ra ngo√†i */
    border-radius: inherit; /* K·∫ø th·ª´a bo g√≥c c·ªßa plot */
}
   .plot.thunderstruck .lightning-gif-container {
    opacity: 1; /* Hi·ªán khi c√≥ class thunderstruck */
    visibility: visible;
    transition: opacity 0.1s ease-in, visibility 0s; /* Hi·ªán nhanh */
}

.lightning-gif-container img {
    display: block; /* Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a d∆∞·ªõi ·∫£nh */
    max-width: 100%; /* Ho·∫∑c ƒëi·ªÅu ch·ªânh % nh·ªè h∆°n n·∫øu mu·ªën GIF nh·ªè h∆°n √¥ */
    max-height: 100%;
    object-fit: contain; /* Gi·ªØ t·ª∑ l·ªá GIF */
}     
	
	
	
	
		/* --- [M·ªöI] Ki·ªÉu cho √¥ ƒë·∫•t b·ªã kh√¥ --- */
.plot.dry-soil-effect {
    border-style: dashed !important; /* D√πng !important ƒë·ªÉ ghi ƒë√® vi·ªÅn infested n·∫øu c·∫ßn */
    border-color: #e67e22 !important; /* M√†u cam ƒë·∫•t */
    background-color: rgba(210, 180, 140, 0.3); /* M√†u n·ªÅn h∆°i n√¢u nh·∫°t, b√°n trong su·ªët */
    box-shadow: inset 0 0 10px rgba(165, 42, 42, 0.3); /* B√≥ng ƒë·ªï m√†u n√¢u b√™n trong */
}
/* Hover tr√™n √¥ b·ªã kh√¥ */
.plot.dry-soil-effect:not(.locked):hover {
    border-color: #d35400 !important; /* Cam ƒë·∫≠m h∆°n khi hover */
    background-color: rgba(210, 180, 140, 0.4);
}
/* ∆Øu ti√™n m√†u vi·ªÅn infested n·∫øu c·∫£ hai c√πng active */
.plot.infested.dry-soil-effect {
     border-color: #e53935 !important; /* Gi·ªØ m√†u vi·ªÅn ƒë·ªè c·ªßa infested */
}
	
	
	
        /* --- Reset & Ki·ªÉu C∆° B·∫£n --- */
		/* --- [M·ªöI] Ki·ªÉu n√∫t T∆∞·ªõi N∆∞·ªõc --- */
#modal-content-Tuoinuoc {
    background-color: #64b5f6; /* M√†u xanh da tr·ªùi nh·∫°t (Material Blue 300) */
    /* Th√™m hi·ªáu ·ª©ng hover n·∫øu mu·ªën */
}
#modal-content-Tuoinuoc:hover:not(:disabled) {
   background-color: #42a5f5; /* Xanh ƒë·∫≠m h∆°n ch√∫t khi hover */
   opacity: 0.95;
}
/* Ki·ªÉu khi b·ªã disable (gi·ªëng c√°c n√∫t action kh√°c) */
#modal-content-Tuoinuoc:disabled {
    background-color: #bdbdbd;
    cursor: not-allowed;
    transform: none;
    opacity: 0.7;
}
		
		
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px; /* C·ª° ch·ªØ c∆° b·∫£n */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f8ff; /* AliceBlue */
            color: #333;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overscroll-behavior: none; /* Ch·∫∑n k√©o ƒë·ªÉ l√†m m·ªõi tr√™n mobile */
            touch-action: manipulation; /* C·∫£i thi·ªán ph·∫£n h·ªìi ch·∫°m */
            -webkit-tap-highlight-color: transparent; /* B·ªè highlight khi ch·∫°m tr√™n mobile */
        }

        /* --- B·ªë C·ª•c --- */
        #game-container {
            max-width: 900px;
            margin: 10px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        } 
		#game-container.darken-weather-effect {
    filter: brightness(0.85); /* Gi·∫£m ƒë·ªô s√°ng xu·ªëng 85% */
    transition: filter 0.8s ease-in-out; /* Hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªïi m∆∞·ª£t m√† */
    /* T√πy ch·ªçn: C√≥ th·ªÉ th√™m hi·ªáu ·ª©ng kh√°c nh∆∞ l√†m l·∫°nh m√†u nh·∫π */
    /* filter: brightness(0.85) contrast(0.95) saturate(0.9); */
}
        #header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px dashed #90ee90;
        }

        #header h1 {
            color: #2e8b57; /* SeaGreen */
            font-size: 2rem;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        #stats-bar {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: #e6f5e6;
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 1rem;
            flex-wrap: wrap;
            gap: 15px;
            border: 1px solid #c8e6c9;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.08);
            min-width: 120px;
            justify-content: center;
        }

        .stat-item span {
            font-weight: bold;
            color: #3b7554; /* Xanh ƒë·∫≠m h∆°n */
            font-size: 1.05em;
        }

        /* --- Khu V∆∞·ªùn --- */
       #garden {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* L∆∞·ªõi linh ho·∫°t */
            gap: 20px;
            padding: 20px;
            background-color: #d2b48c; /* Tan - t∆∞·ª£ng tr∆∞ng cho ƒë·∫•t */
            border: 6px solid #8b4513; /* SaddleBrown - vi·ªÅn d√†y h∆°n */
            border-radius: 12px;
            margin-bottom: 20px;
            flex-grow: 1;
            /* min-height: 250px; */ /* Thay th·∫ø min-height b·∫±ng max-height */
            align-content: start;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23a0522d' fill-opacity='0.2' fill-rule='evenodd'%3E%3Cpath d='M0 40L40 0H20L0 20M40 40V20L20 40'/%3E%3C/g%3E%3C/svg%3E"); /* H·ªça ti·∫øt ƒë·∫•t tinh t·∫ø */

            /* --- [C·∫¨P NH·∫¨T] --- */
            max-height: 580px; /* Gi·ªõi h·∫°n chi·ªÅu cao t·ªëi ƒëa (∆∞·ªõc t√≠nh cho kho·∫£ng 4 h√†ng desktop) - ƒêi·ªÅu ch·ªânh n·∫øu c·∫ßn */
            overflow-y: auto; /* Cho ph√©p cu·ªôn d·ªçc khi n·ªôi dung v∆∞·ª£t qu√° max-height */
            /* T√πy ch·ªçn: Th√™m ki·ªÉu cho thanh cu·ªôn */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #a0522d #d2b48c; /* Firefox: m√†u thumb v√† track */
            /* --- [H·∫æT C·∫¨P NH·∫¨T BAN ƒê·∫¶U] --- */
        }
		/* T√πy ch·ªçn: Ki·ªÉu thanh cu·ªôn cho WebKit (Chrome, Safari, Edge) */
        #garden::-webkit-scrollbar {
            width: 8px; /* Chi·ªÅu r·ªông thanh cu·ªôn */
        }

        #garden::-webkit-scrollbar-track {
            background: #d2b48c; /* M√†u n·ªÅn track (gi·ªëng n·ªÅn garden) */
            border-radius: 4px;
        }

        #garden::-webkit-scrollbar-thumb {
            background-color: #a0522d; /* M√†u c·ªßa thumb (gi·ªëng m√†u ƒë·∫•t) */
            border-radius: 4px;
            border: 2px solid #d2b48c; /* T·∫°o kho·∫£ng c√°ch nh·ªè gi·ªØa thumb v√† track */
        }
        #garden::-webkit-scrollbar-thumb:hover {
            background-color: #8f5a33; /* M√†u thumb ƒë·∫≠m h∆°n khi hover */
        }
		
		
		

        .plot {
            background-color: #a0522d; /* Sienna - ƒë·∫•t t·ªëi h∆°n */
            border: 3px solid #8b4513; /* SaddleBrown */
            border-radius: 10px;
            height: 115px; /* TƒÉng chi·ªÅu cao cho thanh m√°u/ph√¨ nhi√™u */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.25);
            padding-top: 5px;
        }

        /* Hover √¥ ch∆∞a kh√≥a & KH√îNG c·∫±n 0% */
        .plot:not(.locked):not(.barren-soil):hover {
            background-color: #8f5a33;
            transform: scale(1.04);
            border-color: #a0522d;
        }
        /* Hover √¥ c·∫±n 0% */
        .plot.barren-soil:not(.locked):hover {
             background-color: #9d9d9d !important; /* M√†u x√°m hover */
             transform: scale(1.03);
             border-color: #666 !important;
        }

        /* Ch·ªâ ƒë·ªïi m√†u n·ªÅn t·ªëi h∆°n n·∫øu ƒë√£ tr·ªìng v√† ƒë·∫•t KH√îNG c·∫±n 0% */
        .plot.planted:not(.barren-soil) {
            background-color: #5f4c3a;
        }

        /* Ki·ªÉu cho ƒë·∫•t c·∫±n (th√™m l·ªõp .barren-soil) */
        .plot.barren-soil {
            background-color: #a9a9a9 !important; /* DarkGray - Quan tr·ªçng: m√†u ƒë·∫•t 0% */
            border-color: #777 !important; /* Vi·ªÅn x√°m t·ªëi */
        }


        .plot.infested {
             /* D√πng !important ƒë·ªÉ ghi ƒë√® vi·ªÅn kh√°c (k·ªÉ c·∫£ vi·ªÅn barren) */
             border-color: #e53935 !important;
             animation: infestedPulse 1.2s infinite alternate ease-in-out;
        }
        @keyframes infestedPulse {
            from { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 4px #e53935; }
            to   { box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3), 0 0 10px #ff6f60; }
        }

        /* --- √î ƒê·∫•t B·ªã Kh√≥a --- */
        .plot.locked {
            /* !important ƒë·ªÉ ch·∫Øc ch·∫Øn ghi ƒë√® barren n·∫øu c√≥ l·ªói */
            background-color: #b0b0b0 !important;
            border-color: #777 !important;
            cursor: not-allowed; /* ƒê·ªïi con tr·ªè */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        .plot.locked .plant-visual-container,
        .plot.locked .bars-container, /* ·∫®n thanh bar tr√™n √¥ kh√≥a */
        .plot.locked .plot-info {
            opacity: 0.3; /* L√†m m·ªù n·ªôi dung b√™n trong */
        }
        .plot.locked:hover { /* Hover √¥ b·ªã kh√≥a */
            background-color: #a0a0a0 !important;
            transform: scale(1.02);
            cursor: pointer; /* ƒê·ªïi th√†nh pointer khi c√≥ th·ªÉ mua */
        }
        /* Icon kh√≥a (T√πy ch·ªçn) */
        .plot.locked::before {
            content: 'üîí';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: rgba(0, 0, 0, 0.4);
            z-index: 5;
            pointer-events: none; /* Kh√¥ng ch·∫∑n click v√†o √¥ */
        }


        .plant-visual-container {
             position: relative;
             width: 100%;
             height: 55%; /* ƒêi·ªÅu ch·ªânh chi·ªÅu cao */
             display: flex;
             justify-content: center;
             align-items: center;
        }

        .plant-visual {
            /* Container ch·ª©a h√¨nh ·∫£nh */
            line-height: 1;
            text-align: center;
            user-select: none;
            transition: transform 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55), opacity 0.5s ease, filter 0.5s ease; /* Th√™m filter v√†o transition */
            opacity: 0;
            transform: scale(0.5) rotate(-15deg);
            z-index: 1;
            display: flex; /* D√πng flex ƒë·ªÉ cƒÉn gi·ªØa ·∫£nh */
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        .plant-visual img {
            max-width: 70%; /* ƒêi·ªÅu ch·ªânh d·ª±a tr√™n t·ªâ l·ªá ·∫£nh */
            max-height: 70%; /* ƒêi·ªÅu ch·ªânh d·ª±a tr√™n t·ªâ l·ªá ·∫£nh */
            object-fit: contain; /* Scale ·∫£nh ƒë·∫πp */
            transition: filter 0.5s ease; /* Th√™m transition cho filter c·ªßa ·∫£nh */
        }

        .plant-visual.visible {
            opacity: 1;
            transform: scale(1) rotate(0deg);
        }

        .pest-icon {
            position: absolute;
            font-size: 1.1rem;
            color: #dc143c;
            z-index: 2;
            top: 3px;
            right: 3px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            padding: 2px;
            line-height: 1;
            display: none; /* ·∫®n m·∫∑c ƒë·ªãnh */
            animation: wiggle 0.4s infinite ease-in-out;
            text-shadow: 0 0 2px white;
        }

        .plot.infested .pest-icon {
            display: block; /* Hi·ªán khi c√≥ class infested */
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(-8deg) scale(1); }
            50% { transform: rotate(8deg) scale(1.1); }
        }

        /* C√°c Giai ƒêo·∫°n C√¢y (Class c√≥ th·ªÉ √°p d·ª•ng n·∫øu c·∫ßn, nh∆∞ng ch·ªß y·∫øu l√† thay ƒë·ªïi src ·∫£nh) */
        .stage-0 { /* Giai ƒëo·∫°n m·∫ßm n·∫øu c·∫ßn style ri√™ng */ }
        .stage-dead { /* H√¨nh ·∫£nh khi ch·∫øt */
            filter: grayscale(80%) brightness(0.7); /* L√†m ·∫£nh x√°m v√† t·ªëi ƒëi */
        }
        .stage-dead.pest-death img {
            /* C√≥ th·ªÉ th√™m hi·ªáu ·ª©ng ƒë·∫∑c bi·ªát cho ·∫£nh ch·∫øt do s√¢u n·∫øu d√πng chung <img> */
            /* V√≠ d·ª•: filter: grayscale(100%) sepia(30%) brightness(0.6); */
        }

        /* --- Thanh M√°u & Ph√¨ Nhi√™u --- */
         .bars-container {
            width: 85%;
            margin: 3px auto 3px;
            display: flex; /* <<< QUAN TR·ªåNG: Lu√¥n l√† flex ƒë·ªÉ ch·ª©a c√°c thanh b√™n trong */
            flex-direction: column;
            gap: 2px; /* Kho·∫£ng c√°ch gi·ªØa c√°c thanh */
        }

        .bar-wrapper { /* Wrapper cho m·ªói thanh (c·∫£ m√°u v√† ph√¨ nhi√™u) */
             width: 100%;
             height: 6px; /* Chi·ªÅu cao thanh ri√™ng l·∫ª */
             background-color: #555; /* N·ªÅn t·ªëi */
             border-radius: 3px;
             overflow: hidden; /* Gi·ªØ ph·∫ßn fill b√™n trong */
             border: 1px solid #333;
             position: relative; /* Cho nh√£n ti·ªÅm nƒÉng */
        }

        /* <<< QUAN TR·ªåNG: Quy t·∫Øc n√†y ·∫©n THANH M√ÅU khi √¥ ƒë·∫•t KH√îNG c√≥ class .planted */
        .plot:not(.planted) .health-bar-wrapper {
            display: none;
        }
        /* <<< L∆ØU √ù: Kh√¥ng c√≥ quy t·∫Øc t∆∞∆°ng t·ª± cho .fertility-bar-wrapper => Thanh ph√¨ nhi√™u LU√îN ƒë∆∞·ª£c hi·ªÉn th·ªã b·ªüi CSS (n·∫øu cha n√≥ hi·ªÉn th·ªã) */


        .bar-fill { /* Ki·ªÉu fill chung */
            height: 100%;
            width: 100%; /* M·∫∑c ƒë·ªãnh ƒë·∫ßy, JS s·∫Ω ch·ªânh width */
            border-radius: 2px;
            transition: width 0.5s ease-out, background-color 0.5s ease;
            box-shadow: inset 0 -1px 1px rgba(0, 0, 0, 0.2);
        }

         /* Chi ti·∫øt Thanh M√°u */
        .health-bar-fill {
            background-color: #4CAF50; /* Xanh l√° */
        }
        .health-bar-fill.medium-health {
            background-color: #ffeb3b; /* V√†ng */
        }
        .health-bar-fill.low-health {
            background-color: #f44336; /* ƒê·ªè */
        }

         /* Chi ti·∫øt Thanh Ph√¨ Nhi√™u */
        .fertility-bar-fill {
            background-color: #8B4513; /* SaddleBrown */
        }
        .fertility-bar-fill.medium-fertility {
             background-color: #b8860b; /* DarkGoldenrod */
         }
        .fertility-bar-fill.low-fertility {
             background-color: #a9a9a9; /* DarkGray */
         }
         /* Th√™m m√†u cho ƒë·∫•t c·∫±n 0% */
         .fertility-bar-fill.barren {
             background-color: #666 !important; /* M√†u x√°m r·∫•t t·ªëi */
         }


        .plot-info {
            font-size: 0.65rem;
            color: #f5f5f5;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            white-space: normal;
            overflow: hidden;
            text-overflow: ellipsis;
            border-radius: 4px;
            width: 95%;
            margin: 0 auto 5px;
            line-height: 1.3;
            min-height: 2.6em; /* Cho ph√©p kho·∫£ng 2 d√≤ng */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        /* Ch·ªâ √°p d·ª•ng khi low nh∆∞ng ch∆∞a barren */
        .plot.low-fertility:not(.barren-soil) .plot-info {
             /* C√≥ th·ªÉ ƒë·ªïi m√†u nh·∫π n·∫øu mu·ªën */
         }
         /* ƒê·ªïi m√†u n·ªÅn/ch·ªØ info khi ƒë·∫•t c·∫±n 0% */
         .plot.barren-soil .plot-info {
             background-color: rgba(40, 40, 40, 0.7) !important;
             color: #bbb !important;
             font-style: italic;
         }

        /* Ghi ƒë√® style c·ªßa barren n·∫øu ƒëang b·ªã s√¢u */
        .plot.infested .plot-info {
            background-color: rgba(180, 0, 0, 0.6) !important;
            color: white !important;
            font-style: normal !important; /* Ghi ƒë√® italic c·ªßa barren n·∫øu ƒëang b·ªã s√¢u */
        }
        /* Text th√¥ng tin cho √¥ c·∫ßn ph√≠ d·ªçn d·∫πp (s√¢u ch·∫øt) */
        .plot-info.needs-cleanup-fee {
             color: #fff !important;
             background-color: rgba(100, 0, 0, 0.7) !important;
             font-weight: bold;
             font-style: normal !important;
         }
         /* Style cho √¥ ƒëang click d·ªçn mi·ªÖn ph√≠ */
         .plot-info.free-cleanup-progress {
            color: #ffe0b2 !important; /* V√†ng nh·∫°t */
            background-color: rgba(60, 60, 0, 0.8) !important;
            font-weight: bold;
            font-style: normal !important;
         }
        /* Text th√¥ng tin cho √¥ b·ªã kh√≥a */
        .plot.locked .plot-info {
            background-color: rgba(50, 50, 50, 0.6);
            color: #ccc;
            font-weight: bold;
            font-style: normal !important;
        }


        /* --- B·∫£ng ƒêi·ªÅu Khi·ªÉn UI --- */
        #ui-panel {
            display: flex;
            justify-content: space-around;
            margin-top: auto;
            padding: 15px 10px;
            background-color: #e6f5e6;
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 15px;
            border-top: 1px solid #c8e6c9;
        }

        .ui-button {
            background-color: #4CAF50; /* Xanh l√° */
            border: none;
            color: white;
            padding: 12px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease;
            flex-grow: 1;
            min-width: 110px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            font-weight: 500;
        }

        .ui-button:hover:not(:disabled) {
            background-color: #45a049;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }

        .ui-button:active:not(:disabled) {
            background-color: #367c39;
            transform: scale(0.98) translateY(0px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }
        .ui-button:disabled {
            background-color: #bdbdbd;
            cursor: not-allowed;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #757575;
        }

        /* --- Modals --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.4s ease;
            backdrop-filter: blur(3px);
        }
		 #discard-item-popup {
            z-index: 1010; /* ƒê·∫∑t z-index cao h∆°n modal ch√≠nh (1000) */
        }
        @keyframes fadeIn {
            from { opacity: 0; backdrop-filter: blur(0px);}
            to { opacity: 1; backdrop-filter: blur(3px); }
        }

        .modal-content {
            background-color: #fefefe;
            margin: 8% auto;
            padding: 30px;
            border: 1px solid #ccc;
            width: 90%;
            max-width: 480px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
            position: relative;
            animation: slideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            flex-direction: column;
        }

        @keyframes slideIn {
            from { transform: translateY(-40px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }


        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .modal-header h2 {
            color: #2e8b57;
            font-size: 1.6rem;
        }

        .close-button {
            color: #999;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s ease, transform 0.2s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: #333;
            transform: rotate(90deg);
        }

        /* --- Tab C·ª≠a H√†ng / Kho ƒê·ªì --- */
        .tabs-container { /* Container chung cho c√°c tab */
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
        }

        .tab-button { /* Ki·ªÉu n√∫t tab chung */
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background-color: #f1f1f1;
            border-bottom: 3px solid transparent;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
            color: #555;
            flex-grow: 1;
            text-align: center;
            border-radius: 6px 6px 0 0;
            margin-right: 2px;
        }

        .tab-button:last-child {
            margin-right: 0;
        }

        .tab-button:hover {
            background-color: #e9e9e9;
        }

        .tab-button.active {
            background-color: #fff;
            border-color: #4CAF50; /* Xanh l√° */
            color: #2e8b57; /* SeaGreen */
        }

        /* --- V·∫≠t Ph·∫©m C·ª≠a H√†ng & Kho --- */
        .item-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); /* L∆∞·ªõi linh ho·∫°t cho v·∫≠t ph·∫©m */
            gap: 20px;
            max-height: 60vh; /* Gi·ªõi h·∫°n chi·ªÅu cao v√† cho ph√©p cu·ªôn */
            overflow-y: auto;
            padding: 15px 5px 10px 5px;
            scrollbar-width: thin;
            scrollbar-color: #aaa #eee;
            flex-grow: 1;
        }
        /* Chrome/Edge/Safari */
        .item-list::-webkit-scrollbar { width: 8px; }
        .item-list::-webkit-scrollbar-track { background: #eee; border-radius: 4px; }
        .item-list::-webkit-scrollbar-thumb { background-color: #aaa; border-radius: 4px; border: 2px solid #eee; }

        /* ·∫®n danh s√°ch v·∫≠t ph·∫©m kh√¥ng ho·∫°t ƒë·ªông */
        .item-list:not(.active-list) {
            display: none;
        }

        .item-card {
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            background-color: #fff;
            transition: box-shadow 0.3s ease, transform 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .item-card:hover:not(.no-hover) {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transform: translateY(-3px);
        }

        .item-icon {
            /* Container cho ·∫£nh icon */
            height: 50px; /* Chi·ªÅu cao c·ªë ƒë·ªãnh cho khu v·ª±c icon */
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .item-icon img {
             max-width: 100%;
             max-height: 100%;
             object-fit: contain; /* Scale ·∫£nh ƒë·∫πp */
        }

        .item-name {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1rem;
            color: #444;
            flex-grow: 1; /* Cho ph√©p t√™n chi·∫øm kh√¥ng gian */
            min-height: 2.4em; /* ƒê·∫£m b·∫£o kh√¥ng gian cho hai d√≤ng */
            display: flex; /* CƒÉn gi·ªØa d·ªçc n·∫øu ng·∫Øn */
            align-items: center;
            justify-content: center;
        }

        .item-details {
            font-size: 0.78rem; /* H∆°i nh·ªè h∆°n */
            color: #666; /* X√°m h∆°i t·ªëi h∆°n */
            margin-bottom: 8px;
            line-height: 1.3;
            text-align: left; /* CƒÉn tr√°i chi ti·∫øt */
            padding: 0 5px; /* Th√™m padding ngang */
        }
        .item-details div { /* Th√™m kho·∫£ng c√°ch gi·ªØa c√°c d√≤ng chi ti·∫øt */
           margin-bottom: 3px;
        }
        .item-details div:last-child {
           margin-bottom: 0;
        }

        .item-price, .item-quantity {
            font-size: 0.9rem;
            font-weight: bold;
            color: #3b7554; /* Xanh l√° m·∫∑c ƒë·ªãnh */
            margin-bottom: 12px;
            text-align: center; /* CƒÉn gi·ªØa gi√°/s·ªë l∆∞·ª£ng */
        }
        /* M√†u lo·∫°i v·∫≠t ph·∫©m c·ª• th·ªÉ (c√≥ th·ªÉ t√πy ch·ªânh) */
        .item-price.pesticide, .item-quantity.pesticide { color: #c0392b; }
        .item-price.fertilizer, .item-quantity.fertilizer { color: #8B4513; }

        /* [C·∫¨P NH·∫¨T] Ki·ªÉu hi·ªÉn th·ªã gi√° tr·ªã cho v·∫≠t ph·∫©m thu ho·∫°ch */
        .item-harvest-value {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 6px;
        }
        .item-harvest-value span {
            font-weight: bold;
            color: #d4af37; /* M√†u v√†ng gold */
        }

        /* [C·∫¨P NH·∫¨T] Container b√°n trong kho ƒë·ªì */
        .sell-container {
            display: flex;
            flex-direction: column; /* X·∫øp ch·ªìng l√™n nhau */
            gap: 8px;
            margin-top: 10px;
            align-items: center; /* CƒÉn gi·ªØa */
        }
        .sell-quantity-selector {
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
            justify-content: center;
        }
        .sell-quantity-selector label {
            font-size: 0.75rem;
            color: #555;
            margin-right: 3px;
        }
        .sell-quantity-selector input[type="number"] {
            width: 55px; /* R·ªông h∆°n ch√∫t */
            padding: 4px 6px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.85rem;
            -moz-appearance: textfield;
        }
        .sell-quantity-selector input::-webkit-outer-spin-button,
        .sell-quantity-selector input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .sell-button { /* N√∫t B√°n ch√≠nh */
            background-color: #2ecc71; /* Xanh ng·ªçc */
            border: none;
            color: white;
            padding: 8px 15px; /* To h∆°n m·ªôt ch√∫t */
            text-align: center;
            font-size: 0.8rem; /* To h∆°n m·ªôt ch√∫t */
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            width: 80%; /* Chi·∫øm ph·∫ßn l·ªõn chi·ªÅu r·ªông */
            max-width: 120px; /* Gi·ªõi h·∫°n */
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .sell-button:hover:not(:disabled) {
            background-color: #27ae60; /* Xanh ƒë·∫≠m h∆°n */
            transform: scale(1.03);
        }
        .sell-button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            opacity: 0.7;
        }


        /* *** Ki·ªÉu S·ªë L∆∞·ª£ng H·∫°t Gi·ªëng *** */
        .seed-quantity-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-bottom: 8px;
        }
        .seed-quantity-selector input[type="number"] {
            width: 50px;
            padding: 4px 6px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            -moz-appearance: textfield;
        }
        .seed-quantity-selector input::-webkit-outer-spin-button,
        .seed-quantity-selector input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .total-seed-cost {
            font-size: 0.85rem;
            color: #555;
            font-weight: normal;
            display: block;
            margin-bottom: 8px;
            min-height: 1.2em;
        }
        /* *** K·∫øt th√∫c Ki·ªÉu S·ªë L∆∞·ª£ng H·∫°t Gi·ªëng *** */

        .buy-button, .plant-button, .use-button, .action-button {
            background-color: #ff9800; /* Cam - Mua M·∫∑c ƒë·ªãnh */
            border: none;
            color: white;
            padding: 8px 12px;
            text-align: center;
            font-size: 0.85rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            width: 100%;
            margin-top: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .buy-button:hover:not(:disabled), .action-button:hover:not(:disabled), .use-button:hover:not(:disabled) {
            background-color: #f57c00; /* Cam ƒë·∫≠m h∆°n */
            transform: scale(1.02);
        }

        /* M√†u n√∫t h√†nh ƒë·ªông c·ª• th·ªÉ */
        .action-button.treat-pest { background-color: #e74c3c; } /* ƒê·ªè cho thu·ªëc tr·ª´ s√¢u */
        .action-button.treat-pest:hover:not(:disabled) { background-color: #c0392b; }
        .action-button.select-fertilizer { background-color: #8B4513; } /* N√¢u cho ph√¢n b√≥n */
        .action-button.select-fertilizer:hover:not(:disabled) { background-color: #7a3d10; }
        .action-button.clear-plant { background-color: #7f8c8d; } /* X√°m cho d·ªçn d·∫πp */
        .action-button.clear-plant:hover:not(:disabled) { background-color: #6c7a7b; }
        .action-button.clear-plant.costly { background-color: #c0392b; } /* ƒê·ªè nh·∫π cho d·ªçn d·∫πp t·ªën ph√≠ */
        .action-button.clear-plant.costly:hover:not(:disabled) { background-color: #a93226; }
        /* [M·ªöI] M√†u n√∫t B√°n Ngay */
        .action-button.sell-now { background-color: #ffb300; color:#333; font-weight: bold;} /* V√†ng cam */
        .action-button.sell-now:hover:not(:disabled) { background-color: #ffa000; }

        .buy-button:disabled, .plant-button:disabled, .use-button:disabled, .action-button:disabled {
             background-color: #bdbdbd;
             cursor: not-allowed;
             transform: none;
             opacity: 0.7;
         }

        .plant-button {
             background-color: #4CAF50; /* Xanh l√° cho tr·ªìng */
         }
        .plant-button:hover:not(:disabled) {
             background-color: #45a049;
             transform: scale(1.02);
         }
        .use-button { /* Ki·ªÉu cho n√∫t 'S·ª≠ d·ª•ng' trong modal ch·ªçn */
            background-color: #2196F3; /* Xanh d∆∞∆°ng */
        }
        .use-button:hover:not(:disabled) {
            background-color: #1976D2; /* Xanh d∆∞∆°ng ƒë·∫≠m h∆°n */
        }


         /* --- Ki·ªÉu C·ª• Th·ªÉ Modal H√†nh ƒê·ªông C√¢y Tr·ªìng --- */
        #plant-action-modal .modal-content {
            max-width: 450px;
            margin: 15% auto;
        }

        #plant-action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Gi·ªØ nguy√™n 2 c·ªôt */
            gap: 15px;
        }

        /* [C·∫¨P NH·∫¨T] N√∫t Thu Ho·∫°ch v√† B√°n Ngay s·∫Ω chi·∫øm 2 c·ªôt */
        #plant-action-buttons #action-harvest-plant,
        #plant-action-buttons #action-sell-now {
            grid-column: 1 / -1; /* Chi·∫øm t·ª´ c·ªôt 1 ƒë·∫øn h·∫øt */
        }

        .action-button { /* √Åp d·ª•ng cho t·∫•t c·∫£ c√°c n√∫t trong modal h√†nh ƒë·ªông */
            padding: 12px 15px;
            font-size: 0.9rem;
        }

        /* --- Ki·ªÉu C·ª• Th·ªÉ Modal H√†nh ƒê·ªông √î ƒê·∫•t Tr·ªëng --- */
        #empty-plot-action-modal .modal-content {
            max-width: 400px; /* Nh·ªè h∆°n m·ªôt ch√∫t */
            margin: 15% auto;
        }
        #empty-plot-action-buttons {
            display: grid;
            grid-template-columns: 1fr; /* N√∫t x·∫øp ch·ªìng l√™n nhau */
            gap: 10px; /* Kho·∫£ng c√°ch gi·ªØa c√°c n√∫t */
            margin-top: 10px;
        }
        #empty-plot-action-buttons .action-button {
            padding: 10px 15px; /* Padding n√∫t */
            font-size: 0.95rem;
            text-transform: none; /* Kh√¥ng vi·∫øt hoa */
            letter-spacing: normal;
            background-color: #4CAF50; /* Xanh l√° m·∫∑c ƒë·ªãnh */
        }
         #empty-plot-action-buttons .action-button.fertilize { background-color: #8B4513; } /* N√¢u */
         #empty-plot-action-buttons .action-button.shop { background-color: #ff9800; } /* Cam */

        #empty-plot-action-buttons .action-button:hover:not(:disabled) {
            opacity: 0.9;
            transform: scale(1.01);
        }


        /* --- Khu V·ª±c Tin Nh·∫Øn --- */
        #message-area {
            position: fixed;
    left: 50%;
    background-color: rgba(0, 0, 0, 0.75);
    color: white;
    padding: 12px 25px;
    border-radius: 25px;
    font-size: 1rem;
    z-index: 2000;
    opacity: 0;
    /* Quan tr·ªçng: Transition cho opacity, transform V√Ä top/bottom */
    transition: opacity 0.5s ease, transform 0.5s ease, top 0.5s ease, bottom 0.5s ease;
    pointer-events: none;
    white-space: normal;
    text-align: center;
    box-shadow: 0 3px 10px rgba(0,0,0,0.3);
    max-width: 80%;
        }
        /* Style cho message nhi·ªÅu d√≤ng */
        #message-area.multiline {
             white-space: pre-line; /* Gi·ªØ l·∫°i c√°c d·∫•u xu·ªëng d√≤ng */
        }

		#message-area.position-bottom {
    bottom: 15px; /* V·ªã tr√≠ ·∫©n ban ƒë·∫ßu */
    top: auto;
    transform: translateX(-50%) scale(0.9); /* Hi·ªáu ·ª©ng scale khi ·∫©n */
}
#message-area.position-bottom.show {
    opacity: 1;
    bottom: 30px; /* V·ªã tr√≠ hi·ªán */
    transform: translateX(-50%) scale(1); /* Hi·ªáu ·ª©ng scale khi hi·ªán */
}

/* --- ƒê·ªãnh v·ªã Ph√≠a Tr√™n --- */
#message-area.position-top {
    top: 15px; /* V·ªã tr√≠ ·∫©n ban ƒë·∫ßu (h∆°i l·ªách l√™n tr√™n) */
    bottom: auto;
    transform: translateX(-50%) translateY(-60px) scale(0.9); /* ·∫®n ph√≠a tr√™n v√† scale nh·ªè */
}
#message-area.position-top.show {
    opacity: 1;
    top: 30px; /* V·ªã tr√≠ hi·ªán cu·ªëi c√πng */
    transform: translateX(-50%) translateY(0) scale(1); /* Tr∆∞·ª£t xu·ªëng v√† scale l·ªõn */
}


        #message-area.show {
            opacity: 1;
            bottom: 30px;
            transform: translateX(-50%) scale(1);
        }
        #message-area:not(.show) {
            transform: translateX(-50%) scale(0.9);
        }

        #message-area.success { background-color: rgba(46, 139, 87, 0.85); color: #fff; }
        #message-area.error { background-color: rgba(220, 20, 60, 0.85); color: #fff; }
        #message-area.warning { background-color: rgba(243, 156, 18, 0.9); color: #333; font-weight: 500; }
        #message-area.info { background-color: rgba(0, 0, 0, 0.75); color: white; }
         /* [M·ªöI] Style cho pest event */
         #message-area.pest-event { background-color: rgba(180, 0, 0, 0.88); color: white; font-weight: bold; }


        /* --- Ch·ªâ B√°o T·∫£i --- */
        #loading-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            color: #444;
            backdrop-filter: blur(4px);
            flex-direction: column;
            gap: 15px;
            font-weight: 500;
        }
         /* Animation spinner ƒë∆°n gi·∫£n */
         #loading-indicator::before {
             content: '';
             display: block;
             width: 40px;
             height: 40px;
             border: 4px solid #ccc;
             border-top-color: #2e8b57;
             border-radius: 50%;
             animation: spin 1s linear infinite;
         }
         @keyframes spin {
             to { transform: rotate(360deg); }
         }


        /* --- Tooltip --- */
        .tooltip {
          position: fixed;
          background-color: rgba(0, 0, 0, 0.8);
          color: #fff;
          padding: 8px 12px;
          border-radius: 6px;
          font-size: 0.8rem;
          white-space: pre-line; /* Cho ph√©p xu·ªëng d√≤ng b·∫±ng \n */
          max-width: 200px;   /* Gi·ªõi h·∫°n chi·ªÅu r·ªông */
          z-index: 1001;
          opacity: 0;
          transition: opacity 0.2s ease, top 0.2s ease, left 0.2s ease;
          pointer-events: none;
          left: -9999px;
          top: -9999px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
          line-height: 1.4;
          text-align: center; /* CƒÉn gi·ªØa text tooltip */
        }

        .tooltip.visible {
            opacity: 1;
        }

        /* --- ƒêi·ªÅu Ch·ªânh Responsive --- */
       @media (max-width: 768px) { /* Tablet */
             #garden {
                 grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
                 gap: 15px;
                 /* --- [C·∫¨P NH·∫¨T] --- */
                 max-height: 520px; /* Gi·∫£m chi·ªÅu cao t·ªëi ƒëa cho tablet */
                 /* --- [H·∫æT C·∫¨P NH·∫¨T] --- */
             }
             .plot { height: 105px; }
             .plot.locked::before { font-size: 2rem; }
             .plant-visual img { max-height: 65%; max-width: 65%; }
             .pest-icon { font-size: 1rem; }
             .bar-wrapper { height: 5px; } /* Chi·ªÅu cao thanh bar cho tablet */
             .plot-info { font-size: 0.6rem; min-height: 2.8em; }
        }

         @media (max-width: 600px) { /* Mobile L·ªõn */
            html { font-size: 14px; }
            #game-container { margin: 5px; padding: 15px; border-radius: 10px; }
            #header h1 { font-size: 1.8rem; }
            #stats-bar { font-size: 0.9rem; padding: 8px 10px; gap: 8px; }
            .stat-item { padding: 6px 10px; min-width: 100px; }
            #garden {
                gap: 12px;
                padding: 12px;
                grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
                /* --- [C·∫¨P NH·∫¨T] --- */
                max-height: 480px; /* Gi·∫£m chi·ªÅu cao t·ªëi ƒëa cho mobile l·ªõn */
                 /* --- [H·∫æT C·∫¨P NH·∫¨T] --- */
            }
            .plot { height: 100px; border-width: 2px; }
            .plot.locked::before { font-size: 1.8rem; }
            .plant-visual img { max-height: 60%; max-width: 60%; }
             .pest-icon { font-size: 0.9rem; top: 2px; right: 2px; padding: 1px; }
             .bars-container { width: 90%; }
             .bar-wrapper { height: 4px; } /* Chi·ªÅu cao thanh bar cho mobile l·ªõn */
             .plot-info { font-size: 0.55rem; min-height: 3em; width: 95%; padding: 1px 3px; }
            .ui-button { padding: 10px 15px; font-size: 0.9rem; min-width: 95px; box-shadow: 0 3px 6px rgba(0,0,0,0.1); }
            .modal-content { width: 92%; margin: 12% auto; padding: 20px; }
            #plant-action-modal .modal-content,
            #empty-plot-action-modal .modal-content { margin: 20% auto; width: 85%; }
            .modal-header h2 { font-size: 1.4rem; }
             .tabs-container { margin-bottom: 10px; } /* √Åp d·ª•ng cho c·∫£ shop v√† inventory tabs */
             .tab-button { padding: 8px 15px; font-size: 0.9rem; }
             .item-list { grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 15px; }
             .item-card { padding: 10px; }
             .item-icon { height: 45px; }
             .item-name { font-size: 0.9rem; min-height: 2.2em;}
             .item-details { font-size: 0.75rem; }
             .sell-button { font-size: 0.75rem; padding: 6px 10px; } /* C·∫≠p nh·∫≠t sell-button */
             .sell-quantity-selector input[type="number"] { width: 45px; font-size: 0.8rem;}
             .seed-quantity-selector input[type="number"] { width: 40px; font-size: 0.8rem;}
             .total-seed-cost { font-size: 0.8rem; }
             .buy-button, .plant-button, .action-button, .use-button { font-size: 0.8rem; padding: 6px 10px;}
             #message-area { font-size: 0.9rem; padding: 10px 20px; width: auto; max-width: 90%; bottom: 10px; }
             #message-area.show { bottom: 20px; }
             .tooltip { max-width: 180px; font-size: 0.75rem; }
        }

        @media (max-width: 420px) { /* Mobile Nh·ªè */
             #stats-bar { gap: 5px; }
             .stat-item { padding: 5px 8px; gap: 5px; font-size: 0.85rem; min-width: 90px; }
             .stat-item span { font-size: 1em; }
             #garden {
                 grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
                 gap: 10px;
                 padding: 10px;
                 /* --- [C·∫¨P NH·∫¨T] --- */
                 max-height: 450px; /* Gi·∫£m chi·ªÅu cao t·ªëi ƒëa cho mobile nh·ªè */
                 /* --- [H·∫æT C·∫¨P NH·∫¨T] --- */
            }
             .plot { height: 95px; }
             .plot.locked::before { font-size: 1.6rem; }
             .plant-visual img { max-height: 55%; max-width: 55%; }
             .pest-icon { font-size: 0.8rem; }
             #ui-panel { gap: 8px; padding: 10px 5px; }
             .ui-button { padding: 8px 10px; font-size: 0.8rem; min-width: 80px; }
             .modal-content { margin: 15% auto; padding: 15px; width: 95%; }
             #plant-action-modal .modal-content,
             #empty-plot-action-modal .modal-content { margin: 25% auto; width: 90%; }
             #plant-action-buttons { grid-template-columns: 1fr; } /* X·∫øp ch·ªìng n√∫t */
             /* [C·∫¨P NH·∫¨T] ƒê·∫£m b·∫£o n√∫t harvest/sell now c≈©ng x·∫øp ch·ªìng */
             #plant-action-buttons #action-harvest-plant,
             #plant-action-buttons #action-sell-now {
                 grid-column: 1 / -1; /* Gi·ªØ nguy√™n n·∫øu ƒë√£ ch·ªìng */
             }
             .modal-header h2 { font-size: 1.2rem; }
             .modal-header { padding-bottom: 10px; margin-bottom: 15px; }
             .tabs-container { margin-bottom: 8px; }
             .tab-button { padding: 6px 10px; font-size: 0.8rem; }
             .item-list { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; } /* ƒêi·ªÅu ch·ªânh minmax */
             .item-card { padding: 8px; }
             .item-icon { height: 40px; }
             .item-name { font-size: 0.85rem; min-height: 2em; }
             .item-details { font-size: 0.7rem; }
             .item-harvest-value { font-size: 0.7rem;}
             .sell-button { font-size: 0.7rem; padding: 5px 8px; } /* C·∫≠p nh·∫≠t sell-button */
             .sell-quantity-selector input[type="number"] { width: 40px; font-size: 0.75rem;}
             .sell-quantity-selector label { font-size: 0.7rem; }
             .plot-info { font-size: 0.5rem; min-height: 3.2em; }
              .seed-quantity-selector { gap: 3px; }
              .seed-quantity-selector input[type="number"] { width: 35px; font-size: 0.75rem;}
              .total-seed-cost { font-size: 0.75rem; }
              .buy-button, .plant-button, .action-button, .use-button { font-size: 0.75rem; padding: 5px 8px;}
              .tooltip { max-width: 150px; font-size: 0.7rem;}
        }

        /* --- L·ªõp Ti·ªán √çch --- */
        .hidden {
            display: none;
        }
		/* --- [M·ªöI] Ki·ªÉu n√∫t B√°n H·∫øt --- */
        .sell-button.sell-all-button {
            background-color: #e74c3c; /* M√†u ƒë·ªè */
        }
        .sell-button.sell-all-button:hover:not(:disabled) {
            background-color: #c0392b; /* M√†u ƒë·ªè ƒë·∫≠m h∆°n khi hover */
        }
        .sell-button.sell-all-button:disabled {
            background-color: #f5b7b1; /* M√†u ƒë·ªè nh·∫°t khi b·ªã v√¥ hi·ªáu h√≥a */
             opacity: 0.6;
        }
		
		#dark-overlay {
    display: none; /* ·∫®n l·ªõp ph·ªß ban ƒë·∫ßu */
    position: fixed; /* ƒê·ªãnh v·ªã tuy·ªát ƒë·ªëi so v·ªõi c·ª≠a s·ªï tr√¨nh duy·ªát */
    top: 0;
    left: 0;
    width: 100%; /* Chi·∫øm to√†n b·ªô chi·ªÅu r·ªông */
    height: 100%; /* Chi·∫øm to√†n b·ªô chi·ªÅu cao */
    background-color: rgba(0, 0, 80, 0.75); /* M√†u xanh d∆∞∆°ng ƒëen t·ªëi (RGB: 0,0,80) v·ªõi 75% ƒë·ªô m·ªù ƒë·ª•c (25% trong su·ªët) */
    z-index: 950; /* ƒê·∫∑t cao h∆°n n·ªôi dung game nh∆∞ng th·∫•p h∆°n c√°c modal (modal th∆∞·ªùng l√† 1000+) */
    pointer-events: none; /* Cho ph√©p click xuy√™n qua l·ªõp ph·ªß (quan tr·ªçng!) */

    /* T√πy ch·ªçn: Th√™m hi·ªáu ·ª©ng m·ªù d·∫ßn khi xu·∫•t hi·ªán/·∫©n ƒëi */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease, visibility 0s 0.5s;
}

/* Class ƒë·ªÉ hi·ªÉn th·ªã l·ªõp ph·ªß (d√πng v·ªõi JavaScript) */
#dark-overlay.visible {
    display: block; /* Thay ƒë·ªïi display th√†nh block khi d√πng opacity */
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease, visibility 0s;
     /* N·∫øu b·∫°n MU·ªêN l·ªõp ph·ªß ch·∫∑n click khi n√≥ hi·ªÉn th·ªã, th√™m d√≤ng sau: */
     /* pointer-events: auto; */
}
		/* ---  Ki·ªÉu cho H√†ng R√†o H·ªèng --- */
.plot-info.broken-fence-info {
    background-color: rgba(100, 0, 0, 0.7) !important; /* N·ªÅn ƒë·ªè ƒë·∫≠m */
    color: white !important;
    font-weight: bold;
    font-style: normal !important;
}

.action-button.remove-broken-fence {
    background-color: #e74c3c; /* M√†u ƒë·ªè */
}
.action-button.remove-broken-fence:hover:not(:disabled) {
    background-color: #c0392b; /* ƒê·ªè ƒë·∫≠m h∆°n */
}
.action-button.remove-broken-fence:disabled {
    background-color: #f5b7b1; /* ƒê·ªè nh·∫°t */
    opacity: 0.7;
}
/* --- K·∫øt th√∫c Ki·ªÉu H√†ng R√†o H·ªèng --- */
	.fence-health-bar-wrapper { /* ƒê√£ th√™m style inline, ƒë√¢y l√† t√πy ch·ªçn */
    /* V√≠ d·ª•: position: absolute; top: 3px; left: 15%; width: 70%; height: 4px; z-index: 3; */
}	
		
		
		
		
		
		
		
		
		
		
    </style>
</head>
<body>

    <!-- Ch·ªâ B√°o T·∫£i -->
    <div id="loading-indicator">ƒêang t·∫£i khu v∆∞·ªùn... üå±</div>

    <!-- Container Game Ch√≠nh -->
    <div id="game-container" class="hidden"> <!-- B·∫Øt ƒë·∫ßu ·∫©n, hi·ªán sau khi t·∫£i -->

        <!-- Header -->
        <div id="header">
            <h1>V∆∞·ªùn C√¢y H·∫°nh Ph√∫c</h1>
        </div>
		 <!-- ====== KHU V·ª∞C HI·ªÇN TH·ªä TH·ªúI TI·∫æT (M·ªöI) ====== -->
        <div id="weather-section">
             <div id="weather-info">
                 <span id="weather-icon" title="Th·ªùi ti·∫øt hi·ªán t·∫°i">‚ùì</span>
				 <span id="weather-name">---</span>
                 <span id="weather-timer" title="Th·ªùi gian c√≤n l·∫°i ƒë·∫øn khi ƒë·ªïi th·ªùi ti·∫øt">--:--</span>
             </div>
             <div id="weather-progress-container" class="weather-progress-container"> <!-- Container cho CSS -->
                 <div id="weather-progress-bar" class="weather-progress-bar-fill"></div> <!-- Thanh fill s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t -->
             </div>
        </div>
        <!-- =============================================== -->

        <!-- Thanh Ch·ªâ S·ªë -->
        <div id="stats-bar">
            <div class="stat-item">üí∞ Ti·ªÅn: <span id="currency">0</span></div>
            <div class="stat-item">‚è∞ Gi·ªù: <span id="game-time">--:--</span></div>
            <div class="stat-item">üèûÔ∏è √î ƒë·∫•t: <span id="plot-count">0</span></div> <!-- Ch·ªâ hi·ªÉn th·ªã s·ªë √¥ ƒë√£ m·ªü -->
        </div>
		


        <!-- Khu V∆∞·ªùn -->
        <div id="garden">
            <!-- C√°c √¥ ƒë·∫•t s·∫Ω ƒë∆∞·ª£c t·∫°o v√† c·∫≠p nh·∫≠t b·ªüi JavaScript -->
            <!-- M·ªói √¥ ƒë·∫•t (.plot) s·∫Ω ch·ª©a: -->
            <!-- .plant-visual-container -> .plant-visual (ch·ª©a img), .pest-icon -->
            <!-- .bars-container -> .health-bar-wrapper (ch·ª©a .health-bar-fill), .fertility-bar-wrapper (ch·ª©a .fertility-bar-fill) -->
            <!-- .plot-info -->
        </div>

         <!-- Ph·∫ßn T·ª≠ Tooltip -->
        <div id="tooltip" class="tooltip">N·ªôi dung tooltip</div>

        <!-- B·∫£ng ƒêi·ªÅu Khi·ªÉn UI (N√∫t C·ª≠a H√†ng, Kho) -->
        <div id="ui-panel">
            <button id="open-shop-btn" class="ui-button">üõí C·ª≠a H√†ng</button>
            <button id="open-inventory-btn" class="ui-button">üéí T√∫i ƒê·ªì</button>
          <!-- <button id="save-game-btn" class="ui-button">üíæ L∆∞u Game</button> -->
		  <button id="open-menu-btn" class="ui-button">‚ò∞ Menu</button>
        </div>

    </div> <!-- K·∫øt th√∫c Container Game -->

<!-- Popup X√°c Nh·∫≠n B·ªè V·∫≠t Ph·∫©m ƒê√£ Mua -->
    <div id="discard-item-popup" class="modal" style="display: none;">
        <div class="discard-popup-content"> <!-- Class ri√™ng ƒë·ªÉ CSS t√πy ch·ªânh -->
            <span class="close-button" onclick="closeDiscardItemPopup()">√ó</span>
            <h2>X√°c Nh·∫≠n B·ªè V·∫≠t Ph·∫©m</h2>
            <div class="discard-item-info">
                <span id="discard-item-icon" class="item-icon">
                    <img src="" alt="Item Icon" > <!-- src s·∫Ω ƒë∆∞·ª£c set b·ªüi JS -->
                </span>
                <div>
                    <strong id="discard-item-name">T√™n V·∫≠t Ph·∫©m</strong>
                    <span>Hi·ªán c√≥: <span id="discard-current-quantity">0</span></span>
                </div>
            </div>
            <div class="discard-quantity-section">
                <label for="discard-quantity-input">S·ªë l∆∞·ª£ng mu·ªën b·ªè:</label>
                <input type="number" id="discard-quantity-input" value="1" min="1" max="1" step="1">
                <span id="discard-quantity-error"></span> <!-- ƒê·ªÉ hi·ªÉn th·ªã l·ªói -->
            </div>
            <div class="popup-buttons">
                <button id="cancel-discard-btn" class="ui-button">H·ªßy B·ªè</button> <!-- C√≥ th·ªÉ d√πng class ui-button -->
                <button id="confirm-discard-btn" class="ui-button" data-item-id="">X√°c Nh·∫≠n B·ªè</button> <!-- data-item-id s·∫Ω ƒë∆∞·ª£c set b·ªüi JS -->
            </div>
        </div>
    </div>
    <!-- K·∫øt th√∫c Popup X√°c Nh·∫≠n B·ªè -->





<!-- [M·ªöI] Popup X√°c Nh·∫≠n B·ªè V·∫≠t Ph·∫©m ƒê√£ Mua -->
    <div id="discard-item-popup" class="modal" style="display: none;">
        <div class="discard-popup-content"> <!-- Class ri√™ng ƒë·ªÉ CSS t√πy ch·ªânh -->
            <span class="close-button" onclick="closeDiscardItemPopup()">√ó</span>
            <h2>X√°c Nh·∫≠n B·ªè V·∫≠t Ph·∫©m</h2>
            <div class="discard-item-info" style="display: flex; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
                <span id="discard-item-icon" class="item-icon" style="margin-right: 10px; flex-shrink: 0;">
                    <img src="" alt="Item Icon" style="max-width: 40px; max-height: 40px; object-fit: contain;">
                </span>
                <div>
                    <strong id="discard-item-name" style="display: block; margin-bottom: 3px;">T√™n V·∫≠t Ph·∫©m</strong>
                    <span style="font-size: 0.85em; color: #666;">Hi·ªán c√≥: <span id="discard-current-quantity">0</span></span>
                </div>
            </div>
            <div class="discard-quantity-section" style="margin-bottom: 20px;">
                <label for="discard-quantity-input" style="display: block; margin-bottom: 5px; font-weight: 500;">S·ªë l∆∞·ª£ng mu·ªën b·ªè:</label>
                <input type="number" id="discard-quantity-input" value="1" min="1" max="1" step="1" style="width: 80px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; text-align: center;">
                <span id="discard-quantity-error" style="color: #e74c3c; font-size: 0.8em; margin-left: 10px; display: none;"></span>
            </div>
            <div class="popup-buttons" style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="cancel-discard-btn" class="ui-button" style="background-color: #7f8c8d;">H·ªßy B·ªè</button>
                <button id="confirm-discard-btn" class="ui-button" style="background-color: #e74c3c;" data-item-id="">X√°c Nh·∫≠n B·ªè</button>
            </div>
        </div>
    </div>
    <!-- K·∫øt th√∫c Popup X√°c Nh·∫≠n B·ªè -->
	
	<!-- [M·ªöI] Modal H√†nh ƒê·ªông C·ªôt Thu L√¥i -->
    <div id="lightning-rod-action-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="rod-action-title">‚ö° C·ªôt Thu L√¥i (√î X)</h2>
                <span class="close-button" onclick="closeModal('lightning-rod-action-modal'); currentActionPlotId = null;">√ó</span>
            </div>
            <div id="rod-status-info" style="text-align: center; margin-bottom: 20px; font-size: 1.1em;">
                <!-- N·ªôi dung c·∫≠p nh·∫≠t b·ªüi JS -->
                S·ª©c kh·ªèe: <span id="rod-health-display">--/--</span>
            </div>
            <div id="rod-action-buttons" style="display: grid; gap: 15px;">
                <!-- C√°c n√∫t ƒë∆∞·ª£c th√™m ƒë·ªông ho·∫∑c c·∫≠p nh·∫≠t -->
                <button id="action-repair-rod" class="action-button repair-rod" style="background-color:#ff9800;">üîß S·ª≠a Ch·ªØa (--üí∞)</button>
                <button id="action-remove-rod" class="action-button remove-rod" style="background-color:#e74c3c;">üóëÔ∏è G·ª° B·ªè</button>
            </div>
        </div>
    </div>

    <!-- [M·ªöI] Popup X√°c Nh·∫≠n S·ª≠a Ch·ªØa C·ªôt Thu L√¥i -->
    <div id="confirm-repair-rod-popup" class="modal confirm-rod-popup"> <!-- D√πng class CSS ri√™ng n·∫øu c·∫ßn -->
        <link rel="stylesheet" href="style-confirm-cotthuloi.css"> <!-- Li√™n k·∫øt CSS -->
        <div class="popup-content">
             <button class="close-popup-btn" onclick="closeConfirmRepairPopup()" aria-label="ƒê√≥ng">√ó</button>
            <h2>X√°c Nh·∫≠n S·ª≠a Ch·ªØa</h2>
            <p id="confirm-repair-message">B·∫°n c√≥ ch·∫Øc mu·ªën s·ª≠a c·ªôt thu l√¥i ·ªü √¥ X v·ªõi gi√° Yüí∞?</p>
            <div class="popup-buttons">
                <button id="cancel-repair-rod-btn">H·ªßy B·ªè</button>
                <button id="confirm-repair-rod-btn" data-plot-id="">X√°c Nh·∫≠n S·ª≠a</button>
            </div>
        </div>
    </div>

    <!-- [M·ªöI] Popup X√°c Nh·∫≠n G·ª° B·ªè C·ªôt Thu L√¥i -->
    <div id="confirm-remove-rod-popup" class="modal confirm-rod-popup"> <!-- D√πng class CSS ri√™ng n·∫øu c·∫ßn -->
         <link rel="stylesheet" href="style-cotthuloi-gobo.css"> <!-- Li√™n k·∫øt CSS -->
        <div class="popup-content">
             <button class="close-popup-btn" onclick="closeConfirmRemovePopup()" aria-label="ƒê√≥ng">√ó</button>
            <h2>X√°c Nh·∫≠n G·ª° B·ªè</h2>
            <p id="confirm-remove-message">B·∫°n c√≥ ch·∫Øc mu·ªën g·ª° b·ªè c·ªôt thu l√¥i ·ªü √¥ X kh√¥ng? (Kh√¥ng th·ªÉ ho√†n t√°c)</p>
             <div class="popup-buttons">
                <button id="cancel-remove-rod-btn">H·ªßy B·ªè</button>
                <button id="confirm-remove-rod-btn" data-plot-id="">X√°c Nh·∫≠n G·ª°</button>
            </div>
        </div>
    </div>
	
	



	<!-- [M·ªöI] Popup H·∫°t Ng·ªçc Tr·ªùi -->
<div id="hat-ngoc-troi-popup" class="modal" style="display: none;"> <!-- D√πng class modal ƒë·ªÉ k·∫ø th·ª´a logic ƒë√≥ng -->
    <div class="hat-ngoc-troi-content"> <!-- Class ri√™ng cho CSS t√πy ch·ªânh -->
        <span class="close-button" onclick="closeHatNgocTroiPopup()">√ó</span> <!-- N√∫t ƒë√≥ng ri√™ng -->
        <h2>üíé H·∫°t Ng·ªçc Tr·ªùi üíé</h2>
        <div class="hat-ngoc-troi-icon">
            <!-- C√≥ th·ªÉ th√™m icon h√¨nh ·∫£nh h·∫°t gi·ªëng ·ªü ƒë√¢y n·∫øu mu·ªën -->
            üå±
        </div>
        <p>M·ªôt h·∫°t gi·ªëng qu√Ω hi·∫øm v·ª´a r∆°i xu·ªëng v∆∞·ªùn c·ªßa b·∫°n! H√£y gi·ªØ g√¨n c·∫©n th·∫≠n nh√©.</p>
        <div class="hat-ngoc-troi-buttons">
            <button onclick="closeHatNgocTroiPopup()">M·ªü h·∫°t Ng·ªçc Tr·ªùi</button>
            <!-- C√≥ th·ªÉ th√™m n√∫t kh√°c n·∫øu c·∫ßn, v√≠ d·ª•: nh·∫≠n v√†o kho -->
        </div>
    </div>
</div>
<!-- K·∫øt th√∫c Popup H·∫°t Ng·ªçc Tr·ªùi -->




    <!-- Modal C·ª≠a H√†ng -->
    <div id="shop-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üõí C·ª≠a H√†ng V·∫≠t Ph·∫©m</h2>
                <span class="close-button" onclick="closeModal('shop-modal')">√ó</span>
            </div>
            <!-- Tab C·ª≠a H√†ng -->
            <div id="shop-tabs" class="tabs-container"> <!-- S·ª≠ d·ª•ng class chung -->
                <button class="tab-button shop-tab-button active" data-tab="seeds">H·∫°t gi·ªëng üå±</button>
                <button class="tab-button shop-tab-button" data-tab="tools">Ph√¢n B√≥n & Thu·ªëc üíä</button>
            </div>
            <!-- Danh s√°ch V·∫≠t Ph·∫©m (H·∫°t gi·ªëng) -->
            <div id="shop-seed-list" class="item-list active-list">
                <p id="shop-seeds-empty-message" class="hidden" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Kh√¥ng c√≥ h·∫°t gi·ªëng n√†o.</p>
            </div>
             <!-- Danh s√°ch V·∫≠t Ph·∫©m (C√¥ng c·ª• - Gi·ªù l√† Ph√¢n B√≥n & Thu·ªëc tr·ª´ s√¢u) -->
            <div id="shop-tool-list" class="item-list">
                 <p id="shop-tools-empty-message" class="hidden" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Kh√¥ng c√≥ v·∫≠t ph·∫©m n√†o.</p>
            </div>
        </div>
    </div>

    <!-- Modal Kho ƒê·ªì -->
    <div id="inventory-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="inventory-modal-title">üéí T√∫i ƒê·ªì C·ªßa B·∫°n</h2>
                <span class="close-button" onclick="closeModal('inventory-modal')">√ó</span>
            </div>
            <!-- Tab Kho ƒê·ªì -->
            <div id="inventory-tabs" class="tabs-container">
                <button class="tab-button inventory-tab-button active" data-tab="harvested">ƒê√£ Thu Ho·∫°ch üß∫</button>
                <button class="tab-button inventory-tab-button" data-tab="purchased">ƒê√£ Mua üõí</button>
            </div>
            <!-- Danh s√°ch V·∫≠t Ph·∫©m ƒê√£ Thu Ho·∫°ch -->
            <div id="inventory-harvested-list" class="item-list active-list">
                <p id="inventory-harvested-empty-message" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Ch∆∞a thu ho·∫°ch ƒë∆∞·ª£c g√¨...</p>
            </div>
            <!-- Danh s√°ch V·∫≠t Ph·∫©m ƒê√£ Mua -->
            <div id="inventory-purchased-list" class="item-list">
                 <p id="inventory-purchased-empty-message" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">Ch∆∞a mua v·∫≠t ph·∫©m n√†o...</p>
            </div>
        </div>
    </div>

     <!-- Modal Ch·ªçn H·∫°t Gi·ªëng -->
    <div id="seed-selection-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üå± Ch·ªçn H·∫°t Gi·ªëng ƒê·ªÉ Tr·ªìng</h2>
                 <span class="close-button" onclick="closeModal('seed-selection-modal'); currentPlantingPlotId = null;">√ó</span>
            </div>
            <div id="seed-selection-list" class="item-list active-list">
                <p id="seed-selection-empty-message" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">B·∫°n kh√¥ng c√≥ h·∫°t gi·ªëng n√†o (trong kho ƒë·ªì ƒë√£ mua) ƒë·ªÉ tr·ªìng.</p>
            </div>
        </div>
    </div>

    <!-- Modal Ch·ªçn Ph√¢n B√≥n -->
    <div id="fertilizer-selection-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üí© Ch·ªçn Ph√¢n B√≥n ƒê·ªÉ S·ª≠ D·ª•ng</h2>
                 <span class="close-button" onclick="closeModal('fertilizer-selection-modal'); currentActionPlotId = null;">√ó</span>
            </div>
            <div id="fertilizer-selection-list" class="item-list active-list">
                <p id="fertilizer-selection-empty-message" style="text-align: center; color: #888; grid-column: 1 / -1; padding: 20px 0;">B·∫°n kh√¥ng c√≥ ph√¢n b√≥n n√†o (trong kho ƒë·ªì ƒë√£ mua).</p>
            </div>
        </div>
    </div>

    <!-- Modal H√†nh ƒê·ªông C√¢y Tr·ªìng -->
    <div id="plant-action-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="plant-action-title">ChƒÉm S√≥c C√¢y Tr·ªìng</h2>
                 <span class="close-button" onclick="closeModal('plant-action-modal'); currentActionPlotId = null;">√ó</span>
            </div>
            <div id="plant-action-buttons">
                <!-- C√°c n√∫t ƒë∆∞·ª£c th√™m ƒë·ªông ho·∫∑c c·∫≠p nh·∫≠t -->
                <!-- N√∫t thu ho·∫°ch & B√°n ngay ƒë∆∞·ª£c th√™m ƒë·ªông L√äN TR√äN n·∫øu c√≥ -->
                <button id="action-treat-pest" class="action-button treat-pest">üíä Tr·ª´ S√¢u</button>
                <button id="action-select-fertilizer" class="action-button select-fertilizer">üí© B√≥n Ph√¢n</button>
                <button id="action-clear-plant" class="action-button clear-plant">‚õèÔ∏è X·ªõi ƒê·∫•t (B·ªè)</button>
            </div>
            <p id="plant-action-info" style="text-align: center; color: #666; margin-top: 15px; font-size: 0.85rem;"></p>
        </div>
    </div>

    <!-- Modal H√†nh ƒê·ªông √î ƒê·∫•t Tr·ªëng -->
    <div id="empty-plot-action-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="empty-plot-action-title">√î ƒê·∫•t Tr·ªëng</h2>
                 <span class="close-button" onclick="closeModal('empty-plot-action-modal'); currentActionPlotId = null;">√ó</span>
            </div>
            <div id="empty-plot-action-buttons">
                <!-- C√°c n√∫t h√†nh ƒë·ªông cho √¥ tr·ªëng s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y b·∫±ng JS -->
            </div>
             <p id="empty-plot-action-info" style="text-align: center; color: #666; margin-top: 15px; font-size: 0.85rem;"></p>
        </div>
    </div>


    <!-- Khu V·ª±c Tin Nh·∫Øn -->
    <div id="message-area">Tin nh·∫Øn m·∫´u</div>
	<div id="locked-plot-popup" class="modal" style="display: none;"> <!-- Th√™m class modal ƒë·ªÉ c√≥ th·ªÉ ƒë√≥ng b·∫±ng Escape -->
        <div class="popup-content">
            <button class="close-popup-btn" aria-label="ƒê√≥ng">√ó</button>
            <h2>M·ªü Kh√≥a √î ƒê·∫•t</h2>
            <p id="locked-plot-message">B·∫°n c√≥ ch·∫Øc mu·ªën m·ªü kh√≥a √¥ ƒë·∫•t n√†y v·ªõi gi√° ...üí∞?</p>
            <div class="popup-buttons">
                <button id="cancel-buy-plot-btn">H·ªßy B·ªè</button>
                <button id="confirm-buy-plot-btn">Mua Ngay</button>
            </div>
        </div>
    </div>
	
	<div id="confirm-sell-all-modal" class="modal confirm-sell-all-modal" style="display: none;"> <!-- Th√™m class t√πy ch·ªânh -->
        <div class="modal-content confirm-sell-all-content"> <!-- Th√™m class t√πy ch·ªânh -->
            <div class="modal-header">
                <h2>X√°c Nh·∫≠n B√°n H·∫øt</h2>
                <span class="close-button" onclick="closeConfirmSellAllModal()">√ó</span>
            </div>
            <div id="confirm-sell-all-details" style="margin-bottom: 20px; line-height: 1.6;">
                <p>B·∫°n c√≥ ch·∫Øc mu·ªën b√°n h·∫øt <strong id="confirm-sell-item-name"></strong>?</p>
                <p>S·ªë l∆∞·ª£ng: <span id="confirm-sell-quantity"></span></p>
                <p>T·ªïng ti·ªÅn nh·∫≠n ƒë∆∞·ª£c: <strong id="confirm-sell-total-value" style="color: #d4af37;"></strong>üí∞</p>
            </div>
            <div class="popup-buttons" style="display: flex; justify-content: flex-end; gap: 10px;"> <!-- T√°i s·ª≠ d·ª•ng class ho·∫∑c t·∫°o class m·ªõi -->
                <button id="cancel-sell-all-btn" class="ui-button" style="background-color: #7f8c8d;">H·ªßy B·ªè</button>
                <button id="confirm-sell-all-btn" class="ui-button" style="background-color: #e74c3c;">X√°c Nh·∫≠n B√°n</button>
            </div>
        </div>
    </div>
	
	<!--  Popup X√°c Nh·∫≠n Kh√¥i Ph·ª•c Game -->
    <div id="popup-confirm-restoregame" class="modal" style="display: none;">
        <!-- Li√™n k·∫øt CSS ri√™ng n·∫øu ch∆∞a c√≥ trong <head> -->
        <!-- <link rel="stylesheet" href="style-popup-confirm-restoregame.css"> -->
        <div class="restore-popup-content"> <!-- Class ri√™ng cho styling -->
            <span class="close-button" aria-label="ƒê√≥ng">√ó</span>
            <h2>X√°c Nh·∫≠n Kh√¥i Ph·ª•c</h2>
            <p id="restore-confirm-message">
                B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën kh√¥i ph·ª•c ti·∫øn tr√¨nh ch∆°i t·ª´ t·ªáp ƒë√£ ch·ªçn kh√¥ng? <br>
                <strong>To√†n b·ªô ti·∫øn tr√¨nh hi·ªán t·∫°i CH∆ØA L∆ØU s·∫Ω b·ªã m·∫•t vƒ©nh vi·ªÖn.</strong>
            </p>
            <div class="popup-buttons">
                <button id="cancel-restore-btn">H·ªßy B·ªè</button>
                <button id="confirm-restore-btn">X√°c Nh·∫≠n Kh√¥i Ph·ª•c</button>
            </div>
        </div>
    </div>
    <!-- K·∫øt th√∫c Popup X√°c Nh·∫≠n Kh√¥i Ph·ª•c Game -->
	
	
	 <!-- Popup Menu Ch√≠nh -->
    <div id="menu-popup" class="modal" style="display: none;"> <!-- D√πng class modal ƒë·ªÉ k·∫ø th·ª´a logic ƒë√≥ng -->
        <div class="menu-popup-content"> <!-- Class ri√™ng cho CSS t√πy ch·ªânh -->
            <span class="close-button" onclick="closeMenuPopup()">√ó</span> <!-- N√∫t ƒë√≥ng ri√™ng -->
            <h2>Menu Ch√≠nh</h2>
            <div class="menu-buttons">
                
                <!-- Th√™m c√°c n√∫t menu kh√°c v√†o ƒë√¢y n·∫øu c·∫ßn -->
				<button id="planting-history-btn" class="menu-action-button">üìú L·ªãch s·ª≠ tr·ªìng c√¢y</button>
				<button id="toggle-sound-btn" class="menu-action-button">üîä B·∫≠t √Çm Thanh</button>
				<button id="toggle-effects-sound-btn" class="menu-action-button">üîä B·∫≠t √Çm Thanh Hi·ªáu ·ª®ng</button>
				<button id="btn-nhiemvuhangngay" class="menu-action-button" style="background-color: #8B4513;">üìÖ Nhi·ªám v·ª• h·∫±ng ng√†y</button>
              
				<button id="export-import-data-btn" class="menu-action-button" style="background-color: #2196F3;">üíæ Xu·∫•t/Nh·∫≠p d·ªØ li·ªáu game</button>
            
			</div>
        </div>
    </div>
	
	<!--  Popup Nhi·ªám V·ª• H·∫±ng Ng√†y -->
    <div id="daily-quest-popup" class="modal" style="display: none;">
        <!-- Li√™n k·∫øt ƒë·∫øn t·ªáp CSS ri√™ng cho popup n√†y -->
        <link rel="stylesheet" href="style-nhiemvuhangngay-popup.css">
        <div class="daily-quest-popup-content"> <!-- Class ri√™ng cho styling -->
            <span class="close-button" onclick="closeModal('daily-quest-popup')" aria-label="ƒê√≥ng">√ó</span>
            <h2>üìÖ Nhi·ªám v·ª• H·∫±ng Ng√†y</h2>
            <div id="daily-quest-list">
                <!-- N·ªôi dung nhi·ªám v·ª• s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y b·∫±ng JavaScript ho·∫∑c HTML tƒ©nh -->
                <p style="text-align: center; padding: 20px; color: #666;">
                    Hi·ªán ch∆∞a c√≥ nhi·ªám v·ª• n√†o.<br>
                    (T√≠nh nƒÉng ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn!)
                </p>
            </div>
            <!-- C√≥ th·ªÉ th√™m c√°c n√∫t kh√°c ·ªü ƒë√¢y n·∫øu c·∫ßn -->
        </div>
    </div>
    <!-- K·∫øt th√∫c Popup Nhi·ªám V·ª• H·∫±ng Ng√†y -->
	
	
	
	<!-- [M·ªöI] Popup Ph·∫ßn Th∆∞·ªüng H·∫°t Ng·ªçc Tr·ªùi -->
    <div id="hat-ngoc-troi-reward-popup" class="modal reward-popup" style="display: none;">
        <div class="reward-popup-content">
            <!-- N√∫t ƒë√≥ng n·∫øu mu·ªën, ho·∫∑c ch·ªâ d√πng n√∫t x√°c nh·∫≠n -->
            <!-- <span class="close-button" onclick="closeRewardPopup()">√ó</span> -->
            <h2>üåü Ph·∫ßn Th∆∞·ªüng H·∫°t Ng·ªçc Tr·ªùi! üåü</h2>
            <p>B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c m·ªôt m√≥n qu√† b·∫•t ng·ªù:</p>
            <div class="reward-item-display">
                <span class="reward-item-icon" id="reward-item-icon">
                    <img id="reward-item-image" src="" alt="Ph·∫ßn th∆∞·ªüng" style="max-width: 60px; max-height: 60px; object-fit: contain;">
                </span>
                <strong id="reward-item-name">T√™n v·∫≠t ph·∫©m</strong>
            </div>
            <p style="font-size: 0.9em; color: #555;">V·∫≠t ph·∫©m ƒë√£ ƒë∆∞·ª£c th√™m v√†o kho "ƒê√£ Mua".</p>
            <div class="reward-popup-buttons">
                <button id="confirm-reward-btn">Tuy·ªát v·ªùi!</button>
            </div>
        </div>
    </div>
    <!-- K·∫øt th√∫c Popup Ph·∫ßn Th∆∞·ªüng -->

	<div id="dark-overlay"></div>
	
	<!-- Popup L∆∞u/Nh·∫≠p Game -->
<div id="menu-savegame-popup" class="modal" style="display: none;">
    <!-- Li√™n k·∫øt ƒë·∫øn t·ªáp CSS ri√™ng cho popup n√†y -->
    <link rel="stylesheet" href="style-savegame-popup-selectmenu.css">
    <div class="savegame-popup-content"> <!-- Class ri√™ng cho styling -->
        <!-- N√∫t ƒë√≥ng popup -->
        <span class="close-button" onclick="closeSavegamePopup()">√ó</span>
        <h2>Xu·∫•t / Nh·∫≠p Ti·∫øn Tr√¨nh</h2>
        <div class="savegame-buttons">
            <!-- N√∫t L∆∞u -->
            <button id="btn-savegame" class="savegame-action-button">üíæ L∆∞u ti·∫øn tr√¨nh tr√≤ ch∆°i</button>
            <!-- N√∫t Nh·∫≠p -->
            <button id="btn-import-savegame" class="savegame-action-button">üì• Nh·∫≠p ti·∫øn tr√¨nh ch∆°i</button>
        </div>
    </div>
</div>
<!-- K·∫øt th√∫c Popup L∆∞u/Nh·∫≠p Game -->




	
	 <!-- <<< TH√äM TH·∫∫ AUDIO T·∫†I ƒê√ÇY >>> -->
    <audio id="background-music" loop preload="auto">
        <source src="nhacnen.mp3" type="audio/mpeg">
        Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ph√°t √¢m thanh.
    </audio>
	<audio id="lightning-sound" preload="auto">
        <source src="Amthanh/tiengsamset.mp3" type="audio/mpeg">
        Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ph√°t √¢m thanh.
    </audio>
	<audio id="rain-sound" loop preload="auto">
    <source src="Amthanh/tiengmuaroi.mp3" type="audio/mpeg">
    Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ph√°t √¢m thanh.
	</audio>
	 <audio id="rainy-sunny-sound" loop preload="auto">
        <source src="Amthanh/tiengmuanang.mp3" type="audio/mpeg">
        Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ph√°t √¢m thanh.
    </audio>
    <!-- <<< K·∫æT TH√öC TH·∫∫ AUDIO >>> -->



    <!-- JavaScript -->
    <script>
      // --- H·∫±ng S·ªë v√† C·∫•u H√¨nh ---
	  // --- [M·ªöI] C·∫•u h√¨nh Nhi·ªám V·ª• H·∫±ng Ng√†y ---
    const QUEST_TYPES = {
        PLANT_SPECIFIC: 'plant_specific', // Tr·ªìng lo·∫°i c√¢y c·ª• th·ªÉ
        PLANT_ANY: 'plant_any',           // Tr·ªìng b·∫•t k·ª≥ lo·∫°i c√¢y n√†o
        HARVEST_SPECIFIC: 'harvest_specific', // Thu ho·∫°ch lo·∫°i c√¢y c·ª• th·ªÉ
        HARVEST_ANY: 'harvest_any',         // Thu ho·∫°ch b·∫•t k·ª≥ lo·∫°i c√¢y n√†o
        SELL_DIRECT_SPECIFIC: 'sell_direct_specific', // B√°n tr·ª±c ti·∫øp lo·∫°i c√¢y c·ª• th·ªÉ
        SELL_HARVESTED_SPECIFIC: 'sell_harvested_specific', // B√°n t·ª´ kho lo·∫°i c√¢y c·ª• th·ªÉ
        USE_FERTILIZER_TYPE: 'use_fertilizer_type', // S·ª≠ d·ª•ng lo·∫°i ph√¢n b√≥n c·ª• th·ªÉ (basic, growth, premium...)
        BUY_FERTILIZER: 'buy_fertilizer', // Mua ph√¢n b√≥n b·∫•t k·ª≥
        BUY_SEED: 'buy_seed',           // Mua h·∫°t gi·ªëng b·∫•t k·ª≥
        EARN_CURRENCY: 'earn_currency'      // Ki·∫øm ƒë∆∞·ª£c m·ªôt l∆∞·ª£ng ti·ªÅn nh·∫•t ƒë·ªãnh (t·ª´ b√°n h√†ng)
    };

    const QUEST_CONFIG = {
        // C·∫•u h√¨nh chi ti·∫øt cho t·ª´ng lo·∫°i quest
        [QUEST_TYPES.PLANT_SPECIFIC]: { minQty: 3, maxQty: 8, baseReward: 5 },
        [QUEST_TYPES.PLANT_ANY]: { minQty: 5, maxQty: 10, baseReward: 3 },
        [QUEST_TYPES.HARVEST_SPECIFIC]: { minQty: 4, maxQty: 10, baseReward: 6 },
        [QUEST_TYPES.HARVEST_ANY]: { minQty: 6, maxQty: 12, baseReward: 4 },
        [QUEST_TYPES.SELL_DIRECT_SPECIFIC]: { minQty: 2, maxQty: 5, baseReward: 7 },
        [QUEST_TYPES.SELL_HARVESTED_SPECIFIC]: { minQty: 5, maxQty: 15, baseReward: 8 },
        [QUEST_TYPES.USE_FERTILIZER_TYPE]: { minQty: 1, maxQty: 3, baseReward: 10 },
        [QUEST_TYPES.BUY_FERTILIZER]: { minQty: 1, maxQty: 3, baseReward: 4 },
        [QUEST_TYPES.BUY_SEED]: { minQty: 3, maxQty: 8, baseReward: 2 },
        [QUEST_TYPES.EARN_CURRENCY]: { minQty: 50, maxQty: 200, baseReward: 15 }
    };

    const NUM_DAILY_QUESTS = 10; // S·ªë l∆∞·ª£ng nhi·ªám v·ª• m·ªói ng√†y
	  
	  
	  
	   const LIGHTNING_ROD_MAX_HEALTH = 20; // S·ªë l·∫ßn ch·ªãu s√©t t·ªëi ƒëa
      const LIGHTNING_ROD_INITIAL_REPAIR_COST = 300; // Ph√≠ s·ª≠a l·∫ßn ƒë·∫ßu
      const LIGHTNING_ROD_REPAIR_COST_MULTIPLIER = 1.3; // H·ªá s·ªë nh√¢n ph√≠ s·ª≠a
      const LIGHTNING_ROD_PROTECTION_RANGE = 4; // S·ªë √¥ b·∫£o v·ªá m·ªói b√™n (t·ªïng 4+1+4 = 9 √¥)
      const LIGHTNING_ROD_ITEM_ID = 'cotthuloi'; // ID v·∫≠t ph·∫©m c·ªôt thu l√¥i

	  const INITIAL_MAX_INVENTORY_CAPACITY = 50; // <<< GI·ªöI H·∫†N M·ªöI CHO T·ªîNG S·ªê L∆Ø·ª¢NG KHO ƒê·ªí
      
               const DRY_HEALTH_DRAIN_PER_TICK = 0.3; // L∆∞·ª£ng m√°u c√¢y m·∫•t m·ªói gi√¢y khi kh√¥ (c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh)
        const DRY_FERTILITY_DRAIN_PER_TICK = 0.02; // L∆∞·ª£ng % ph√¨ nhi√™u ƒë·∫•t tr·ªëng m·∫•t m·ªói gi√¢y khi kh√¥ (0.02% = 1.2%/ph√∫t)
		// C·∫•u h√¨nh S√©t ƒê√°nh (Thunderstorm - C√ì S√ÅT TH∆Ø∆†NG)
const THUNDERSTORM_STRIKE_CHANCE_PER_TICK = 0.03; // 3% m·ªói gi√¢y KHI C√ì M∆ØA S√âT
const STRIKE_DURATION_MS = 1000;   // 2 gi√¢y hi·ªáu ·ª©ng
const PLANT_HEALTH_DAMAGE = 40;    // S√°t th∆∞∆°ng m√°u c√¢y (Thunderstorm)
const SOIL_FERTILITY_DAMAGE = 20;  // S√°t th∆∞∆°ng ƒë·ªô ph√¨ ƒë·∫•t tr·ªëng (Thunderstorm)
	  // [M·ªöI] C·∫•u h√¨nh S√©t ƒê√°nh H√¨nh ·∫¢nh (Lightning - KH√îNG S√ÅT TH∆Ø∆†NG)
const LIGHTNING_VISUAL_STRIKE_CHANCE_PER_TICK = 0.025; // 2.5% m·ªói gi√¢y KHI CH·ªà C√ì S√âT (c√≥ th·ªÉ ch·ªânh)
 const LIGHTNING_PLANT_DAMAGE = 30; // <<< TH√äM: S√°t th∆∞∆°ng m√°u c√¢y (Lightning) >>>
        const LIGHTNING_SOIL_DAMAGE = 20;  // <<< TH√äM: S√°t th∆∞∆°ng ƒë·ªô ph√¨ ƒë·∫•t tr·ªëng (Lightning) >>>
		
		
		// ƒê·ªãnh nghƒ©a kho·∫£ng th·ªùi gian ng·∫´u nhi√™n cho H·∫°t Ng·ªçc Tr·ªùi
		const MIN_HAT_NGOC_TROI_DELAY_MS = 3 * 60 * 1000; // 3 ph√∫t
      const MAX_HAT_NGOC_TROI_DELAY_MS = 10 * 60 * 1000; // 10 ph√∫t

		// C·∫•u h√¨nh Gi√≥ L·ªëc (Windy) - ƒê√É C·∫¨P NH·∫¨T T√äN
const TORNADO_EVENT_MIN_INTERVAL_MS_WINDY = 120 * 1000; // √çt nh·∫•t 120 gi√¢y (2 ph√∫t) <<< S·ª¨A L·ªñI MIN/MAX
        const TORNADO_EVENT_MAX_INTERVAL_MS_WINDY = 180 * 1000; // Nhi·ªÅu nh·∫•t 180 gi√¢y (3 ph√∫t) <<< S·ª¨A L·ªñI MIN/MAX
        const TORNADO_EFFECT_DURATION_MS_WINDY = 8 * 1000;       // Th·ªùi gian hi·ªáu ·ª©ng h√¨nh ·∫£nh V√Ä g√¢y s√°t th∆∞∆°ng: 8 gi√¢y <<< TƒÇNG TH·ªúI GIAN
        const TORNADO_DESTRUCTION_CHANCE = 0.25;                 // 25% kh·∫£ nƒÉng ph√° h·ªßy ho√†n to√†n (100% damage) <<< X√ÅC SU·∫§T M·ªöI
        const TORNADO_PARTIAL_DAMAGE_FACTOR = 0.80;              // 80% s√°t th∆∞∆°ng n·∫øu kh√¥ng b·ªã ph√° h·ªßy ho√†n to√†n <<< S√ÅT TH∆Ø∆†NG M·ªòT PH·∫¶N


        // ============================
		// --- H·∫±ng S·ªë Ch·∫•t L∆∞·ª£ng Thu Ho·∫°ch ---
const QUALITY_TIERS = {
    PERFECT: 'perfect', // 95-100% HP
    GOOD: 'good',       // 70-94% HP
    FAIR: 'fair',       // 30-69% HP
    POOR: 'poor'        // 1-29% HP
};

const QUALITY_THRESHOLDS = {
    [QUALITY_TIERS.PERFECT]: 95,
    [QUALITY_TIERS.GOOD]: 70,
    [QUALITY_TIERS.FAIR]: 30,
    [QUALITY_TIERS.POOR]: 1 // Ch·ªâ c·∫ßn > 0
};

const QUALITY_VALUE_MULTIPLIERS = {
    [QUALITY_TIERS.PERFECT]: 1.0,
    [QUALITY_TIERS.GOOD]: 0.85, // ƒêi·ªÅu ch·ªânh n·∫øu mu·ªën (VD: 0.85)
    [QUALITY_TIERS.FAIR]: 0.65,  // ƒêi·ªÅu ch·ªânh n·∫øu mu·ªën (VD: 0.65)
    [QUALITY_TIERS.POOR]: 0.4   // ƒêi·ªÅu ch·ªânh n·∫øu mu·ªën (VD: 0.4)
};

const QUALITY_DISPLAY_NAMES = {
    [QUALITY_TIERS.PERFECT]: '‚ú®Ho√†n h·∫£o',
    [QUALITY_TIERS.GOOD]: 'üëçT·ªët',
    [QUALITY_TIERS.FAIR]: 'üëåTh∆∞·ªùng',
    [QUALITY_TIERS.POOR]: '‚ùåK√©m'
};
// --- K·∫øt th√∫c H·∫±ng S·ªë Ch·∫•t L∆∞·ª£ng ---
		
		
		
		
		
		
		
		// ƒê·ªãnh nghƒ©a d·ªØ li·ªáu th·ªùi ti·∫øt v·ªõi ID, icon v√† t√™n
const WEATHER_DATA = [
    { id: 'sunny',       icon: '‚òÄÔ∏è', name: 'N·∫Øng g·∫Øt' },
    { id: 'rainy',       icon: 'üåßÔ∏è', name: 'C√≥ m∆∞a' },
    { id: 'thunderstorm',icon: '‚õàÔ∏è', name: 'M∆∞a v√† s·∫•m s√©t' },
    { id: 'rainy_sunny', icon: 'üå¶Ô∏è', name: 'C√≥ m∆∞a v√† n·∫Øng' },
    { id: 'lightning',   icon: 'üå©Ô∏è', name: 'C√≥ s·∫•m s√©t' },
    { id: 'cloudy',      icon: '‚òÅÔ∏è', name: 'C√≥ m√¢y' },
    { id: 'windy',       icon: 'üå™Ô∏è', name: 'C√≥ gi√≥ l·ªëc' } // Gi·∫£ s·ª≠ icon cu·ªëi l√† gi√≥ l·ªëc/tornado
];
		// C·∫•u h√¨nh Gi√≥ L·ªëc (Windy)
const TORNADO_EVENT_MIN_INTERVAL_MS = 60 * 1000; // 60 gi√¢y
const TORNADO_EVENT_MAX_INTERVAL_MS = 120 * 1000; // 120 gi√¢y
const TORNADO_MIN_DURATION_MS = 5 * 1000;       // 5 gi√¢y
const TORNADO_MAX_DURATION_MS = 10 * 1000;      // 10 gi√¢y
const TORNADO_MAX_SPAWN_COUNT = 2;              // S·ªë l∆∞·ª£ng l·ªëc t·ªëi ƒëa xu·∫•t hi·ªán m·ªói l·∫ßn
const TORNADO_HEALTH_DAMAGE_PER_TICK = 0.05;    // 5% m√°u c√¢y m·ªói gi√¢y
const TORNADO_FERTILITY_DAMAGE_PER_TICK = 0.05; // 5% ƒë·ªô ph√¨ ƒë·∫•t tr·ªëng m·ªói gi√¢y
		
		
		
		
		
		
		 const WEATHER_CHANGE_INTERVAL_MS = 5 * 60 * 1000; // 5 ph√∫t (300,000 ms)
       const WEATHER_ICONS = ['‚òÄÔ∏è N·∫Øng g·∫Øt', 'üåßÔ∏è C√≥ m∆∞a', '‚õàÔ∏è M∆∞a v√† s·∫•m s√©t', 'üå¶Ô∏è C√≥ m∆∞a v√† n·∫Øng', 'üå©Ô∏è C√≥ s·∫•m s√©t', '‚òÅÔ∏è C√≥ m√¢y', 'üå™Ô∏è']; // [PHI√äN B·∫¢N C·∫¨P NH·∫¨T V9.3 - Random Pest Per Plot (Online/Offline)]
        console.log("ƒêang t·∫£i Script V∆∞·ªùn C√¢y (v9.3 - Random Pest)...");

        // C·∫•u h√¨nh Game
        const INITIAL_PLOT_COUNT = 6;       // S·ªë √¥ b·∫Øt ƒë·∫ßu
        const INITIAL_CURRENCY = 10;        // Ti·ªÅn kh·ªüi ƒëi·ªÉm
        const BASE_PLOT_COST_FOR_7TH = 300;         // Gi√° √¥ ƒë·∫•t th·ª© 7 (index 6)
		
        const PLOT_COST_MULTIPLIER = 2;     // H·ªá s·ªë nh√¢n gi√° √¥ ƒë·∫•t ti·∫øp theo (G·∫§P ƒê√îI)
        const INITIAL_PESTICIDE = 1;        // S·ªë thu·ªëc tr·ª´ s√¢u ban ƒë·∫ßu
        const INITIAL_PLANT_HEALTH = 100;   // M√°u c√¢y t·ªëi ƒëa
        const BASE_FERTILITY = 100;         // ƒê·ªô ph√¨ nhi√™u ƒë·∫•t t·ªëi ƒëa %
        const LOW_FERTILITY_THRESHOLD = 25; // D∆∞·ªõi m·ª©c n√†y, hi·ªán c·∫£nh b√°o UI (thanh bar)
        const BARREN_HARVEST_PENALTY_MULTIPLIER = 1.3; // H·ªá s·ªë nh√¢n th·ªùi gian khi thu ho·∫°ch tr√™n ƒë·∫•t c·∫±n
        const GAME_SAVE_KEY = 'vuonCayHanhPhuc_v9.3_RandomPest'; // <<<KH√ìA L∆ØU
        const TICK_INTERVAL = 1000;         // 1 gi√¢y m·ªôt tick (1000ms)
        const PLANT_GROWTH_STAGES = 4;      // S·ªë giai ƒëo·∫°n h√¨nh ·∫£nh c√¢y
        const MESSAGE_DISPLAY_TIME = 3800;  // Th·ªùi gian hi·ªÉn th·ªã tin nh·∫Øn (ms)
        const TOOLTIP_DELAY = 350;          // ƒê·ªô tr·ªÖ hi·ªÉn th·ªã tooltip (ms)
        const AUTO_SAVE_INTERVAL_TICKS = 60;// T·ª± ƒë·ªông l∆∞u m·ªói 60 tick (60 gi√¢y)
        const HEALTH_REGEN_PER_TICK = 0.2;  // L∆∞·ª£ng m√°u h·ªìi m·ªói tick
        const DEAD_PEST_CLEANUP_COST = 2;  // Ph√≠ d·ªçn c√¢y ch·∫øt do s√¢u
        const DEAD_PEST_FREE_CLEANUP_CLICKS = 20; // S·ªë l·∫ßn click ƒë·ªÉ d·ªçn mi·ªÖn ph√≠
        const PEST_DAMAGE_PER_TICK = 0.5;   // S√°t th∆∞∆°ng s√¢u m·ªói tick (cho c√¢y ƒëang l·ªõn)
        const PEST_DAMAGE_MATURE_REDUCTION_FACTOR = 0.5; // H·ªá s·ªë gi·∫£m s√°t th∆∞∆°ng s√¢u cho c√¢y tr∆∞·ªüng th√†nh
        const HISTORY_SAVE_KEY = 'vuonCayHanhPhuc_v9.3_History'; // C·∫≠p nh·∫≠t c·∫£ kh√≥a l·ªãch s·ª≠ n·∫øu mu·ªën t√°ch bi·ªát
		const MAX_HISTORY_ENTRIES = 150; // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng m·ª•c l·ªãch s·ª≠
		const MUSIC_ENABLED_KEY = 'vuonCayHanhPhuc_v9.3_musicEnabled'; // <<< KH√ìA L∆ØU TR·∫†NG TH√ÅI NH·∫†C N·ªÄN
		
const EFFECTS_ENABLED_KEY = 'vuonCayHanhPhuc_v9.3_effectsEnabled' // <<< KH√ìA L∆ØU TR·∫†NG TH√ÅI HI·ªÜU ·ª®NG
        // --- [M·ªöI Req - Random Pest] C·∫•u h√¨nh S√¢u B·ªánh Ng·∫´u Nhi√™n ---
        const PEST_APPEARANCE_CHANCE_PER_TICK_PER_PLOT = 0.0002; // T·ªâ l·ªá s√¢u xu·∫•t hi·ªán m·ªói gi√¢y TR√äN M·ªñI √î ƒê·∫§T H·ª¢P L·ªÜ (0.02%) - C·∫ßn ƒëi·ªÅu ch·ªânh!
        const FERTILIZER_GROWTH_MAX_USES = 3; // Gi·ªõi h·∫°n s·ª≠ d·ª•ng Ph√¢n B√≥n TƒÉng Tr∆∞·ªüng m·ªói c√¢y
		

        // --- D·ªØ Li·ªáu V·∫≠t Ph·∫©m (H·∫°t Gi·ªëng & Ph√¢n B√≥n) ---
        // =======================================================================
        // (Gi·ªØ nguy√™n nh∆∞ v9.2, kh√¥ng c·∫ßn thay ƒë·ªïi ITEM_DATA cho y√™u c·∫ßu n√†y)
       const ITEM_DATA = {
            // H·∫°t gi·ªëng (id, type, name, imageFolder, price, harvestYield(GI√Å TR·ªä B√ÅN M·ªñI ƒê∆†N V·ªä!), growthTime(gi√¢y!), fertilityCost(0-1!))
            'hanhla':   { id: 'hanhla', type: 'seed', name: 'H√†nh l√°', imageFolder: 'Hanhla', price: 1, harvestYield: 2, growthTime: 60, fertilityCost: 0.05 },         // 1p, PPM 1.00, Hao 5% (Gi·ªØ nguy√™n)
            'namrom':   { id: 'namrom', type: 'seed', name: 'N·∫•m r∆°m', imageFolder: 'Namrom', price: 3, harvestYield: 6, growthTime: 60, fertilityCost: 0.05 },         // 1p, PPM 3.00, Hao 5% (Gi·ªØ nguy√™n)
            'raumuong': { id: 'raumuong', type: 'seed', name: 'Rau mu·ªëng', imageFolder: 'Raumuong', price: 1, harvestYield: 4, growthTime: 120, fertilityCost: 0.06 }, // 2p, PPM 1.50, Hao 6% (TƒÉng yield)
            'caithia':  { id: 'caithia', type: 'seed', name: 'C·∫£i th√¨a', imageFolder: 'Caithia', price: 1, harvestYield: 4, growthTime: 120, fertilityCost: 0.07 },     // 2p, PPM 1.50, Hao 7% (Gi·ªØ nguy√™n)
            'dualeo':   { id: 'dualeo', type: 'seed', name: 'D∆∞a leo', imageFolder: 'Dualeo', price: 2, harvestYield: 5, growthTime: 120, fertilityCost: 0.08 },       // 2p, PPM 1.50, Hao 8% (Gi·ªØ nguy√™n)
            'carot':    { id: 'carot', type: 'seed', name: 'C√† r·ªët', imageFolder: 'Carot', price: 1, harvestYield: 5, growthTime: 180, fertilityCost: 0.09 },         // 3p, PPM 1.33, Hao 9% (Gi·ªØ nguy√™n)
            'cachua':   { id: 'cachua', type: 'seed', name: 'C√† chua', imageFolder: 'Cachua', price: 1, harvestYield: 6, growthTime: 180, fertilityCost: 0.04 },     // 3p, PPM 1.67, Hao 4% (TƒÉng m·∫°nh yield)
            'bapcai':   { id: 'bapcai', type: 'seed', name: 'B·∫Øp c·∫£i', imageFolder: 'Bapcai', price: 2, harvestYield: 6, growthTime: 180, fertilityCost: 0.08 },       // 3p, PPM 1.33, Hao 8% (Gi·ªØ nguy√™n)
            'bap':      { id: 'bap', type: 'seed', name: 'B·∫Øp (Ng√¥)', imageFolder: 'Bap', price: 4, harvestYield: 8, growthTime: 180, fertilityCost: 0.09 },         // 3p, PPM 1.33, Hao 9% (Gi·ªØ nguy√™n)
            'hanhtay':  { id: 'hanhtay', type: 'seed', name: 'H√†nh t√¢y', imageFolder: 'Hanhtay', price: 5, harvestYield: 9, growthTime: 180, fertilityCost: 0.08 }, // 3p, PPM 1.33, Hao 8% (TƒÉng nh·∫π hao ƒë·∫•t)
            'bido':     { id: 'bido', type: 'seed', name: 'B√≠ ƒë·ªè', imageFolder: 'Bido', price: 5, harvestYield: 9, growthTime: 180, fertilityCost: 0.08 },         // 3p, PPM 1.33, Hao 8% (Gi·ªØ nguy√™n)
            'khoaitay': { id: 'khoaitay', type: 'seed', name: 'Khoai t√¢y', imageFolder: 'Khoaitay', price: 2, harvestYield: 6, growthTime: 180, fertilityCost: 0.08 }, // 3p, PPM 1.33, Hao 8% (TƒÉng nh·∫π hao ƒë·∫•t)
            'toi':      { id: 'toi', type: 'seed', name: 'T·ªèi', imageFolder: 'Toi', price: 3, harvestYield: 7, growthTime: 180, fertilityCost: 0.09 },             // 3p, PPM 1.33, Hao 9% (Gi·ªØ nguy√™n)
            'khoailang':{ id: 'khoailang', type: 'seed', name: 'Khoai lang', imageFolder: 'Khoailang', price: 5, harvestYield: 9, growthTime: 180, fertilityCost: 0.08 }, // 3p, PPM 1.33, Hao 8% (Gi·ªØ nguy√™n)
            'suplo':    { id: 'suplo', type: 'seed', name: 'S√∫p l∆°', imageFolder: 'Suplo', price: 10, harvestYield: 20, growthTime: 240, fertilityCost: 0.10 },      // 4p, PPM 2.50, Hao 10% (Gi·ªØ nguy√™n)
            'othiem':   { id: 'othiem', type: 'seed', name: '·ªöt hi·ªÉm', imageFolder: 'Othiem', price: 3, harvestYield: 11, growthTime: 240, fertilityCost: 0.08 },    // 4p, PPM 2.00, Hao 8% (TƒÉng yield)
            'dudu':     { id: 'dudu', type: 'seed', name: 'ƒêu ƒë·ªß', imageFolder: 'Dudu', price: 3, harvestYield: 18, growthTime: 360, fertilityCost: 0.11 },      // 6p, PPM 2.50, Hao 11% (TƒÉng m·∫°nh yield)
            'chuoi':    { id: 'chuoi', type: 'seed', name: 'Chu·ªëi', imageFolder: 'Chuoi', price: 4, harvestYield: 28, growthTime: 540, fertilityCost: 0.12 },      // 9p, PPM 2.67, Hao 12% (TƒÉng c·ª±c m·∫°nh yield)
            'mangtay':  { id: 'mangtay', type: 'seed', name: 'MƒÉng t√¢y', imageFolder: 'Mangtay', price: 12, harvestYield: 33, growthTime: 720, fertilityCost: 0.15 }, // 12p, PPM 1.75, Hao 15% (TƒÉng nh·∫π yield)

             // C√¥ng c·ª• (Thu·ªëc tr·ª´ s√¢u + Ph√¢n B√≥n + C·ªôt thu l√¥i) - Gi·ªØ nguy√™n
             'pesticide': {
                id: 'pesticide', type: 'tool', name: 'Thu·ªëc Tr·ª´ S√¢u',
                imageFolder: 'Hinhanh/Thuoctrusau', imageFile: 'Thuoctrusau1.png',
                price: 2,
                description: 'Lo·∫°i b·ªè s√¢u b·ªánh kh·ªèi m·ªôt c√¢y tr·ªìng.'
             },
            'fertilizer_basic': {
                id: 'fertilizer_basic', type: 'tool', name: 'Ph√¢n B√≥n C∆° B·∫£n', imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanboncoban.png',
                price: 2,
                fertilityBoost: 0.20, description: 'B·ªï sung 20% ƒë·ªô ph√¨ nhi√™u cho ƒë·∫•t.'
            },
            'fertilizer_growth': {
                id: 'fertilizer_growth', type: 'tool', name: 'Ph√¢n B√≥n TƒÉng Tr∆∞·ªüng',
                imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanbontangtruong.png',
                // price: 20, // Gi√° c≈©
                price: 15, // <<< GI√Å M·ªöI
                // fertilityBoost: 0.30, // <<< X√ìA B·ªé
                growthTimeReductionPercent: 0.05, // <<< TH√äM: Gi·∫£m 5% th·ªùi gian c√≤n l·∫°i
                healthBoostPercent: 0.20, // <<< TH√äM: TƒÉng 20% m√°u (so v·ªõi max)
                usageLimitPerPlant: 3, // <<< TH√äM: Gi·ªõi h·∫°n s·ª≠ d·ª•ng
                // description: 'B·ªï sung 30% ƒë·ªô ph√¨ nhi√™u cho ƒë·∫•t.' // M√¥ t·∫£ c≈©
                description: 'Gi·∫£m 5% th·ªùi gian ph√°t tri·ªÉn c√≤n l·∫°i v√† tƒÉng 20% s·ª©c kho c√¢y (T·ªëi ƒëa 3 l·∫ßn/c√¢y).' // <<< M√î T·∫¢ M·ªöI
            },
			
			
			
			
			
			
           'fertilizer_protect': {
                id: 'fertilizer_protect', type: 'tool', name: 'Ph√¢n B√≥n B·∫£o V·ªá',
                imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanbonbaove.png',
                // --- THAY ƒê·ªîI ---
                price: 30, // Gi√° m·ªõi
                fertilityBoost: 0.20, // 20% ƒë·ªô ph√¨
                pestProtectionFactor: 0.5, // <<< TH√äM: Gi·∫£m 50% t·ªâ l·ªá s√¢u xu·∫•t hi·ªán (gi√° tr·ªã 0.5)
                usageLimitPerPlant: 3,     // <<< TH√äM: Gi·ªõi h·∫°n 3 l·∫ßn/c√¢y
                description: 'B·ªï sung 20% ƒë·ªô ph√¨ & gi·∫£m t·ªâ l·ªá s√¢u b·ªánh (T·ªëi ƒëa 3 l·∫ßn/c√¢y).' // <<< M√î T·∫¢ M·ªöI (Ti·∫øng Vi·ªát)
                
            },
            'fertilizer_premium': {
                id: 'fertilizer_premium', type: 'tool', name: 'Ph√¢n B√≥n Cao C·∫•p', imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanboncaocap.png',
                price: 40, fertilityBoost: 0.60, description: 'B·ªï sung 60% ƒë·ªô ph√¨ nhi√™u cho ƒë·∫•t.'
            },
            'fertilizer_special': {
                id: 'fertilizer_special', type: 'tool', name: 'Ph√¢n B√≥n ƒê·∫∑c Bi·ªát', imageFolder: 'Hinhanh/Phanbon', imageFile: 'Phanbondacbiet.png',
                price: 60, fertilityBoost: 0.80, description: 'B·ªï sung 80% ƒë·ªô ph√¨ nhi√™u cho ƒë·∫•t.'
            },
			 // --- Th√™m C·ªôt Thu L√¥i ---
            'cotthuloi': {
                id: 'cotthuloi', type: 'tool', name: 'C·ªôt thu l√¥i',
                imageFolder: 'Hinhanh', // Th∆∞ m·ª•c ch·ª©a ·∫£nh
                imageFile: 'pic_cotthuloi.png', // T√™n file ·∫£nh
                price: 2000,
                description: 'Gi·∫£m thi·ªÉu t√°c h·∫°i c·ªßa s√©t ƒë√°nh v√†o v∆∞·ªùn.' // M√¥ t·∫£ ch·ª©c nƒÉng (hi·ªán t·∫°i ch·ªâ ƒë·ªÉ hi·ªÉn th·ªã)
            },
			 // ---  Th√™m R√†o B·∫£o V·ªá ---
            'raobaove': {
                id: 'raobaove', type: 'tool', name: 'R√†o b·∫£o v·ªá',
                imageFolder: 'Hinhanh',         // Th∆∞ m·ª•c ch·ª©a ·∫£nh
                imageFile: 'pic_hangrao.png',    // ·∫¢nh h√†ng r√†o b√¨nh th∆∞·ªùng
                brokenImageFile: 'pic_hangrao_bihong.png', // ·∫¢nh h√†ng r√†o h·ªèng
                price: 40,                     // Gi√° b√°n
                health: 100,                    // S·ª©c kh·ªèe ban ƒë·∫ßu (max health)
                removeCost: 5,                  // Ph√≠ g·ª° b·ªè khi h·ªèng
                description: 'B·∫£o v·ªá c√¢y kh·ªèi gi√≥ l·ªëc. C√≥ th·ªÉ b·ªã h·ªèng v√† c·∫ßn g·ª° b·ªè.' // M√¥ t·∫£
            },
			// --- Th√™m V·∫≠t Ph·∫©m N√¢ng C·∫•p Kho ƒê·ªì ---
    'Balocaocap': {
        id: 'Balocaocap', type: 'upgrade', name: 'Balo cao c·∫•p',
        imageFolder: 'Hinhanh', imageFile: 'pic_balo_200.png',
        price: 300,
        upgradeCapacity: { from: 50, to: 200 }, // N√¢ng t·ª´ 50 l√™n 200
        description: 'M·ªü r·ªông kho ƒë·ªì c·ªßa b·∫°n l√™n 200 ch·ªó.'
    },
    'Nhakholv1': {
        id: 'Nhakholv1', type: 'upgrade', name: 'Nh√† kho level 1',
        imageFolder: 'Hinhanh', imageFile: 'pic_nangcapnongtrai.png',
        price: 5000,
        upgradeCapacity: { from: 200, to: 2000 }, // N√¢ng t·ª´ 200 l√™n 2000
        description: 'N√¢ng c·∫•p nh√† kho, tƒÉng s·ª©c ch·ª©a l√™n 2000 ch·ªó.'
    }
    // --- K·∫øt th√∫c th√™m V·∫≠t Ph·∫©m N√¢ng C·∫•p ---
			
            // --- K·∫øt th√∫c th√™m C·ªôt Thu L√¥i ---
        };

        // --- Tr·∫°ng Th√°i Game ---
// ====================
let gameState = {
    currency: INITIAL_CURRENCY,
    plots: [], // M·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng √¥ ƒë·∫•t { ..., fertility, causeOfDeath, pestDeathClickCount, barrenHarvestPenaltyFactor }
    maxInventoryCapacity: INITIAL_MAX_INVENTORY_CAPACITY, // <<< S·ª©c ch·ª©a t·ªëi ƒëa hi·ªán t·∫°i
	maxUnlockedPlots: INITIAL_PLOT_COUNT,
	
    inventory: { // Kho ƒë·ªì v·∫≠t ph·∫©m ƒê√É MUA
         pesticide: INITIAL_PESTICIDE
         // H·∫°t gi·ªëng & Ph√¢n b√≥n ƒë∆∞·ª£c th√™m ƒë·ªông khi mua
    },
    harvestedItems: { // Kho ƒë·ªì v·∫≠t ph·∫©m ƒê√É THU HO·∫†CH
        // V√≠ d·ª•: 'hanhla': 5, 'cachua': 2
    },
    lastUpdateTimestamp: Date.now(),
    gameStartTime: Date.now(),
    totalPlayTime: 0,
    actionHistory: [], // <<< Gi·ªØ nguy√™n: M·∫£ng l∆∞u l·ªãch s·ª≠ h√†nh ƒë·ªông
    // --- KH√îNG C√íN TR·∫†NG TH√ÅI PEST EVENT ---
    // isPestEventActive: false,
    // pestEventStartTime: 0
	
	 currentWeather: WEATHER_DATA[0],             // <<< THAY ƒê·ªîI: L∆∞u c·∫£ object, m·∫∑c ƒë·ªãnh l√† sunny {id, icon, name}
    nextWeatherChangeTimestamp: 0,               // Timestamp (ms) c·ªßa l·∫ßn ƒë·ªïi th·ªùi ti·∫øt k·∫ø ti·∫øp
    currentWeatherStartTime: 0,                  // Timestamp b·∫Øt ƒë·∫ßu chu k·ª≥ th·ªùi ti·∫øt hi·ªán t·∫°i
	nextDryCheckTimestamp: 0, // <<< BI·∫æN THEO D√ïI CHECK KH√î H·∫†N >>>
	 activeTornadoes: [],                // M·∫£ng s·∫Ω ch·ª©a { plotId, expireTimestamp, isDestruction } <-- c·∫•u tr√∫c m·ªõi khi s·ª≠ d·ª•ng
    lightningRods: [], // <<< M·ªöI: M·∫£ng ch·ª©a th√¥ng tin c√°c c·ªôt thu l√¥i ƒë√£ ƒë·∫∑t
	nextTornadoEventTimestamp: 0,
	maxInventoryCapacity: INITIAL_MAX_INVENTORY_CAPACITY,
	// === NHI·ªÜM V·ª§ H·∫∞NG NG√ÄY ===
    dailyQuests: [],         // M·∫£ng ch·ª©a 10 ƒë·ªëi t∆∞·ª£ng nhi·ªám v·ª• c·ªßa ng√†y hi·ªán t·∫°i
    lastQuestResetDate: null // Chu·ªói 'YYYY-MM-DD' c·ªßa l·∫ßn reset nhi·ªám v·ª• cu·ªëi
    // ========================================
	
};

		// --- H√†m Ti·ªán √çch M·ªõi: Ghi L·ªãch S·ª≠ H√†nh ƒê·ªông ---
		function compareQuests(a, b) {
    // ∆Øu ti√™n 1: Nhi·ªám v·ª• CH∆ØA NH·∫¨N TH∆Ø·ªûNG l√™n tr∆∞·ªõc
    if (a.isClaimed && !b.isClaimed) {
        return 1; // a (ƒë√£ nh·∫≠n) xu·ªëng d∆∞·ªõi b (ch∆∞a nh·∫≠n)
    }
    if (!a.isClaimed && b.isClaimed) {
        return -1; // a (ch∆∞a nh·∫≠n) l√™n tr√™n b (ƒë√£ nh·∫≠n)
    }
    // N·∫øu c·∫£ hai c√πng tr·∫°ng th√°i ƒë√£ nh·∫≠n ho·∫∑c ch∆∞a nh·∫≠n...

    // ∆Øu ti√™n 2: N·∫øu c·∫£ hai ƒë·ªÅu CH∆ØA NH·∫¨N, th√¨ nhi·ªám v·ª• HO√ÄN TH√ÄNH l√™n tr∆∞·ªõc
    if (!a.isClaimed && !b.isClaimed) {
        if (a.isCompleted && !b.isCompleted) {
            return -1; // a (ho√†n th√†nh) l√™n tr√™n b (ch∆∞a ho√†n th√†nh)
        }
        if (!a.isCompleted && b.isCompleted) {
            return 1; // a (ch∆∞a ho√†n th√†nh) xu·ªëng d∆∞·ªõi b (ho√†n th√†nh)
        }
    }

    // N·∫øu c·∫£ hai ƒë√£ nh·∫≠n HO·∫∂C c·∫£ hai ch∆∞a nh·∫≠n v√† c√πng tr·∫°ng th√°i ho√†n th√†nh
    // -> gi·ªØ nguy√™n th·ª© t·ª± t∆∞∆°ng ƒë·ªëi (ho·∫∑c c√≥ th·ªÉ th√™m ti√™u ch√≠ ph·ª• nh∆∞ ph·∫ßn th∆∞·ªüng)
    return 0;
}
		// --- C√°c H√†m M√£ H√≥a/Gi·∫£i M√£ Base64 (X·ª≠ l√Ω Unicode) ---
    /**
     * M√£ h√≥a m·ªôt chu·ªói (bao g·ªìm Unicode) th√†nh Base64.
     * @param {string} str Chu·ªói c·∫ßn m√£ h√≥a.
     * @returns {string} Chu·ªói Base64.
     */
    function encodeStringToBase64(str) {
        try {
            // 1. Chuy·ªÉn chu·ªói UTF-16 th√†nh m·∫£ng byte UTF-8
            const utf8Bytes = new TextEncoder().encode(str);
            // 2. Chuy·ªÉn m·∫£ng byte th√†nh chu·ªói nh·ªã ph√¢n (m·ªói byte l√† m·ªôt k√Ω t·ª±)
            let binaryString = '';
            utf8Bytes.forEach(byte => {
                binaryString += String.fromCharCode(byte);
            });
            // 3. M√£ h√≥a chu·ªói nh·ªã ph√¢n b·∫±ng btoa
            return btoa(binaryString);
        } catch (e) {
            console.error("L·ªói khi m√£ h√≥a Base64:", e);
            return null; // Tr·∫£ v·ªÅ null n·∫øu l·ªói
        }
    }

    /**
     * Gi·∫£i m√£ m·ªôt chu·ªói Base64 th√†nh chu·ªói g·ªëc (x·ª≠ l√Ω Unicode).
     * @param {string} base64Str Chu·ªói Base64 c·∫ßn gi·∫£i m√£.
     * @returns {string|null} Chu·ªói g·ªëc ho·∫∑c null n·∫øu l·ªói.
     */
    function decodeBase64ToString(base64Str) {
        try {
            // 1. Gi·∫£i m√£ Base64 th√†nh chu·ªói nh·ªã ph√¢n
            const binaryString = atob(base64Str);
            // 2. Chuy·ªÉn chu·ªói nh·ªã ph√¢n th√†nh m·∫£ng byte (Uint8Array)
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            // 3. Gi·∫£i m√£ m·∫£ng byte UTF-8 th√†nh chu·ªói UTF-16
            return new TextDecoder().decode(bytes);
        } catch (e) {
            console.error("L·ªói khi gi·∫£i m√£ Base64:", e);
            // Th∆∞·ªùng l·ªói n·∫øu chu·ªói ƒë·∫ßu v√†o kh√¥ng ph·∫£i Base64 h·ª£p l·ªá
            return null;
        }
    }
    // --- K·∫øt th√∫c H√†m M√£ H√≥a/Gi·∫£i M√£ Base64 ---

	
// ==============================================
/** X√°c ƒë·ªãnh b·∫≠c ch·∫•t l∆∞·ª£ng d·ª±a tr√™n ph·∫ßn trƒÉm m√°u */
function getQualityTier(healthPercent) {
    if (healthPercent >= QUALITY_THRESHOLDS[QUALITY_TIERS.PERFECT]) {
        return QUALITY_TIERS.PERFECT;
    } else if (healthPercent >= QUALITY_THRESHOLDS[QUALITY_TIERS.GOOD]) {
        return QUALITY_TIERS.GOOD;
    } else if (healthPercent >= QUALITY_THRESHOLDS[QUALITY_TIERS.FAIR]) {
        return QUALITY_TIERS.FAIR;
    } else if (healthPercent >= QUALITY_THRESHOLDS[QUALITY_TIERS.POOR]) {
        return QUALITY_TIERS.POOR;
    }
    // Tr∆∞·ªùng h·ª£p health <= 0 kh√¥ng n√™n x·∫£y ra khi thu ho·∫°ch, nh∆∞ng tr·∫£ v·ªÅ null n·∫øu c√≥ l·ªói
    return null;
}



function isPlotWithRod(plotId) {
    return gameState.lightningRods.some(rod => rod.plotId === plotId);
}

/** [M·ªöI] L·∫•y d·ªØ li·ªáu c·ªôt thu l√¥i cho m·ªôt √¥ ƒë·∫•t */
function getRodData(plotId) {
    return gameState.lightningRods.find(rod => rod.plotId === plotId);
}

/** [M·ªöI] T√¨m c·ªôt thu l√¥i ƒëang ho·∫°t ƒë·ªông trong ph·∫°m vi */
function findRodInRange(targetPlotId) {
    for (const rod of gameState.lightningRods) {
        if (rod.health > 0 && Math.abs(rod.plotId - targetPlotId) <= LIGHTNING_ROD_PROTECTION_RANGE) {
            return rod; // Tr·∫£ v·ªÅ rod ƒë·∫ßu ti√™n t√¨m th·∫•y
        }
    }
    return null; // Kh√¥ng t√¨m th·∫•y rod n√†o
}


function calculateTotalInventoryQuantity() {
    let total = 0;
    // T√≠nh t·ªïng kho ƒë√£ thu ho·∫°ch
    for (const itemId in gameState.harvestedItems) {
        total += gameState.harvestedItems[itemId] || 0;
    }
    // T√≠nh t·ªïng kho ƒë√£ mua
    for (const itemId in gameState.inventory) {
        // ·ªû ƒë√¢y ƒëang t√≠nh t·∫•t c·∫£ v·∫≠t ph·∫©m ƒë√£ mua, bao g·ªìm c·∫£ h·∫°t gi·ªëng, thu·ªëc, ph√¢n
        total += gameState.inventory[itemId] || 0;
    }
    return total;
}
/**
 * Ghi l·∫°i m·ªôt h√†nh ƒë·ªông v√†o l·ªãch s·ª≠ game.
 * @param {string} type Lo·∫°i h√†nh ƒë·ªông (e.g., 'plant', 'harvest', 'fertilize', 'pest', 'clear', 'sell_direct', 'buy_plot', 'buy_item')
 * @param {number|null} plotId ID √¥ ƒë·∫•t li√™n quan (null n·∫øu kh√¥ng √°p d·ª•ng)
 * @param {string} details M√¥ t·∫£ chi ti·∫øt h√†nh ƒë·ªông
 * @param {string} icon Bi·ªÉu t∆∞·ª£ng emoji cho h√†nh ƒë·ªông
 * @param {string|null} itemId ID v·∫≠t ph·∫©m li√™n quan (null n·∫øu kh√¥ng √°p d·ª•ng)
 */
function logAction(type, plotId, details, icon, itemId = null) {
    try {
        const newEntry = {
            timestamp: Date.now(),
            type: type,
            plotId: plotId, // C√≥ th·ªÉ l√† null
            details: details,
            icon: icon,
            itemId: itemId // C√≥ th·ªÉ l√† null
        };

        // Th√™m v√†o ƒë·∫ßu m·∫£ng (m·ªõi nh·∫•t l√™n tr∆∞·ªõc)
        gameState.actionHistory.unshift(newEntry);

        // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc m·∫£ng l·ªãch s·ª≠
        if (gameState.actionHistory.length > MAX_HISTORY_ENTRIES) {
            gameState.actionHistory.length = MAX_HISTORY_ENTRIES; // C·∫Øt b·ªè ph·∫ßn t·ª≠ c≈© nh·∫•t
            // Ho·∫∑c d√πng splice/pop n·∫øu mu·ªën: gameState.actionHistory.pop();
        }

        // L∆∞u l·ªãch s·ª≠ v√†o localStorage ri√™ng bi·ªát
        localStorage.setItem(HISTORY_SAVE_KEY, JSON.stringify(gameState.actionHistory));
        // console.log("ƒê√£ ghi log h√†nh ƒë·ªông:", details); // B·∫≠t n·∫øu c·∫ßn debug
    } catch (error) {
        console.error("L·ªói khi ghi l·ªãch s·ª≠ h√†nh ƒë·ªông:", error, {type, plotId, details, icon, itemId});
        // Kh√¥ng n√™n d·ª´ng game ch·ªâ v√¨ l·ªói log
    }
}





        // --- Bi·∫øn To√†n C·ª•c ---
		const backgroundMusic = document.getElementById('background-music');
		const lightningSound = document.getElementById('lightning-sound');
		let musicStarted = false; // C·ªù ƒë·ªÉ ƒë·∫£m b·∫£o nh·∫°c ch·ªâ b·∫Øt ƒë·∫ßu m·ªôt l·∫ßn
		const darkOverlayElement = document.getElementById('dark-overlay');
		// >>> BI·∫æN V√Ä THAM CHI·∫æU N√öT √ÇM THANH <<<
let isMusicManuallyEnabled = true; // C·ªù theo d√µi ng∆∞·ªùi d√πng ƒë√£ c·ªë b·∫≠t nh·∫°c ch∆∞a
const toggleSoundBtn = document.getElementById('toggle-sound-btn');
const rainSound = document.getElementById('rain-sound');
const rainySunnySound = document.getElementById('rainy-sunny-sound');

// >>> K·∫æT TH√öC TH√äM <<<
		
        // =====================
        let gameLoopInterval = null;
        let messageTimeout = null;
        let currentPlantingPlotId = null;
        let currentActionPlotId = null;
        let tooltipTimeout = null;
        let currentTooltipTarget = null;
        let tooltipHideTimeout = null;
        let tickCounter = 0;
		let weatherUpdateNeeded = true; // C·ªù ƒë·ªÉ y√™u c·∫ßu c·∫≠p nh·∫≠t UI th·ªùi ti·∫øt l·∫ßn ƒë·∫ßu
		let hatNgocTroiTimeout = null;
		let areEffectSoundsEnabled = true; // M·∫∑c ƒë·ªãnh b·∫≠t √¢m thanh hi·ªáu ·ª©ng
		let isMusicEnabled = true; // <<< ƒê·ªîI T√äN: Tr·∫°ng th√°i b·∫≠t/t·∫Øt th·ª±c t·∫ø c·ªßa nh·∫°c n·ªÅn (s·∫Ω load t·ª´ localStorage)
        // --- Tham Chi·∫øu Ph·∫ßn T·ª≠ DOM ---
        // ==============================
		
        const loadingIndicator = document.getElementById('loading-indicator');
        const gameContainer = document.getElementById('game-container');
        const gardenElement = document.getElementById('garden');
        const currencyElement = document.getElementById('currency');
        const gameTimeElement = document.getElementById('game-time');
        const plotCountElement = document.getElementById('plot-count');
        const messageArea = document.getElementById('message-area');
        const shopModal = document.getElementById('shop-modal');
        const inventoryModal = document.getElementById('inventory-modal');
        const seedSelectionModal = document.getElementById('seed-selection-modal');
        const fertilizerSelectionModal = document.getElementById('fertilizer-selection-modal');
        const plantActionModal = document.getElementById('plant-action-modal');
        const emptyPlotActionModal = document.getElementById('empty-plot-action-modal');
        const shopTabsContainer = document.getElementById('shop-tabs');
        const shopSeedList = document.getElementById('shop-seed-list');
        const shopToolList = document.getElementById('shop-tool-list');
        const shopSeedsEmptyMessage = document.getElementById('shop-seeds-empty-message');
        const shopToolsEmptyMessage = document.getElementById('shop-tools-empty-message');
        const inventoryTabsContainer = document.getElementById('inventory-tabs');
        const inventoryHarvestedList = document.getElementById('inventory-harvested-list');
        const inventoryPurchasedList = document.getElementById('inventory-purchased-list');
        const inventoryHarvestedEmptyMessage = document.getElementById('inventory-harvested-empty-message');
        const inventoryPurchasedEmptyMessage = document.getElementById('inventory-purchased-empty-message');
        const seedSelectionList = document.getElementById('seed-selection-list');
        const seedSelectionEmptyMessage = document.getElementById('seed-selection-empty-message');
        const fertilizerSelectionList = document.getElementById('fertilizer-selection-list');
        const fertilizerSelectionEmptyMessage = document.getElementById('fertilizer-selection-empty-message');
        const plantActionButtonsContainer = document.getElementById('plant-action-buttons');
        const plantActionTitle = document.getElementById('plant-action-title');
        const plantActionInfo = document.getElementById('plant-action-info');
        const emptyPlotActionButtonsContainer = document.getElementById('empty-plot-action-buttons');
        const emptyPlotActionTitle = document.getElementById('empty-plot-action-title');
        const emptyPlotActionInfo = document.getElementById('empty-plot-action-info');
        const openShopBtn = document.getElementById('open-shop-btn');
        const openInventoryBtn = document.getElementById('open-inventory-btn');
       // const saveGameBtn = document.getElementById('save-game-btn');
	    const openMenuBtn = document.getElementById('open-menu-btn'); // <<< TH√äM N√öT M·ªöI
        const tooltipElement = document.getElementById('tooltip');
		const lockedPlotPopup = document.getElementById('locked-plot-popup');
		const menuPopup = document.getElementById('menu-popup');
			 // T√¨m n√∫t ƒë√≥ng b√™n trong menu popup - Quan tr·ªçng l√† t√¨m sau khi menuPopup ƒë√£ ƒë∆∞·ª£c tham chi·∫øu
		const closeMenuPopupBtn = menuPopup ? menuPopup.querySelector('.close-button') : null; // <<< TH√äM N√öT ƒê√ìNG MENU
		const lockedPlotMessage = document.getElementById('locked-plot-message');
		const confirmBuyPlotBtn = document.getElementById('confirm-buy-plot-btn');
		const cancelBuyPlotBtn = document.getElementById('cancel-buy-plot-btn');
		const closePopupBtn = lockedPlotPopup.querySelector('.close-popup-btn'); // T√¨m n√∫t ƒë√≥ng b√™n trong popup
		const confirmSellAllModal = document.getElementById('confirm-sell-all-modal');
        const confirmSellItemName = document.getElementById('confirm-sell-item-name');
        const confirmSellQuantity = document.getElementById('confirm-sell-quantity');
        const confirmSellTotalValue = document.getElementById('confirm-sell-total-value');
        const confirmSellAllBtn = document.getElementById('confirm-sell-all-btn');
        const cancelSellAllBtn = document.getElementById('cancel-sell-all-btn');

		const weatherIconElement = document.getElementById('weather-icon');
        const weatherTimerElement = document.getElementById('weather-timer');
        const weatherProgressBarElement = document.getElementById('weather-progress-bar');
        const weatherProgressContainer = document.getElementById('weather-progress-container'); // Th√™m container
		const weatherNameElement = document.getElementById('weather-name'); // <<< TH√äM THAM CHI·∫æU M·ªöI
		const plantingHistoryBtn = document.getElementById('planting-history-btn');
		
		const hatNgocTroiPopup = document.getElementById('hat-ngoc-troi-popup'); // <<< TH√äM THAM CHI·∫æU POPUP M·ªöI
		const hatNgocTroiRewardPopup = document.getElementById('hat-ngoc-troi-reward-popup');
const rewardItemImage = document.getElementById('reward-item-image');
const rewardItemName = document.getElementById('reward-item-name');
const confirmRewardBtn = document.getElementById('confirm-reward-btn');
		const discardItemPopup = document.getElementById('discard-item-popup');
const discardItemIcon = document.getElementById('discard-item-icon');
const discardItemName = document.getElementById('discard-item-name');
const discardCurrentQuantity = document.getElementById('discard-current-quantity');
const discardQuantityInput = document.getElementById('discard-quantity-input');
const discardQuantityError = document.getElementById('discard-quantity-error');
const confirmDiscardBtn = document.getElementById('confirm-discard-btn');
const cancelDiscardBtn = document.getElementById('cancel-discard-btn');
		const lightningRodActionModal = document.getElementById('lightning-rod-action-modal'); 
      const confirmRepairRodPopup = document.getElementById('confirm-repair-rod-popup'); 
      const confirmRemoveRodPopup = document.getElementById('confirm-remove-rod-popup'); 
const toggleEffectsSoundBtn = document.getElementById('toggle-effects-sound-btn');
		const exportImportBtn = document.getElementById('export-import-data-btn');
const savegamePopup = document.getElementById('menu-savegame-popup');
const btnSaveGame = document.getElementById('btn-savegame'); // Tham chi·∫øu n√∫t L∆∞u
const btnImportSaveGame = document.getElementById('btn-import-savegame'); // Tham chi·∫øu n√∫t Nh·∫≠p
const closeSavegamePopupBtn = savegamePopup ? savegamePopup.querySelector('.close-button') : null; // N√∫t ƒë√≥ng popup l∆∞u/nh·∫≠p

const dailyQuestBtn = document.getElementById('btn-nhiemvuhangngay');
const dailyQuestPopup = document.getElementById('daily-quest-popup');

	  // --- C√°c H√†m Logic Game C·ªët L√µi ---
	  
	   /**  X√°c th·ª±c c·∫•u tr√∫c c∆° b·∫£n c·ªßa d·ªØ li·ªáu game ƒë√£ nh·∫≠p */
    function validateImportedState(data) {
        if (!data || typeof data !== 'object') return false;
        // Ki·ªÉm tra c√°c kh√≥a ch√≠nh v√† ki·ªÉu d·ªØ li·ªáu c∆° b·∫£n
        if (typeof data.currency !== 'number' || data.currency < 0) return false;
        if (typeof data.maxUnlockedPlots !== 'number' || data.maxUnlockedPlots < INITIAL_PLOT_COUNT) return false;
        if (!Array.isArray(data.plots)) return false;
        if (typeof data.inventory !== 'object' || data.inventory === null) return false;
        if (typeof data.harvestedItems !== 'object' || data.harvestedItems === null) return false;
        if (typeof data.lastUpdateTimestamp !== 'number' || data.lastUpdateTimestamp <= 0) return false;
        if (typeof data.currentWeather !== 'object' || typeof data.currentWeather.id !== 'string') return false;
        // C√≥ th·ªÉ th√™m nhi·ªÅu ki·ªÉm tra chi ti·∫øt h∆°n n·∫øu c·∫ßn (v√≠ d·ª•: c·∫•u tr√∫c plot, ID v·∫≠t ph·∫©m h·ª£p l·ªá)
        return true; // Tr·∫£ v·ªÅ true n·∫øu c√°c ki·ªÉm tra c∆° b·∫£n pass
    }

    /** √Åp d·ª•ng d·ªØ li·ªáu game ƒë√£ nh·∫≠p v√† kh·ªüi ƒë·ªông l·∫°i game */
    function applyAndRestartGame(newStateData) {
        console.log("ƒêang √°p d·ª•ng tr·∫°ng th√°i game ƒë√£ nh·∫≠p...");
        try {
            // 1. D·ª´ng game loop v√† c√°c timer/√¢m thanh hi·ªán t·∫°i
            stopGameLoop(); // D·ª´ng game loop ch√≠nh v√† timer Hat Ng·ªçc Tr·ªùi
            if (backgroundMusic && !backgroundMusic.paused) backgroundMusic.pause();
            if (rainSound && !rainSound.paused) rainSound.pause();
            if (rainySunnySound && !rainySunnySound.paused) rainySunnySound.pause();
            if (lightningSound && !lightningSound.paused) { lightningSound.pause(); lightningSound.currentTime = 0; }
            console.log("ƒê√£ d·ª´ng v√≤ng l·∫∑p v√† √¢m thanh hi·ªán t·∫°i.");

            // 2. Th·ª±c hi·ªán Deep Copy tr·∫°ng th√°i m·ªõi v√†o gameState
            //    ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o kh√¥ng c√≥ tham chi·∫øu ƒë·ªëi t∆∞·ª£ng c≈© n√†o c√≤n s√≥t l·∫°i.
            gameState = JSON.parse(JSON.stringify(newStateData));
            console.log("ƒê√£ th·ª±c hi·ªán deep copy tr·∫°ng th√°i m·ªõi v√†o gameState.");

            // 3. [QUAN TR·ªåNG] M√¥ ph·ªèng ti·∫øn tr√¨nh offline t·ª´ th·ªùi ƒëi·ªÉm l∆∞u trong t·ªáp ƒë·∫øn hi·ªán t·∫°i
            const now = Date.now();
            const timeDiff = now - gameState.lastUpdateTimestamp;
            let stateChangedDuringSim = false;
            if (timeDiff > TICK_INTERVAL * 1.5 && gameState.lastUpdateTimestamp > 0) {
                console.log(`√Åp d·ª•ng m√¥ ph·ªèng offline cho ${formatTime(timeDiff)} k·ªÉ t·ª´ l·∫ßn l∆∞u cu·ªëi.`);
                stateChangedDuringSim = simulateOfflineProgress(gameState.lastUpdateTimestamp, now);
                gameState.totalPlayTime += timeDiff; // C·∫≠p nh·∫≠t t·ªïng th·ªùi gian ch∆°i
                gameState.lastUpdateTimestamp = now; // C·∫≠p nh·∫≠t timestamp cu·ªëi c√πng v·ªÅ hi·ªán t·∫°i
                console.log("M√¥ ph·ªèng offline ho√†n t·∫•t.");
            } else if (timeDiff > 0 && gameState.lastUpdateTimestamp > 0){ // C·∫≠p nh·∫≠t th·ªùi gian ch∆°i n·∫øu offline ng·∫Øn
                 gameState.totalPlayTime += timeDiff;
                 gameState.lastUpdateTimestamp = now;
            } else { // N·∫øu timestamp l∆∞u l√† t∆∞∆°ng lai ho·∫∑c kh√¥ng h·ª£p l·ªá, ƒë·∫∑t l·∫°i
                gameState.lastUpdateTimestamp = now;
            }

            // 4. T·∫£i l·∫°i c√†i ƒë·∫∑t √¢m thanh t·ª´ localStorage (kh√¥ng ghi ƒë√® b·ªüi file save)
            const savedMusicEnabled = localStorage.getItem(MUSIC_ENABLED_KEY);
            const savedEffectsEnabled = localStorage.getItem(EFFECTS_ENABLED_KEY);
            isMusicEnabled = (savedMusicEnabled === null) ? true : (savedMusicEnabled === 'true');
            areEffectSoundsEnabled = (savedEffectsEnabled === null) ? true : (savedEffectsEnabled === 'true');
            console.log(`ƒê√£ t·∫£i l·∫°i c√†i ƒë·∫∑t √¢m thanh: Music=${isMusicEnabled}, Effects=${areEffectSoundsEnabled}`);

            // 5. Kh·ªüi t·∫°o l·∫°i d·ªØ li·ªáu plots d·ª±a tr√™n maxUnlockedPlots m·ªõi
            initializePlotsData(); // ƒê·∫£m b·∫£o m·∫£ng plots kh·ªõp v·ªõi maxUnlockedPlots
            console.log("ƒê√£ kh·ªüi t·∫°o l·∫°i d·ªØ li·ªáu plots.");

            // 6. Render l·∫°i to√†n b·ªô giao di·ªán
            renderGarden();
            renderUI();
            populateShop();
            updateShopButtons(); // Quan tr·ªçng sau khi populateShop v√† renderUI
            weatherUpdateNeeded = true; // ƒê√°nh d·∫•u c·∫ßn c·∫≠p nh·∫≠t th·ªùi ti·∫øt
            renderWeatherUI();
            updateSoundButtonText(); // C·∫≠p nh·∫≠t n√∫t √¢m thanh theo c√†i ƒë·∫∑t ƒë√£ t·∫£i
            updateEffectSoundButtonText();
            console.log("ƒê√£ render l·∫°i giao di·ªán.");

            // 7. X√≥a tooltip c≈© n·∫øu c√≥
            hideTooltip();

            // 8. Kh·ªüi ƒë·ªông l·∫°i game loop
            startGameLoop(); // Bao g·ªìm c·∫£ vi·ªác kh·ªüi ƒë·ªông l·∫°i timer Hat Ng·ªçc Tr·ªùi
            console.log("ƒê√£ kh·ªüi ƒë·ªông l·∫°i v√≤ng l·∫∑p game.");

            showMessage("ƒê√£ ph·ª•c h·ªìi d·ªØ li·ªáu game th√†nh c√¥ng!", "success", 4000);

        } catch (error) {
            console.error("L·ªói nghi√™m tr·ªçng khi √°p d·ª•ng tr·∫°ng th√°i game ƒë√£ nh·∫≠p:", error);
            showMessage("L·ªói nghi√™m tr·ªçng! Kh√¥ng th·ªÉ ph·ª•c h·ªìi d·ªØ li·ªáu game. ƒêang t·∫£i l·∫°i game m·∫∑c ƒë·ªãnh.", "error", 5000);
            // Reset v·ªÅ tr·∫°ng th√°i m·∫∑c ƒë·ªãnh n·∫øu c√≥ l·ªói nghi√™m tr·ªçng khi √°p d·ª•ng
            localStorage.removeItem(GAME_SAVE_KEY);
            localStorage.removeItem(HISTORY_SAVE_KEY);
            // G·ªçi l·∫°i initGame ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i ho√†n to√†n
            // D√πng setTimeout ƒë·ªÉ tr√°nh g·ªçi ƒë·ªá quy tr·ª±c ti·∫øp n·∫øu initGame c≈©ng l·ªói
            setTimeout(() => {
                // Reset c√°c bi·∫øn tr·∫°ng th√°i tr∆∞·ªõc khi init l·∫°i
                 currentPlantingPlotId = null;
                 currentActionPlotId = null;
                 tickCounter = 0;
                 weatherUpdateNeeded = true;
                 clearTimeout(messageTimeout);
                 clearTimeout(tooltipTimeout);
                 clearTimeout(tooltipHideTimeout);
                 clearTimeout(hatNgocTroiTimeout);
                 hatNgocTroiTimeout = null;
                 // G·ªçi initGame ƒë·ªÉ reset
                 initGame();
            }, 100);
        }
    }

	// --- bi·∫øn to√†n c·ª•c g·∫ßn c√°c bi·∫øn tr·∫°ng th√°i kh√°c ---
let pendingRestoreData = null; // D·ªØ li·ªáu game ch·ªù x√°c nh·∫≠n kh√¥i ph·ª•c


    /**  X·ª≠ l√Ω vi·ªác ch·ªçn v√† nh·∫≠p t·ªáp tr·∫°ng th√°i game */
   async function importGameStateFromFile() {
    console.log("B·∫Øt ƒë·∫ßu qu√° tr√¨nh nh·∫≠p game t·ª´ t·ªáp (d·ª± ki·∫øn Base64)...");

    // 1. Ki·ªÉm tra h·ªó tr·ª£ API truy c·∫≠p t·ªáp
    if (!window.showOpenFilePicker) {
        showMessage("Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng nh·∫≠p t·ªáp n√†y.", "error");
        console.error("File System Access API (showOpenFilePicker) is not supported.");
        return;
    }

    const savegamePopupElement = document.getElementById('menu-savegame-popup'); // Tham chi·∫øu popup l∆∞u/nh·∫≠p

    try {
        // 2. M·ªü h·ªôp tho·∫°i ch·ªçn t·ªáp
        const [fileHandle] = await window.showOpenFilePicker({
            multiple: false, // Ch·ªâ cho ph√©p ch·ªçn m·ªôt t·ªáp
            types: [{
                description: 'V∆∞·ªùn C√¢y H·∫°nh Ph√∫c Save File', // M√¥ t·∫£ lo·∫°i t·ªáp
                accept: {
                    'application/octet-stream': ['.sav'], // ∆Øu ti√™n ƒëu√¥i .sav (encoded)
                    'application/json': ['.json']         // Cho ph√©p c·∫£ .json (plain text)
                },
            }],
        });
        console.log("Ng∆∞·ªùi d√πng ƒë√£ ch·ªçn t·ªáp:", fileHandle.name);

        // 3. L·∫•y ƒë·ªëi t∆∞·ª£ng File
        const file = await fileHandle.getFile();
        console.log(`Th√¥ng tin t·ªáp: T√™n=${file.name}, K√≠ch th∆∞·ªõc=${file.size} bytes, Lo·∫°i=${file.type}`);

        // 4. ƒê·ªçc n·ªôi dung t·ªáp d∆∞·ªõi d·∫°ng text
        const fileContent = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result); // Tr·∫£ v·ªÅ n·ªôi dung khi ƒë·ªçc xong
            reader.onerror = (error) => reject(error); // B√°o l·ªói n·∫øu c√≥
            reader.readAsText(file); // B·∫Øt ƒë·∫ßu ƒë·ªçc t·ªáp
        });
        console.log("ƒê√£ ƒë·ªçc n·ªôi dung t·ªáp.");

        // 5. Gi·∫£i m√£ Base64 (n·∫øu c·∫ßn) v√† Parse JSON
        let decodedJsonString = decodeBase64ToString(fileContent); // Th·ª≠ gi·∫£i m√£ Base64
        let parsedData;

        if (decodedJsonString === null) {
            // N·∫øu gi·∫£i m√£ Base64 l·ªói, th·ª≠ parse tr·ª±c ti·∫øp nh∆∞ JSON (cho save c≈©)
            console.warn("Gi·∫£i m√£ Base64 th·∫•t b·∫°i. ƒêang th·ª≠ parse tr·ª±c ti·∫øp nh∆∞ JSON thu·∫ßn...");
            try {
                parsedData = JSON.parse(fileContent);
                console.log("Parse tr·ª±c ti·∫øp JSON th√†nh c√¥ng (c√≥ th·ªÉ l√† t·ªáp l∆∞u c≈©).");
            } catch (directParseError) {
                // N·∫øu c·∫£ hai ƒë·ªÅu l·ªói
                console.error("L·ªói khi parse tr·ª±c ti·∫øp JSON:", directParseError);
                showMessage("T·ªáp kh√¥ng ch·ª©a d·ªØ li·ªáu h·ª£p l·ªá (kh√¥ng ph·∫£i Base64 ho·∫∑c JSON).", "error");
                return; // D·ª´ng l·∫°i
            }
        } else {
            // N·∫øu gi·∫£i m√£ Base64 th√†nh c√¥ng, parse chu·ªói ƒë√£ gi·∫£i m√£
            try {
                parsedData = JSON.parse(decodedJsonString);
                console.log("ƒê√£ gi·∫£i m√£ Base64 v√† parse JSON th√†nh c√¥ng.");
            } catch (parseError) {
                console.error("L·ªói khi parse JSON sau khi gi·∫£i m√£ Base64:", parseError);
                showMessage("D·ªØ li·ªáu trong t·ªáp b·ªã l·ªói sau khi gi·∫£i m√£.", "error");
                return; // D·ª´ng l·∫°i
            }
        }

        // 6. Validate c·∫•u tr√∫c d·ªØ li·ªáu c∆° b·∫£n
        if (!validateImportedState(parsedData)) {
            console.error("D·ªØ li·ªáu ƒë√£ parse kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu c√°c tr∆∞·ªùng quan tr·ªçng.");
            showMessage("T·ªáp kh√¥ng ch·ª©a d·ªØ li·ªáu l∆∞u game h·ª£p l·ªá.", "error");
            return; // D·ª´ng l·∫°i
        }
        console.log("D·ªØ li·ªáu ƒë√£ qua ki·ªÉm tra c·∫•u tr√∫c c∆° b·∫£n.");

        // --- B·∫ÆT ƒê·∫¶U HI·ªÇN TH·ªä POPUP X√ÅC NH·∫¨N L·ªíNG NHAU ---
        pendingRestoreData = parsedData; // L∆∞u d·ªØ li·ªáu h·ª£p l·ªá ch·ªù x√°c nh·∫≠n

        // L·∫•y tham chi·∫øu ƒë·∫øn popup x√°c nh·∫≠n v√† c√°c n√∫t b√™n trong
        const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
        const confirmRestoreBtn = document.getElementById('confirm-restore-btn');
        const cancelRestoreBtn = document.getElementById('cancel-restore-btn');
        const closeRestorePopupBtn = confirmRestorePopup ? confirmRestorePopup.querySelector('.close-button') : null;

        // Ki·ªÉm tra xem t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ c·∫ßn thi·∫øt c√≥ t·ªìn t·∫°i kh√¥ng
        if (!savegamePopupElement || !confirmRestorePopup || !confirmRestoreBtn || !cancelRestoreBtn || !closeRestorePopupBtn) {
             console.error("L·ªói: Thi·∫øu c√°c ph·∫ßn t·ª≠ DOM cho popup l∆∞u/nh·∫≠p ho·∫∑c popup x√°c nh·∫≠n kh√¥i ph·ª•c!");
             showMessage("L·ªói giao di·ªán: Kh√¥ng th·ªÉ x√°c nh·∫≠n kh√¥i ph·ª•c.", "error");
             pendingRestoreData = null; // X√≥a d·ªØ li·ªáu ƒëang ch·ªù n·∫øu c√≥ l·ªói DOM
             return;
        }

        // 1. Th√™m class ƒë·ªÉ l√†m m·ªù v√† v√¥ hi·ªáu h√≥a popup l∆∞u/nh·∫≠p b√™n d∆∞·ªõi
        savegamePopupElement.classList.add('popup-underlay');
        console.log("ƒê√£ th√™m class 'popup-underlay' v√†o #menu-savegame-popup.");

        // 2. Hi·ªÉn th·ªã popup x√°c nh·∫≠n kh√¥i ph·ª•c b·∫±ng 'flex' ƒë·ªÉ cƒÉn gi·ªØa
        confirmRestorePopup.style.display = 'flex';
        console.log("ƒê√£ hi·ªÉn th·ªã #popup-confirm-restoregame b·∫±ng display: flex.");

        // 3. L·ªõp ph·ªß t·ªëi (darkOverlay) ƒë√£ ƒë∆∞·ª£c hi·ªÉn th·ªã khi m·ªü popup l∆∞u/nh·∫≠p,
        //    kh√¥ng c·∫ßn g·ªçi l·∫°i showDarkOverlay() ·ªü ƒë√¢y.

        // 4. ƒê·∫∑t focus v√†o n√∫t "X√°c Nh·∫≠n Kh√¥i Ph·ª•c" ƒë·ªÉ ti·ªán cho ng∆∞·ªùi d√πng
        setTimeout(() => {
            confirmRestoreBtn.focus();
            console.log("ƒê√£ focus v√†o n√∫t #confirm-restore-btn.");
        }, 50); // D√πng setTimeout ƒë·ªÉ ƒë·∫£m b·∫£o popup ƒë√£ render

        // --- POPUP L∆ØU/NH·∫¨P G·ªêC KH√îNG B·ªä ƒê√ìNG ---

        // --- K·∫øt th√∫c logic hi·ªÉn th·ªã popup l·ªìng nhau ---

    } catch (error) {
        // X·ª≠ l√Ω c√°c l·ªói c√≥ th·ªÉ x·∫£y ra trong qu√° tr√¨nh
        if (error.name === 'AbortError') {
            // Ng∆∞·ªùi d√πng h·ªßy h·ªôp tho·∫°i ch·ªçn t·ªáp
            console.log("Ng∆∞·ªùi d√πng ƒë√£ h·ªßy h·ªôp tho·∫°i ch·ªçn t·ªáp.");
            showMessage("ƒê√£ h·ªßy thao t√°c ch·ªçn t·ªáp.", "info");
        } else {
            // C√°c l·ªói kh√°c (ƒë·ªçc file, permission,...)
            console.error("L·ªói trong qu√° tr√¨nh nh·∫≠p game t·ª´ t·ªáp:", error);
            showMessage(`L·ªói khi nh·∫≠p t·ªáp: ${error.message}`, "error");
        }

        // Quan tr·ªçng: N·∫øu c√≥ l·ªói, ƒë·∫£m b·∫£o x√≥a class l√†m m·ªù kh·ªèi popup l∆∞u/nh·∫≠p
        // v√† reset d·ªØ li·ªáu ƒëang ch·ªù
        if (savegamePopupElement) {
            savegamePopupElement.classList.remove('popup-underlay');
            console.log("ƒê√£ x√≥a class 'popup-underlay' kh·ªèi #menu-savegame-popup do l·ªói.");
        }
        pendingRestoreData = null; // Reset d·ªØ li·ªáu ch·ªù
    }
}

	// --- c√°c h√†m x·ª≠ l√Ω cho popup m·ªõi ---
/** ƒê√≥ng popup x√°c nh·∫≠n kh√¥i ph·ª•c game */
function closeConfirmRestorePopup() {
    const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
    const savegamePopupElement = document.getElementById('menu-savegame-popup'); // <<<< L·∫§Y POPUP D∆Ø·ªöI

    if (confirmRestorePopup) {
        confirmRestorePopup.style.display = 'none';
        pendingRestoreData = null; // Quan tr·ªçng: X√≥a d·ªØ li·ªáu ƒëang ch·ªù

        // X√≥a class l√†m m·ªù kh·ªèi popup l∆∞u/nh·∫≠p
        if (savegamePopupElement) {
            savegamePopupElement.classList.remove('popup-underlay');
        }

        // KI·ªÇM TRA OVERLAY: Ch·ªâ ·∫©n overlay n·∫øu popup save/load c≈©ng *kh√¥ng* hi·ªÉn th·ªã
        setTimeout(() => {
            const savegamePopupVisible = savegamePopupElement && (savegamePopupElement.style.display === 'block' || savegamePopupElement.style.display === 'flex');
            // Ch·ªâ ·∫©n n·∫øu kh√¥ng c√≤n modal n√†o kh√°c V√Ä popup save/load c≈©ng kh√¥ng hi·ªÉn th·ªã
            const anyOtherModalOpen = document.querySelector('.modal[style*="display: block"]:not(#popup-confirm-restoregame), .modal[style*="display: flex"]:not(#popup-confirm-restoregame)');
            if (!anyOtherModalOpen && !savegamePopupVisible && darkOverlayElement && darkOverlayElement.classList.contains('visible')) {
                hideDarkOverlay();
            }
        }, 50);
    }
}

/** X·ª≠ l√Ω khi nh·∫•n n√∫t H·ªßy B·ªè trong popup kh√¥i ph·ª•c */
function handleCancelRestore() {
    console.log("Ng∆∞·ªùi d√πng ƒë√£ h·ªßy thao t√°c kh√¥i ph·ª•c.");
    showMessage("ƒê√£ h·ªßy thao t√°c ph·ª•c h·ªìi d·ªØ li·ªáu.", "info");
    closeConfirmRestorePopup(); // Ch·ªâ ƒë√≥ng popup x√°c nh·∫≠n, popup l∆∞u/nh·∫≠p v·∫´n m·ªü v√† active l·∫°i
}


/** X·ª≠ l√Ω khi nh·∫•n n√∫t X√°c Nh·∫≠n Kh√¥i Ph·ª•c */
function handleConfirmRestore() {
    const savegamePopupElement = document.getElementById('menu-savegame-popup'); // <<<< L·∫§Y POPUP D∆Ø·ªöI
    if (pendingRestoreData) {
        console.log("Ng∆∞·ªùi d√πng ƒë√£ x√°c nh·∫≠n kh√¥i ph·ª•c.");
        applyAndRestartGame(pendingRestoreData); // G·ªçi h√†m √°p d·ª•ng d·ªØ li·ªáu

        // ƒê√≥ng c·∫£ hai popup sau khi √°p d·ª•ng th√†nh c√¥ng
        closeConfirmRestorePopup(); // ƒê√≥ng popup x√°c nh·∫≠n (ƒë√£ bao g·ªìm x√≥a class underlay)
        closeSavegamePopup();     // ƒê√≥ng popup l∆∞u/nh·∫≠p g·ªëc
        // H√†m closeSavegamePopup n√™n t·ª± ƒë·ªông ki·ªÉm tra v√† ·∫©n overlay n·∫øu c·∫ßn
    } else {
        console.error("L·ªói: Kh√¥ng c√≥ d·ªØ li·ªáu kh√¥i ph·ª•c ƒëang ch·ªù.");
        showMessage("L·ªói: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ƒë·ªÉ kh√¥i ph·ª•c.", "error");
        // N·∫øu l·ªói, v·∫´n ƒë√≥ng popup x√°c nh·∫≠n v√† x√≥a class l√†m m·ªù
        closeConfirmRestorePopup();
    }
    // pendingRestoreData ƒë√£ ƒë∆∞·ª£c reset trong closeConfirmRestorePopup()
}
 
	  
	  
	   /** Xu·∫•t tr·∫°ng th√°i game hi·ªán t·∫°i ra t·ªáp JSON */
     async function exportGameStateToFile() {
        console.log("B·∫Øt ƒë·∫ßu qu√° tr√¨nh xu·∫•t game ra t·ªáp (Base64)...");
        try {
            saveGame(); // C·∫≠p nh·∫≠t gameState trong b·ªô nh·ªõ
            console.log("Tr·∫°ng th√°i game ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong b·ªô nh·ªõ.");

            // 2. L·∫•y d·ªØ li·ªáu gameState v√† chuy·ªÉn th√†nh JSON
            const jsonString = JSON.stringify(gameState, null, 2); // C√≥ th·ªÉ b·ªè ƒë·ªãnh d·∫°ng ƒë·∫πp (null, 2) n·∫øu mu·ªën t·ªáp nh·ªè h∆°n ch√∫t
            console.log("ƒê√£ t·∫°o chu·ªói JSON.");

            // --- [THAY ƒê·ªîI] M√£ h√≥a chu·ªói JSON th√†nh Base64 ---
            const dataToExport = encodeStringToBase64(jsonString);
            if (dataToExport === null) {
                showMessage("L·ªói: Kh√¥ng th·ªÉ m√£ h√≥a d·ªØ li·ªáu l∆∞u game.", "error");
                return; // D·ª´ng n·∫øu m√£ h√≥a l·ªói
            }
            console.log("ƒê√£ m√£ h√≥a d·ªØ li·ªáu JSON th√†nh Base64.");
            // ----------------------------------------------

            // 3. T·∫°o t√™n t·ªáp ƒë·ªÅ xu·∫•t
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            // C√≥ th·ªÉ ƒë·ªïi ƒëu√¥i t·ªáp th√†nh .sav ho·∫∑c g√¨ ƒë√≥ kh√°c thay v√¨ .json ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt n√≥ kh√¥ng ph·∫£i JSON thu·∫ßn
            const suggestedName = `VuonCayHanhPhuc_Save_${timestamp}.sav`; // <-- ƒê·ªïi ƒëu√¥i t·ªáp th√†nh .sav
            console.log("T√™n t·ªáp ƒë·ªÅ xu·∫•t:", suggestedName);

            // 4. M·ªü h·ªôp tho·∫°i "Save As"
            const fileHandle = await window.showSaveFilePicker({
                suggestedName: suggestedName,
                types: [{
                    // C·∫≠p nh·∫≠t description v√† accept n·∫øu ƒë·ªïi ƒëu√¥i t·ªáp
                    description: 'V∆∞·ªùn C√¢y H·∫°nh Ph√∫c Save File (Encoded)',
                    accept: { 'application/octet-stream': ['.sav'] }, // D√πng ki·ªÉu generic n·∫øu kh√¥ng ph·∫£i json
                }],
            });
            console.log("Ng∆∞·ªùi d√πng ƒë√£ ch·ªçn t·ªáp:", fileHandle.name);

            // 5. T·∫°o lu·ªìng ghi
            const writableStream = await fileHandle.createWritable();
            console.log("ƒê√£ t·∫°o lu·ªìng ghi.");

            // 6. Ghi d·ªØ li·ªáu ƒê√É M√É H√ìA v√†o lu·ªìng
            await writableStream.write(dataToExport);
            console.log("ƒê√£ ghi d·ªØ li·ªáu Base64 v√†o lu·ªìng.");

            // 7. ƒê√≥ng lu·ªìng ghi
            await writableStream.close();
            console.log("ƒê√£ ƒë√≥ng lu·ªìng ghi.");

            showMessage("ƒê√£ l∆∞u ti·∫øn tr√¨nh tr√≤ ch∆°i v√†o t·ªáp th√†nh c√¥ng!", "success");
            closeSavegamePopup();

        } catch (error) {
            if (error.name === 'AbortError') {
                console.log("Ng∆∞·ªùi d√πng ƒë√£ h·ªßy h·ªôp tho·∫°i l∆∞u t·ªáp.");
                showMessage("ƒê√£ h·ªßy thao t√°c l∆∞u t·ªáp.", "info");
            } else {
                console.error("L·ªói khi l∆∞u game ra t·ªáp (Base64):", error);
                showMessage(`L·ªói khi l∆∞u t·ªáp: ${error.message}`, "error");
            }
        }
    }

	  
	  
        // =================================
		/** M·ªü Popup L∆∞u/Nh·∫≠p Game */
function openSavegamePopup() {
    if (savegamePopup) {
        console.log("M·ªü popup L∆∞u/Nh·∫≠p game.");
        closeMenuPopup(); // ƒê√≥ng menu ch√≠nh tr∆∞·ªõc
        savegamePopup.style.display = 'block'; // Hi·ªÉn th·ªã popup
        showDarkOverlay(); // Hi·ªÉn th·ªã l·ªõp ph·ªß t·ªëi

        // T·ª± ƒë·ªông focus v√†o n√∫t L∆∞u ho·∫∑c Nh·∫≠p
        const focusTarget = btnSaveGame || btnImportSaveGame;
        if (focusTarget) {
            setTimeout(() => focusTarget.focus(), 50);
        }
    } else {
        console.error("Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ DOM c·ªßa popup L∆∞u/Nh·∫≠p game!");
    }
}

/** ƒê√≥ng Popup L∆∞u/Nh·∫≠p Game */
function closeSavegamePopup() {
    if (savegamePopup) {
        savegamePopup.style.display = 'none';
        // Ch·ªâ ·∫©n l·ªõp ph·ªß n·∫øu kh√¥ng c√≤n modal/popup n√†o kh√°c ƒëang m·ªü
        setTimeout(() => {
            const anyModalOpen = document.querySelector('.modal[style*="display: block"], .modal[style*="display: flex"]');
            if (!anyModalOpen && darkOverlayElement && darkOverlayElement.classList.contains('visible')) {
                hideDarkOverlay();
            }
        }, 50);
    }
}
		
		
		
		function showDarkOverlay() {
    if (darkOverlayElement) {
        darkOverlayElement.classList.add('visible');
        console.log("L·ªõp ph·ªß t·ªëi ƒë√£ hi·ªÉn th·ªã.");
    } else {
        console.error("Kh√¥ng t√¨m th·∫•y #dark-overlay ƒë·ªÉ hi·ªÉn th·ªã.");
    }
}

/** ·∫®n l·ªõp ph·ªß t·ªëi */
function hideDarkOverlay() {
    if (darkOverlayElement) {
        darkOverlayElement.classList.remove('visible');
         console.log("L·ªõp ph·ªß t·ªëi ƒë√£ ·∫©n.");
    } else {
         console.error("Kh√¥ng t√¨m th·∫•y #dark-overlay ƒë·ªÉ ·∫©n.");
    }
}

		
		function toggleEffectSounds() {
    if (!toggleEffectsSoundBtn) return;

    // 1. ƒê·∫£o ng∆∞·ª£c tr·∫°ng th√°i
    areEffectSoundsEnabled = !areEffectSoundsEnabled;
    console.log(`Ng∆∞·ªùi d√πng chuy·ªÉn tr·∫°ng th√°i hi·ªáu ·ª©ng th√†nh: ${areEffectSoundsEnabled}`);

    // 2. L∆∞u tr·∫°ng th√°i m·ªõi v√†o localStorage
    localStorage.setItem(EFFECTS_ENABLED_KEY, areEffectSoundsEnabled.toString());
    console.log(`ƒê√£ l∆∞u tr·∫°ng th√°i hi·ªáu ·ª©ng (${areEffectSoundsEnabled}) v√†o localStorage.`);

    // 3. C·∫≠p nh·∫≠t vƒÉn b·∫£n n√∫t
    updateEffectSoundButtonText();

    // 4. T·∫Øt c√°c hi·ªáu ·ª©ng ƒëang ch·∫°y n·∫øu ng∆∞·ªùi d√πng v·ª´a t·∫Øt
    if (!areEffectSoundsEnabled) {
        if (lightningSound && !lightningSound.paused) { lightningSound.pause(); lightningSound.currentTime = 0; }
        if (rainSound && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
        if (rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
        console.log("ƒê√£ d·ª´ng c√°c hi·ªáu ·ª©ng √¢m thanh ƒëang ch·∫°y (n·∫øu c√≥).");
    } else {
        // N·∫øu ng∆∞·ªùi d√πng v·ª´a b·∫≠t l·∫°i, gameTick ti·∫øp theo s·∫Ω t·ª± ƒë·ªông x·ª≠ l√Ω b·∫≠t √¢m thanh th·ªùi ti·∫øt n·∫øu c·∫ßn
        console.log("Hi·ªáu ·ª©ng ƒë√£ ƒë∆∞·ª£c b·∫≠t. √Çm thanh th·ªùi ti·∫øt s·∫Ω ph√°t n·∫øu ph√π h·ª£p trong gameTick.");
    }
}
function updateEffectSoundButtonText() {
    if (!toggleEffectsSoundBtn) return; // Ki·ªÉm tra n√∫t t·ªìn t·∫°i
    if (areEffectSoundsEnabled) {
        toggleEffectsSoundBtn.textContent = "üîá T·∫Øt √Çm Thanh Hi·ªáu ·ª®ng";
        // T√πy ch·ªçn: Th√™m title ƒë·ªÉ r√µ h∆°n
        toggleEffectsSoundBtn.title = "T·∫Øt c√°c hi·ªáu ·ª©ng √¢m thanh nh∆∞ s·∫•m s√©t, m∆∞a,...";
    } else {
        toggleEffectsSoundBtn.textContent = "üîä B·∫≠t √Çm Thanh Hi·ªáu ·ª®ng";
        toggleEffectsSoundBtn.title = "B·∫≠t c√°c hi·ªáu ·ª©ng √¢m thanh nh∆∞ s·∫•m s√©t, m∆∞a,...";
    }
}
		function getTotalInventoryQuantity() {
            let totalQuantity = 0;
            // T√≠nh t·ªïng t·ª´ kho ƒë√£ thu ho·∫°ch
            for (const itemId in gameState.harvestedItems) {
                totalQuantity += gameState.harvestedItems[itemId] || 0;
            }
            // T√≠nh t·ªïng t·ª´ kho ƒë√£ mua
            for (const itemId in gameState.inventory) {
                totalQuantity += gameState.inventory[itemId] || 0;
            }
            return totalQuantity;
        }
		
		
		/** [M·ªöI] Ch·ªçn ng·∫´u nhi√™n m·ªôt v·∫≠t ph·∫©m t·ª´ ITEM_DATA ƒë·ªÉ l√†m ph·∫ßn th∆∞·ªüng */
function getRandomRewardItem() {
    const validItemIds = Object.keys(ITEM_DATA);
    if (validItemIds.length === 0) {
        console.error("Kh√¥ng c√≥ v·∫≠t ph·∫©m n√†o trong ITEM_DATA ƒë·ªÉ ch·ªçn l√†m ph·∫ßn th∆∞·ªüng.");
        return null;
    }
    const randomIndex = Math.floor(Math.random() * validItemIds.length);
    const randomItemId = validItemIds[randomIndex];
    console.log("V·∫≠t ph·∫©m th∆∞·ªüng ng·∫´u nhi√™n ƒë∆∞·ª£c ch·ªçn:", randomItemId);
    return randomItemId;
}

/** [M·ªöI] Hi·ªÉn th·ªã popup ph·∫ßn th∆∞·ªüng v·ªõi th√¥ng tin v·∫≠t ph·∫©m */
function showRewardPopup(itemId) {
    // Ki·ªÉm tra c√°c ph·∫ßn t·ª≠ DOM c·∫ßn thi·∫øt
    if (!hatNgocTroiRewardPopup || !rewardItemImage || !rewardItemName || !confirmRewardBtn) {
        console.error("Thi·∫øu ph·∫ßn t·ª≠ DOM cho popup ph·∫ßn th∆∞·ªüng H·∫°t Ng·ªçc Tr·ªùi.");
        // N·∫øu thi·∫øu, kh√¥ng th·ªÉ hi·ªán popup, c·∫ßn kh·ªüi ƒë·ªông l·∫°i timer ƒë·ªÉ tr√°nh k·∫πt
        startHatNgocTroiTimer();
        return;
    }
    const item = ITEM_DATA[itemId];
    if (!item) {
        console.error(`Kh√¥ng t√¨m th·∫•y th√¥ng tin cho v·∫≠t ph·∫©m th∆∞·ªüng ID: ${itemId}`);
        // N·∫øu kh√¥ng t√¨m th·∫•y item, c≈©ng kh·ªüi ƒë·ªông l·∫°i timer
        startHatNgocTroiTimer();
        return;
    }

    // X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n ·∫£nh
    let iconSrc = 'Hinhanh/Caychet.png';
    if (item.type === 'seed' && item.imageFolder) {
        iconSrc = `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
    } else if (item.type === 'tool' && item.imageFolder && item.imageFile) {
        iconSrc = `${item.imageFolder}/${item.imageFile}`;
    }

    // C·∫≠p nh·∫≠t n·ªôi dung popup
    rewardItemImage.src = iconSrc;
    rewardItemImage.alt = item.name;
    rewardItemImage.onerror = () => { if (rewardItemImage.src !== 'Hinhanh/Caychet.png') rewardItemImage.src = 'Hinhanh/Caychet.png'; };
    rewardItemName.textContent = item.name;

    // L∆∞u itemId v√†o n√∫t x√°c nh·∫≠n
    confirmRewardBtn.dataset.itemId = itemId;

    // Hi·ªÉn th·ªã popup th∆∞·ªüng
    hatNgocTroiRewardPopup.style.display = 'block'; // Ho·∫∑c 'flex'
    console.log(`ƒêang hi·ªÉn th·ªã popup th∆∞·ªüng cho: ${item.name} (ID: ${itemId})`);
}

/** [M·ªöI] Th√™m ph·∫ßn th∆∞·ªüng v√†o kho, ƒë√≥ng popup th∆∞·ªüng v√† kh·ªüi ƒë·ªông l·∫°i timer H·∫°t Ng·ªçc Tr·ªùi */
function grantRewardAndClosePopup() {
           const itemId = confirmRewardBtn?.dataset?.itemId;
          if (!itemId || !ITEM_DATA[itemId]) {
              console.error("Kh√¥ng th·ªÉ x√°c ƒë·ªãnh v·∫≠t ph·∫©m th∆∞·ªüng ƒë·ªÉ trao.");
              closeRewardPopup();
              startHatNgocTroiTimer(); // Kh·ªüi ƒë·ªông l·∫°i timer n·∫øu c√≥ l·ªói
              return;
          }
          const item = ITEM_DATA[itemId];

          // --- [M·ªöI] Ki·ªÉm tra gi·ªõi h·∫°n kho ƒë·ªì tr∆∞·ªõc khi nh·∫≠n qu√† ---
          const currentTotalCount = getTotalInventoryCount();
          const giftQuantity = 1;

          if (currentTotalCount + giftQuantity > MAX_INVENTORY_CAPACITY) {
              showMessage(`Kho ƒë·ªì ƒë·∫ßy (${currentTotalCount}/${MAX_INVENTORY_CAPACITY}), kh√¥ng th·ªÉ nh·∫≠n ph·∫ßn th∆∞·ªüng "${item.name}" t·ª´ H·∫°t Ng·ªçc Tr·ªùi!`, "error");
              console.warn(`(H·∫°t Ng·ªçc Tr·ªùi) Kho ƒë·ªì ƒë·∫ßy, kh√¥ng th·ªÉ trao th∆∞·ªüng: ${item.name}`);
              logAction('gift_fail', null, `Kho ƒë·ªì ƒë·∫ßy (${currentTotalCount}/${MAX_INVENTORY_CAPACITY}), kh√¥ng nh·∫≠n ƒë∆∞·ª£c qu√† H·∫°t Ng·ªçc Tr·ªùi: ${item.name}.`, 'üö´', itemId);

              // ƒê√≥ng popup v√† kh·ªüi ƒë·ªông l·∫°i timer M√Ä KH√îNG trao th∆∞·ªüng
              closeRewardPopup();
              startHatNgocTroiTimer(); // Quan tr·ªçng: V·∫´n kh·ªüi ƒë·ªông l·∫°i timer
              return; // D·ª´ng l·∫°i ·ªü ƒë√¢y
          }
          // --- K·∫øt th√∫c ki·ªÉm tra gi·ªõi h·∫°n ---

          // Th√™m v·∫≠t ph·∫©m v√†o kho "ƒê√£ Mua" (n·∫øu kh√¥ng b·ªã ch·∫∑n b·ªüi ki·ªÉm tra ·ªü tr√™n)
          gameState.inventory[itemId] = (gameState.inventory[itemId] || 0) + 1;
          console.log(`ƒê√£ th√™m 1 ${item.name} (ID: ${itemId}) v√†o kho t·ª´ H·∫°t Ng·ªçc Tr·ªùi.`);

          // C·∫≠p nh·∫≠t UI li√™n quan (kho ƒë·ªì, shop, modals)
          if (inventoryModal.style.display === 'block') renderInventory(); // C·∫≠p nh·∫≠t kho ƒë·ªÉ th·∫•y item m·ªõi v√† ti√™u ƒë·ªÅ
          if (shopModal.style.display === 'block') updateShopButtons();
          if (plantActionModal.style.display === 'block' && currentActionPlotId !== null) updatePlantActionModalButtons(currentActionPlotId);
          if (emptyPlotActionModal.style.display === 'block' && currentActionPlotId !== null) updateEmptyPlotActionModal(currentActionPlotId);
          if (seedSelectionModal.style.display === 'block' && item.type === 'seed') populateSeedSelection();
          if (fertilizerSelectionModal.style.display === 'block' && item.type === 'tool' && typeof item.fertilityBoost === 'number') populateFertilizerSelection();

          saveGame();
          showMessage(`B·∫°n nh·∫≠n ƒë∆∞·ª£c 1 ${item.name} t·ª´ H·∫°t Ng·ªçc Tr·ªùi!`, "success");
          logAction('gift', null, `Nh·∫≠n qu√† t·ª´ H·∫°t Ng·ªçc Tr·ªùi: 1 ${item.name}.`, 'üíé', itemId);

          // ƒê√≥ng popup th∆∞·ªüng
          closeRewardPopup();

          // Kh·ªüi ƒë·ªông l·∫°i timer cho H·∫°t Ng·ªçc Tr·ªùi ti·∫øp theo
          console.log("Ph·∫ßn th∆∞·ªüng ƒë√£ ƒë∆∞·ª£c nh·∫≠n. Kh·ªüi ƒë·ªông l·∫°i timer H·∫°t Ng·ªçc Tr·ªùi.");
          startHatNgocTroiTimer();
      }

/** [M·ªöI] H√†m ri√™ng ƒë·ªÉ ƒë√≥ng popup ph·∫ßn th∆∞·ªüng */
function closeRewardPopup() {
      if (hatNgocTroiRewardPopup) {
        hatNgocTroiRewardPopup.style.display = 'none';
        if (confirmRewardBtn) {
             delete confirmRewardBtn.dataset.itemId;
        }
        console.log("ƒê√£ ƒë√≥ng popup th∆∞·ªüng H·∫°t Ng·ªçc Tr·ªùi.");
    }
}


/** [C·∫¨P NH·∫¨T] ƒê√≥ng Popup H·∫°t Ng·ªçc Tr·ªùi ban ƒë·∫ßu V√Ä k√≠ch ho·∫°t hi·ªÉn th·ªã ph·∫ßn th∆∞·ªüng */
function closeHatNgocTroiPopup() {
      if (hatNgocTroiPopup) {
        hatNgocTroiPopup.style.display = 'none'; // ƒê√≥ng popup ban ƒë·∫ßu
        console.log("ƒê√£ ƒë√≥ng Popup H·∫°t Ng·ªçc Tr·ªùi ban ƒë·∫ßu. Chu·∫©n b·ªã hi·ªÉn th·ªã ph·∫ßn th∆∞·ªüng.");

        // Ch·ªçn v·∫≠t ph·∫©m th∆∞·ªüng ng·∫´u nhi√™n
        const rewardItemId = getRandomRewardItem();

        if (rewardItemId && ITEM_DATA[rewardItemId]) { // Th√™m ki·ªÉm tra ITEM_DATA[rewardItemId] t·ªìn t·∫°i
            // *** Hi·ªÉn th·ªã popup ph·∫ßn th∆∞·ªüng ***
            showRewardPopup(rewardItemId);
        } else {
            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p kh√¥ng ch·ªçn ƒë∆∞·ª£c ph·∫ßn th∆∞·ªüng (v√≠ d·ª•: ITEM_DATA r·ªóng ho·∫∑c l·ªói)
            console.error(`Kh√¥ng th·ªÉ ch·ªçn ho·∫∑c t√¨m th·∫•y v·∫≠t ph·∫©m th∆∞·ªüng h·ª£p l·ªá. rewardItemId: ${rewardItemId}`);
            showMessage("·ªí! C√≥ l·ªói x·∫£y ra, kh√¥ng th·ªÉ nh·∫≠n ph·∫ßn th∆∞·ªüng H·∫°t Ng·ªçc Tr·ªùi.", "error");
            // [QUAN TR·ªåNG] V·∫´n ph·∫£i kh·ªüi ƒë·ªông l·∫°i timer ·ªü ƒë√¢y n·∫øu c√≥ l·ªói, ƒë·ªÉ game kh√¥ng b·ªã k·∫πt
            startHatNgocTroiTimer();
        }
        // --- Timer KH√îNG ƒë∆∞·ª£c kh·ªüi ƒë·ªông l·∫°i ·ªü ƒë√¢y ---
    } else {
         console.warn("Kh√¥ng t√¨m th·∫•y hatNgocTroiPopup ƒë·ªÉ ƒë√≥ng.");
    }
}
		
		
		
		
		/** Hi·ªÉn th·ªã Popup H·∫°t Ng·ªçc Tr·ªùi */
function showHatNgocTroiPopup() {
    if (hatNgocTroiPopup) {
        console.log("Hi·ªÉn th·ªã Popup H·∫°t Ng·ªçc Tr·ªùi!");
        hatNgocTroiPopup.style.display = 'block'; // Ho·∫∑c 'flex' t√πy theo CSS
        // Reset timer ƒë·ªÉ n√≥ kh√¥ng ch·∫°y l·∫°i ngay l·∫≠p t·ª©c
        clearTimeout(hatNgocTroiTimeout);
        hatNgocTroiTimeout = null;
    }
}

/** ƒê√≥ng Popup H·∫°t Ng·ªçc Tr·ªùi v√† kh·ªüi ƒë·ªông l·∫°i timer */
function closeHatNgocTroiPopup() {
    try {
        const allItemIds = Object.keys(ITEM_DATA);
        if (allItemIds.length > 0) {
            const randomIndex = Math.floor(Math.random() * allItemIds.length);
            const randomItemId = allItemIds[randomIndex];
            const giftedItem = ITEM_DATA[randomItemId];

            if (giftedItem) {
                // Th√™m 1 v·∫≠t ph·∫©m v√†o kho ƒë·ªì ƒê√É MUA
                gameState.inventory[randomItemId] = (gameState.inventory[randomItemId] || 0) + 1;
                console.log(`(H·∫°t Ng·ªçc Tr·ªùi) T·∫∑ng qu√†: 1 x ${giftedItem.name} (ID: ${randomItemId})`);

                // Chu·∫©n b·ªã th√¥ng b√°o
                let giftMessage = `‚ú® T·ª´ H·∫°t Ng·ªçc Tr·ªùi, b·∫°n nh·∫≠n ƒë∆∞·ª£c 1 ${giftedItem.name}!`;
                let giftIconType = 'üéÅ'; // Icon m·∫∑c ƒë·ªãnh
                if(giftedItem.type === 'seed') giftIconType = 'üå±';
                else if(giftedItem.id === 'pesticide') giftIconType = 'üíä';
                else if(typeof giftedItem.fertilityBoost === 'number') giftIconType = 'üí©';

                // Hi·ªÉn th·ªã th√¥ng b√°o (k√©o d√†i h∆°n m·ªôt ch√∫t)
                showMessage(`${giftIconType} ${giftMessage}`, "success", MESSAGE_DISPLAY_TIME * 1.5);

                // C·∫≠p nh·∫≠t UI li√™n quan (Kho ƒë·ªì, c√°c modal ch·ªçn/h√†nh ƒë·ªông)
                if (inventoryModal.style.display === 'block') renderInventory();
                if (seedSelectionModal.style.display === 'block' && giftedItem.type === 'seed') populateSeedSelection();
                if (fertilizerSelectionModal.style.display === 'block' && giftedItem.type === 'tool' && typeof giftedItem.fertilityBoost === 'number') populateFertilizerSelection();
                if (plantActionModal.style.display === 'block' && currentActionPlotId !== null) updatePlantActionModalButtons(currentActionPlotId);
                if (emptyPlotActionModal.style.display === 'block' && currentActionPlotId !== null) updateEmptyPlotActionModal(currentActionPlotId);
                // C·∫≠p nh·∫≠t c·∫£ n√∫t shop n·∫øu c·∫ßn (v√≠ d·ª• n·∫øu qu√† l√†m thay ƒë·ªïi s·ªë l∆∞·ª£ng thu·ªëc/ph√¢n)
                updateShopButtons();

                // L∆∞u game
                saveGame();

                // Ghi log
                logAction('gift', null, `Nh·∫≠n qu√† t·ª´ H·∫°t Ng·ªçc Tr·ªùi: 1 ${giftedItem.name}.`, 'üíé', randomItemId);

            } else {
                console.error("(H·∫°t Ng·ªçc Tr·ªùi) L·ªói: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho v·∫≠t ph·∫©m ng·∫´u nhi√™n:", randomItemId);
            }
        } else {
             console.warn("(H·∫°t Ng·ªçc Tr·ªùi) Kh√¥ng c√≥ v·∫≠t ph·∫©m n√†o trong ITEM_DATA ƒë·ªÉ t·∫∑ng.");
        }
    } catch (error) {
        console.error("L·ªói khi x·ª≠ l√Ω t·∫∑ng qu√† t·ª´ H·∫°t Ng·ªçc Tr·ªùi:", error);
        // C√≥ th·ªÉ th√™m showMessage l·ªói ·ªü ƒë√¢y n·∫øu mu·ªën
    }
    // --- K·∫øt th√∫c logic t·∫∑ng qu√† ---

    // --- Logic g·ªëc: ƒê√≥ng popup v√† Kh·ªüi ƒë·ªông l·∫°i timer ---
    if (hatNgocTroiPopup) {
        hatNgocTroiPopup.style.display = 'none';
        console.log("ƒê√£ ƒë√≥ng Popup H·∫°t Ng·ªçc Tr·ªùi (v√† t·∫∑ng qu√†). Kh·ªüi ƒë·ªông l·∫°i timer.");
        startHatNgocTroiTimer(); // Kh·ªüi ƒë·ªông l·∫°i timer ƒë·ªÉ popup c√≥ th·ªÉ xu·∫•t hi·ªán l·∫°i
    }
}

/** Kh·ªüi ƒë·ªông ho·∫∑c ƒë·∫∑t l·∫°i timer cho Popup H·∫°t Ng·ªçc Tr·ªùi */
function startHatNgocTroiTimer() {
              // Ch·ªâ kh·ªüi ƒë·ªông timer n·∫øu game ƒëang ch·∫°y v√† ch∆∞a c√≥ timer n√†o ƒëang ch·∫°y
            if (gameLoopInterval && !hatNgocTroiTimeout) {
                clearTimeout(hatNgocTroiTimeout); // X√≥a timer c≈© n·∫øu c√≥ (ph√≤ng l·ªói)

                // <<< T√çNH TO√ÅN DELAY NG·∫™U NHI√äN >>>
                const randomDelay = MIN_HAT_NGOC_TROI_DELAY_MS + Math.random() * (MAX_HAT_NGOC_TROI_DELAY_MS - MIN_HAT_NGOC_TROI_DELAY_MS);
                const randomDelaySeconds = Math.round(randomDelay / 1000); // Chuy·ªÉn sang gi√¢y ƒë·ªÉ log

                console.log(`B·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c kho·∫£ng ${formatTime(randomDelay)} (${randomDelaySeconds}s) cho H·∫°t Ng·ªçc Tr·ªùi ti·∫øp theo.`);
                hatNgocTroiTimeout = setTimeout(showHatNgocTroiPopup, randomDelay); // <<< S·ª¨ D·ª§NG DELAY NG·∫™U NHI√äN >>>

            } else if (!gameLoopInterval) {
                // console.log("Kh√¥ng b·∫Øt ƒë·∫ßu timer H·∫°t Ng·ªçc Tr·ªùi v√¨ game loop ch∆∞a ch·∫°y.");
            } else if (hatNgocTroiTimeout) {
                 // console.log("Timer H·∫°t Ng·ªçc Tr·ªùi ƒë√£ ch·∫°y.");
            }
        }

		
		
		
		
		
		 /** Ch·ªçn ng·∫´u nhi√™n m·ªôt icon th·ªùi ti·∫øt m·ªõi, tr√°nh ch·ªçn l·∫°i icon c≈© */
        function chooseRandomWeather() {
             const currentId = gameState.currentWeather?.id; // L·∫•y id hi·ªán t·∫°i m·ªôt c√°ch an to√†n

    // N·∫øu ch·ªâ c√≥ m·ªôt ho·∫∑c kh√¥ng c√≥ ch·∫ø ƒë·ªô th·ªùi ti·∫øt n√†o, tr·∫£ v·ªÅ c√°i ƒë·∫ßu ti√™n (ho·∫∑c undefined n·∫øu r·ªóng)
    if (WEATHER_DATA.length <= 1) {
        return WEATHER_DATA[0];
    }

    let newWeather;
    do {
        // Ch·ªçn ng·∫´u nhi√™n m·ªôt object t·ª´ m·∫£ng WEATHER_DATA
        newWeather = WEATHER_DATA[Math.floor(Math.random() * WEATHER_DATA.length)];
    } while (newWeather.id === currentId); // L·∫∑p l·∫°i n·∫øu ID tr√πng v·ªõi ID hi·ªán t·∫°i

    return newWeather; // Tr·∫£ v·ªÅ to√†n b·ªô object {id, icon, name}
        }
		/** C·∫≠p nh·∫≠t giao di·ªán ng∆∞·ªùi d√πng cho ph·∫ßn th·ªùi ti·∫øt */
        function renderWeatherUI() {
            // 1. Ki·ªÉm tra c√°c ph·∫ßn t·ª≠ DOM v√† d·ªØ li·ªáu c·∫ßn thi·∫øt (gi·ªØ nguy√™n)
            if (!weatherIconElement || !weatherNameElement || !weatherTimerElement || !weatherProgressBarElement || !gameState.currentWeather) {
                console.warn("Thi·∫øu ph·∫ßn t·ª≠ DOM th·ªùi ti·∫øt ho·∫∑c gameState.currentWeather kh√¥ng h·ª£p l·ªá.");
                // ƒê·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh/tr·ªëng khi c√≥ l·ªói
                if(weatherIconElement) weatherIconElement.textContent = '‚ùì';
                if(weatherNameElement) weatherNameElement.textContent = '---';
                if(weatherTimerElement) weatherTimerElement.textContent = '--:--';
                if(weatherProgressBarElement) weatherProgressBarElement.style.width = '0%';
                // <<< TH√äM: ƒê·∫£m b·∫£o x√≥a class n·∫øu c√≥ l·ªói d·ªØ li·ªáu th·ªùi ti·∫øt >>>
                const gameContainerForReset = document.getElementById('game-container');
                if (gameContainerForReset) {
                    gameContainerForReset.classList.remove('darken-weather-effect');
                }
                // <<< K·∫æT TH√öC TH√äM >>>
                return; // Tho√°t s·ªõm n·∫øu thi·∫øu
            }

            // 2. T√≠nh to√°n th·ªùi gian v√† ti·∫øn tr√¨nh (gi·ªØ nguy√™n)
            const now = Date.now();
            const timeUntilChange = Math.max(0, gameState.nextWeatherChangeTimestamp - now);
            const totalDuration = WEATHER_CHANGE_INTERVAL_MS;
            const progressPercent = totalDuration > 0
                ? Math.max(0, Math.min(100, (timeUntilChange / totalDuration) * 100))
                : 0;

            // 3. L·∫•y c√°c thu·ªôc t√≠nh c·∫ßn thi·∫øt t·ª´ gameState.currentWeather
            const { id, icon, name } = gameState.currentWeather;

            // 4. C·∫≠p nh·∫≠t giao di·ªán ng∆∞·ªùi d√πng th·ªùi ti·∫øt (icon, t√™n, timer, progress) - gi·ªØ nguy√™n
            weatherIconElement.textContent = icon;
            weatherIconElement.title = `Th·ªùi ti·∫øt hi·ªán t·∫°i: ${name}`;
            weatherNameElement.textContent = name;
            const minutes = Math.floor(timeUntilChange / 60000);
            const seconds = Math.floor((timeUntilChange % 60000) / 1000);
            weatherTimerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            weatherTimerElement.title = `Th·ªùi gian c√≤n l·∫°i ƒë·∫øn khi ƒë·ªïi th·ªùi ti·∫øt: ${formatTime(timeUntilChange)}`;
            weatherProgressBarElement.style.width = `${progressPercent}%`;
            if (weatherProgressContainer) {
                weatherProgressContainer.title = `Ti·∫øn ƒë·ªô chu k·ª≥ th·ªùi ti·∫øt hi·ªán t·∫°i (${name})`;
            }

            // --- [M·ªöI] Logic l√†m t·ªëi UI khi m∆∞a/b√£o ---
            const shouldDarken = (id === 'rainy' || id === 'thunderstorm'); // ƒêi·ªÅu ki·ªán ƒë·ªÉ l√†m t·ªëi
            const gameContainerElement = document.getElementById('game-container');

            if (gameContainerElement) {
                // S·ª≠ d·ª•ng classList.toggle ƒë·ªÉ th√™m/x√≥a class m·ªôt c√°ch g·ªçn g√†ng
                // Tham s·ªë th·ª© hai l√† boolean: true -> th√™m class, false -> x√≥a class
                gameContainerElement.classList.toggle('darken-weather-effect', shouldDarken);

                // Log ƒë·ªÉ debug (t√πy ch·ªçn)
                // if (shouldDarken && !gameContainerElement.classList.contains('darken-weather-effect')) {
                //     console.log("Applying darken effect for weather:", id);
                // } else if (!shouldDarken && gameContainerElement.classList.contains('darken-weather-effect')) {
                //     console.log("Removing darken effect for weather:", id);
                // }
            } else {
                // C√°i n√†y kh√¥ng n√™n x·∫£y ra n·∫øu HTML ƒë√∫ng
                console.error("renderWeatherUI: Kh√¥ng th·ªÉ t√¨m th·∫•y ph·∫ßn t·ª≠ #game-container ƒë·ªÉ √°p d·ª•ng hi·ªáu ·ª©ng th·ªùi ti·∫øt!");
            }
            // --- K·∫øt th√∫c Logic l√†m t·ªëi UI ---
        }
		    // --- Listener ƒë·ªÉ b·∫Øt ƒë·∫ßu nh·∫°c n·ªÅn sau t∆∞∆°ng t√°c ƒë·∫ßu ti√™n ---
		 function openConfirmSellAllModal(itemId, itemName, quantity, totalValue) {
            if (!confirmSellAllModal || !confirmSellItemName || !confirmSellQuantity || !confirmSellTotalValue || !confirmSellAllBtn) {
                console.error("L·ªói: Thi·∫øu c√°c ph·∫ßn t·ª≠ DOM cho modal x√°c nh·∫≠n b√°n h·∫øt.");
                return;
            }
            // ƒêi·ªÅn th√¥ng tin v√†o modal
            confirmSellItemName.textContent = itemName;
            confirmSellQuantity.textContent = quantity;
            confirmSellTotalValue.textContent = totalValue;

            // L∆∞u th√¥ng tin v√†o dataset c·ªßa n√∫t x√°c nh·∫≠n ƒë·ªÉ h√†m x·ª≠ l√Ω c√≥ th·ªÉ l·∫•y
            confirmSellAllBtn.dataset.itemId = itemId;
            confirmSellAllBtn.dataset.quantity = quantity;

            // Hi·ªÉn th·ªã modal
            openModal('confirm-sell-all-modal'); // D√πng h√†m openModal chung
        }

        /** ƒê√≥ng h·ªôp tho·∫°i x√°c nh·∫≠n b√°n h·∫øt */
        function closeConfirmSellAllModal() {
            if (confirmSellAllModal) {
                closeModal('confirm-sell-all-modal'); // D√πng h√†m closeModal chung
                // X√≥a d·ªØ li·ªáu kh·ªèi n√∫t ƒë·ªÉ tr√°nh l·ªói
                if (confirmSellAllBtn) {
                    delete confirmSellAllBtn.dataset.itemId;
                    delete confirmSellAllBtn.dataset.quantity;
                }
            }
        }

        /** X·ª≠ l√Ω khi click n√∫t X√°c nh·∫≠n trong h·ªôp tho·∫°i b√°n h·∫øt */
        function handleConfirmSellAll() {
            if (!confirmSellAllBtn) return;
            const itemId = confirmSellAllBtn.dataset.itemId;
            const quantityString = confirmSellAllBtn.dataset.quantity;

            if (!itemId || !quantityString) {
                console.error("L·ªói: Kh√¥ng t√¨m th·∫•y itemId ho·∫∑c quantity tr√™n n√∫t x√°c nh·∫≠n b√°n h·∫øt.");
                closeConfirmSellAllModal();
                return;
            }

            const quantity = parseInt(quantityString);
            if (isNaN(quantity) || quantity <= 0) {
                console.error("L·ªói: S·ªë l∆∞·ª£ng b√°n h·∫øt kh√¥ng h·ª£p l·ªá:", quantityString);
                closeConfirmSellAllModal();
                return;
            }

            // G·ªçi h√†m b√°n v·ªõi th√¥ng tin ƒë√£ l∆∞u
            sellHarvestedItem(itemId, quantity);
            // ƒê√≥ng modal sau khi b√°n
            closeConfirmSellAllModal();
        }

        // G·∫Øn listener cho c√°c n√∫t trong modal x√°c nh·∫≠n (n√™n th·ª±c hi·ªán trong attachEventListeners)
        // Tuy nhi√™n, ƒë·ªÉ ƒë∆°n gi·∫£n, c√≥ th·ªÉ th√™m tr·ª±c ti·∫øp ·ªü ƒë√¢y n·∫øu c√°c n√∫t lu√¥n t·ªìn t·∫°i
        if (confirmSellAllBtn) {
             confirmSellAllBtn.addEventListener('click', handleConfirmSellAll);
        } else { console.warn("Kh√¥ng t√¨m th·∫•y n√∫t confirm-sell-all-btn khi g·∫Øn listener."); }

        if (cancelSellAllBtn) {
             cancelSellAllBtn.addEventListener('click', closeConfirmSellAllModal);
        } else { console.warn("Kh√¥ng t√¨m th·∫•y n√∫t cancel-sell-all-btn khi g·∫Øn listener."); }
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
    function playMusicOnFirstInteraction() {
    // >>> THAY ƒê·ªîI: Ch·ªâ th·ª≠ ph√°t n·∫øu ng∆∞·ªùi d√πng ƒë√£ b·∫≠t ho·∫∑c ch∆∞a t∆∞∆°ng t√°c <<<
    if (!musicStarted && backgroundMusic && (isMusicManuallyEnabled || !toggleSoundBtn || toggleSoundBtn.textContent.includes('T·∫Øt'))) {
    // >>> K·∫æT TH√öC THAY ƒê·ªîI <<<
        const playPromise = backgroundMusic.play();

        if (playPromise !== undefined) {
            playPromise.then(_ => {
                console.log("Nh·∫°c n·ªÅn ƒë√£ b·∫Øt ƒë·∫ßu ph√°t.");
                musicStarted = true;
                isMusicManuallyEnabled = true; // ƒê√°nh d·∫•u l√† ƒë√£ b·∫≠t (k·ªÉ c·∫£ t·ª± ƒë·ªông)
                // >>> C·∫¨P NH·∫¨T VƒÇN B·∫¢N N√öT <<<
                if (toggleSoundBtn) {
                    toggleSoundBtn.textContent = "üîá T·∫Øt √Çm Thanh";
                }
                // >>> K·∫æT TH√öC C·∫¨P NH·∫¨T <<<
                document.removeEventListener('click', playMusicOnFirstInteraction, { capture: true });
            })
            .catch(error => {
                console.warn("Kh√¥ng th·ªÉ t·ª± ƒë·ªông ph√°t nh·∫°c n·ªÅn (c·∫ßn t∆∞∆°ng t√°c ng∆∞·ªùi d√πng):", error);
                // N·∫øu l·ªói, ƒë·∫£m b·∫£o n√∫t hi·ªÉn th·ªã ƒë√∫ng tr·∫°ng th√°i "B·∫≠t"
                if (toggleSoundBtn && !backgroundMusic.paused) { // Ki·ªÉm tra l·∫°i n·∫øu play() l·ªói nh∆∞ng nh·∫°c v·∫´n ch·∫°y? (Hi·∫øm)
                    toggleSoundBtn.textContent = "üîá T·∫Øt √Çm Thanh";
                } else if (toggleSoundBtn) {
                    toggleSoundBtn.textContent = "üîä B·∫≠t √Çm Thanh";
                }
                isMusicManuallyEnabled = false; // ƒê·∫∑t l·∫°i n·∫øu t·ª± ƒë·ªông ph√°t l·ªói
            });
        } else {
             // N·∫øu playPromise l√† undefined (tr√¨nh duy·ªát c≈© kh√¥ng h·ªó tr·ª£), c·∫≠p nh·∫≠t n√∫t d·ª±a tr√™n tr·∫°ng th√°i hi·ªán t·∫°i
             updateSoundButtonText();
			 
			 // Lu√¥n g·∫Øn listener v√¨ m·∫∑c ƒë·ªãnh l√† mu·ªën b·∫≠t nh·∫°c
        document.addEventListener('click', playMusicOnFirstInteraction, { capture: true });
        console.log("ƒê√£ g·∫Øn listener ƒë·ªÉ c·ªë g·∫Øng ph√°t nh·∫°c sau t∆∞∆°ng t√°c ƒë·∫ßu ti√™n.");
        }
    } else if (musicStarted) {
         document.removeEventListener('click', playMusicOnFirstInteraction, { capture: true });
    }
}

    // G·∫Øn listener v√†o document ƒë·ªÉ b·∫Øt click b·∫•t k·ª≥ ƒë√¢u
    // S·ª≠ d·ª•ng capture: true ƒë·ªÉ ƒë·∫£m b·∫£o listener n√†y ch·∫°y tr∆∞·ªõc c√°c listener kh√°c c√≥ th·ªÉ ngƒÉn ch·∫∑n s·ª± ki·ªán (stopPropagation)
    document.addEventListener('click', playMusicOnFirstInteraction, { capture: true });
    console.log("ƒê√£ g·∫Øn listener ƒë·ªÉ ph√°t nh·∫°c n·ªÅn sau t∆∞∆°ng t√°c.");
    // --- K·∫øt th√∫c Listener nh·∫°c n·ªÅn ---


        /** Kh·ªüi t·∫°o m√¥i tr∆∞·ªùng game. */
      function initGame() {
    console.log(`ƒêang kh·ªüi t·∫°o V∆∞·ªùn H·∫°nh Ph√∫c (Kh√≥a L∆∞u: ${GAME_SAVE_KEY})...`);
    try {
        // 1. T·∫£i t·∫•t c·∫£ tr·∫°ng th√°i game, bao g·ªìm c·∫£ c√†i ƒë·∫∑t √¢m thanh
        loadGame();

        // 2. Kh·ªüi t·∫°o d·ªØ li·ªáu logic game d·ª±a tr√™n tr·∫°ng th√°i ƒë√£ t·∫£i
        initializePlotsData(); // D·ª±a tr√™n gameState.maxUnlockedPlots ƒë√£ t·∫£i

        // 3. Render giao di·ªán ban ƒë·∫ßu d·ª±a tr√™n tr·∫°ng th√°i ƒë√£ t·∫£i
        renderGarden();        // V·∫Ω c√°c √¥ ƒë·∫•t
        renderUI();            // C·∫≠p nh·∫≠t ti·ªÅn, s·ªë √¥
        populateShop();        // ƒêi·ªÅn v·∫≠t ph·∫©m v√†o c·ª≠a h√†ng

        // 4. B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p game ch√≠nh
        startGameLoop();

        // 5. Hi·ªÉn th·ªã game v√† ·∫©n ch·ªâ b√°o t·∫£i
        loadingIndicator.style.display = 'none';
        gameContainer.classList.remove('hidden');

        // 6. G·∫Øn c√°c tr√¨nh l·∫Øng nghe s·ª± ki·ªán cho c√°c n√∫t v√† ph·∫ßn t·ª≠ t∆∞∆°ng t√°c
        attachEventListeners();

        // 7. C·∫≠p nh·∫≠t vƒÉn b·∫£n n√∫t √¢m thanh D·ª∞A TR√äN TR·∫†NG TH√ÅI ƒê√É T·∫¢I trong loadGame()
        updateSoundButtonText();       // C·∫≠p nh·∫≠t n√∫t nh·∫°c n·ªÅn
        updateEffectSoundButtonText(); // C·∫≠p nh·∫≠t n√∫t hi·ªáu ·ª©ng

        // 8. Hi·ªÉn th·ªã th√¥ng b√°o ch√†o m·ª´ng
        console.log("Kh·ªüi t·∫°o game ho√†n t·∫•t. Ch√†o m·ª´ng!");
        if(gameState.totalPlayTime < 10 * 1000) showMessage("Ch√†o m·ª´ng ƒë·∫øn V∆∞·ªùn C√¢y H·∫°nh Ph√∫c!", "success");
        else showMessage("Ch√†o m·ª´ng quay tr·ªü l·∫°i!", "info");

        // 9. X·ª≠ l√Ω nh·∫°c n·ªÅn ban ƒë·∫ßu (Kh√¥ng t·ª± ƒë·ªông ph√°t ngay)
        // Ch·ªâ log tr·∫°ng th√°i, vi·ªác ph√°t s·∫Ω ch·ªù t∆∞∆°ng t√°c ho·∫∑c visibility change
        if (isMusicEnabled) {
            console.log("INIT: Nh·∫°c n·ªÅn ƒëang ƒë∆∞·ª£c B·∫¨T theo c√†i ƒë·∫∑t. S·∫Ω ph√°t sau t∆∞∆°ng t√°c.");
        } else {
            console.log("INIT: Nh·∫°c n·ªÅn ƒëang ƒë∆∞·ª£c T·∫ÆT theo c√†i ƒë·∫∑t.");
            // ƒê·∫£m b·∫£o audio element c≈©ng ·ªü tr·∫°ng th√°i pause n·∫øu c√†i ƒë·∫∑t l√† t·∫Øt
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
            }
        }

    } catch (error) {
        // X·ª≠ l√Ω l·ªói nghi√™m tr·ªçng trong qu√° tr√¨nh kh·ªüi t·∫°o
        console.error("L·ªñI NGHI√äM TR·ªåNG trong qu√° tr√¨nh kh·ªüi t·∫°o game:", error);
        loadingIndicator.textContent = "L·ªói nghi√™m tr·ªçng! Kh√¥ng th·ªÉ t·∫£i game. H√£y th·ª≠ x√≥a d·ªØ li·ªáu trang web.";
        loadingIndicator.style.color = 'red';
        // Kh√¥ng ·∫©n loading ƒë·ªÉ ng∆∞·ªùi d√πng th·∫•y l·ªói
    }
} // --- K·∫øt th√∫c h√†m initGame ---


        /** G·∫Øn c√°c tr√¨nh l·∫Øng nghe s·ª± ki·ªán ch√≠nh. */
      function attachEventListeners() {
    console.log("[V10 Buy Fix attachEventListeners] Starting to attach event listeners...");
    let listenerCount = 0; // ƒê·∫øm s·ªë l∆∞·ª£ng listener ƒë√£ g·∫Øn th√†nh c√¥ng

    // --- N√öT UI CH√çNH ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Main UI button listeners...");
    if (openShopBtn) {
        openShopBtn.addEventListener('click', () => {
            console.log("[V10 UI Click] Open Shop Button");
            switchShopTab('seeds');
            openModal('shop-modal');
        });
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: openShopBtn not found."); }

    if (openInventoryBtn) {
        openInventoryBtn.addEventListener('click', () => {
            console.log("[V10 UI Click] Open Inventory Button");
            switchInventoryTab('harvested');
            renderInventory(); // Render tr∆∞·ªõc khi m·ªü ƒë·ªÉ l·∫•y s·ªë l∆∞·ª£ng m·ªõi nh·∫•t
            openModal('inventory-modal');
        });
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: openInventoryBtn not found."); }

    if (openMenuBtn) {
        openMenuBtn.addEventListener('click', () => {
            console.log("[V10 UI Click] Open Menu Button");
            openMenuPopup();
        });
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: openMenuBtn not found."); }

    // --- N√öT TRONG MENU POPUP ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Menu Popup button listeners...");
    if (menuPopup) { // Ch·ªâ g·∫Øn listener n√∫t con n·∫øu popup cha t·ªìn t·∫°i
        const closeMenuPopupBtn = menuPopup.querySelector('.close-button');
        if (closeMenuPopupBtn) {
            closeMenuPopupBtn.addEventListener('click', closeMenuPopup);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: Close button not found inside menuPopup."); }

        if (plantingHistoryBtn) {
            plantingHistoryBtn.addEventListener('click', handlePlantingHistoryClick);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: plantingHistoryBtn not found."); }

        if (toggleSoundBtn) {
            toggleSoundBtn.addEventListener('click', toggleBackgroundMusic);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: toggleSoundBtn not found."); }

        if (toggleEffectsSoundBtn) {
            toggleEffectsSoundBtn.addEventListener('click', toggleEffectSounds);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: toggleEffectsSoundBtn not found."); }

        if (exportImportBtn) {
            exportImportBtn.addEventListener('click', openSavegamePopup);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: exportImportBtn not found."); }
		 if (dailyQuestBtn) { // <<< TH√äM LISTENER CHO N√öT NHI·ªÜM V·ª§
        dailyQuestBtn.addEventListener('click', openDailyQuestPopup);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: dailyQuestBtn not found."); }
		
		
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: menuPopup element not found, skipping child listeners."); }


    // --- KHU V∆Ø·ªúN (S·ª≠ d·ª•ng ·ª¶y Quy·ªÅn S·ª± Ki·ªán - Event Delegation) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Garden area listeners...");
    if (gardenElement) {
        gardenElement.addEventListener('click', handleGardenClick);
        gardenElement.addEventListener('mouseover', handlePlotMouseover);
        gardenElement.addEventListener('mouseout', handlePlotMouseout);
        gardenElement.addEventListener('mousemove', handlePlotMousemove);
        listenerCount += 4; // ƒê·∫øm 4 listeners ƒë√£ g·∫Øn
        console.log("[V10 Buy Fix attachEventListeners] Garden listeners attached successfully.");
    } else {
        console.error("[V10 Buy Fix attachEventListeners] FATAL ERROR: gardenElement not found! Plot interactions will not work.");
    }

    // --- ƒê√ìNG MODAL/POPUP TO√ÄN C·ª§C ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching global modal/popup closing listeners...");
    window.addEventListener('click', handleModalBackgroundClick);
    document.addEventListener('keydown', handleEscapeKey);
    listenerCount += 2;

    // --- TABS TRONG C√ÅC MODAL ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Tab listeners...");
    if (shopTabsContainer) {
        shopTabsContainer.addEventListener('click', handleShopTabClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: shopTabsContainer not found."); }

    if (inventoryTabsContainer) {
        inventoryTabsContainer.addEventListener('click', handleInventoryTabClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: inventoryTabsContainer not found."); }

    // --- DANH S√ÅCH V·∫¨T PH·∫®M (·ª¶y quy·ªÅn) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Item List listeners (Shop & Inventory)...");
    // C·ª≠a h√†ng (Mua v√† thay ƒë·ªïi s·ªë l∆∞·ª£ng) - G·∫Øn listener v√†o container cha
    if (shopSeedList) {
        shopSeedList.addEventListener('click', handleShopItemClick); // X·ª≠ l√Ω click n√∫t Mua
        shopSeedList.addEventListener('input', handleShopQuantityChange); // X·ª≠ l√Ω thay ƒë·ªïi input
        shopSeedList.addEventListener('change', handleShopQuantityChange); // Backup listener cho input
        listenerCount += 3;
        console.log("[V10 Buy Fix attachEventListeners] Shop Seed List listeners attached.");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: shopSeedList not found."); }

    if (shopToolList) {
        shopToolList.addEventListener('click', handleShopItemClick); // X·ª≠ l√Ω click n√∫t Mua
        shopToolList.addEventListener('input', handleShopQuantityChange); // X·ª≠ l√Ω thay ƒë·ªïi input
        shopToolList.addEventListener('change', handleShopQuantityChange); // Backup listener cho input
        listenerCount += 3;
        console.log("[V10 Buy Fix attachEventListeners] Shop Tool List listeners attached.");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: shopToolList not found."); }

    // Kho ƒë·ªì (B√°n v√† B·ªè) - G·∫Øn listener v√†o container cha
    if (inventoryHarvestedList) {
        inventoryHarvestedList.addEventListener('click', handleSellHarvestedClick); // X·ª≠ l√Ω click n√∫t B√°n / B√°n h·∫øt
        listenerCount++;
        console.log("[V10 Buy Fix attachEventListeners] Inventory Harvested List listeners attached.");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: inventoryHarvestedList not found."); }

    if (inventoryPurchasedList) {
        inventoryPurchasedList.addEventListener('click', handleDiscardPurchasedItemClick); // X·ª≠ l√Ω click n√∫t B·ªè ƒëi...
        listenerCount++;
        console.log("[V10 Buy Fix attachEventListeners] Inventory Purchased List listeners attached.");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: inventoryPurchasedList not found."); }

    // --- MODAL L·ª∞A CH·ªåN (·ª¶y quy·ªÅn) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Selection Modal listeners...");
    if (seedSelectionList) {
        seedSelectionList.addEventListener('click', handleSeedSelectionClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: seedSelectionList not found."); }

    if (fertilizerSelectionList) {
        fertilizerSelectionList.addEventListener('click', handleFertilizerSelection);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: fertilizerSelectionList not found."); }

    // --- MODAL H√ÄNH ƒê·ªòNG (·ª¶y quy·ªÅn) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Action Modal listeners...");
    if (plantActionButtonsContainer) {
        plantActionButtonsContainer.addEventListener('click', handlePlantActionClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: plantActionButtonsContainer not found."); }

    if (emptyPlotActionButtonsContainer) {
        emptyPlotActionButtonsContainer.addEventListener('click', handleEmptyPlotActionClick);
        listenerCount++;
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: emptyPlotActionButtonsContainer not found."); }

    if (lightningRodActionModal) {
        const rodButtonsContainer = lightningRodActionModal.querySelector('#rod-action-buttons');
        if (rodButtonsContainer) {
            rodButtonsContainer.addEventListener('click', handleRodActionClick);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: #rod-action-buttons container not found inside lightningRodActionModal."); }
        // N√∫t ƒë√≥ng cho modal n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi listener to√†n c·ª•c ho·∫∑c Escape
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: lightningRodActionModal not found."); }

    // --- POPUP X√ÅC NH·∫¨N C·ª§ TH·ªÇ (G·∫Øn listener tr·ª±c ti·∫øp v√†o n√∫t con) ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Confirmation Popup button listeners...");

    // Popup Mua √î ƒê·∫•t
    if (lockedPlotPopup) {
        if (confirmBuyPlotBtn) { confirmBuyPlotBtn.addEventListener('click', handleConfirmBuyPlot); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmBuyPlotBtn not found in lockedPlotPopup."); }
        if (cancelBuyPlotBtn) { cancelBuyPlotBtn.addEventListener('click', closeLockedPlotPopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: cancelBuyPlotBtn not found in lockedPlotPopup."); }
        const lockedPlotCloseBtn = lockedPlotPopup.querySelector('.close-popup-btn');
        if (lockedPlotCloseBtn) { lockedPlotCloseBtn.addEventListener('click', closeLockedPlotPopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: .close-popup-btn not found in lockedPlotPopup."); }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: lockedPlotPopup element not found."); }

    // Popup X√°c nh·∫≠n B√°n H·∫øt
    if (confirmSellAllModal) {
        if (confirmSellAllBtn) { confirmSellAllBtn.addEventListener('click', handleConfirmSellAll); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirm-sell-all-btn not found."); }
        if (cancelSellAllBtn) { cancelSellAllBtn.addEventListener('click', closeConfirmSellAllModal); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: cancel-sell-all-btn not found."); }
        const closeSellAllPopupBtn = confirmSellAllModal.querySelector('.close-button');
        if(closeSellAllPopupBtn) { closeSellAllPopupBtn.addEventListener('click', closeConfirmSellAllModal); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: .close-button not found in confirmSellAllModal."); }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmSellAllModal element not found."); }

    // Popup B·ªè V·∫≠t Ph·∫©m
    if (discardItemPopup) {
        if (confirmDiscardBtn) { confirmDiscardBtn.addEventListener('click', handleConfirmDiscardClick); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmDiscardBtn not found."); }
        if (cancelDiscardBtn) { cancelDiscardBtn.addEventListener('click', closeDiscardItemPopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: cancelDiscardBtn not found."); }
        const closeDiscardPopupBtn = discardItemPopup.querySelector('.close-button');
        if (closeDiscardPopupBtn) { closeDiscardPopupBtn.addEventListener('click', closeDiscardItemPopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: .close-button not found in discardItemPopup."); }
        if (discardQuantityInput) { // G·∫Øn listener cho input s·ªë l∆∞·ª£ng b·ªè
            discardQuantityInput.addEventListener('input', () => {
                if (confirmDiscardBtn) confirmDiscardBtn.disabled = false;
                if (discardQuantityError) { discardQuantityError.textContent = ''; discardQuantityError.style.display = 'none'; }
            });
            listenerCount++;
            discardQuantityInput.addEventListener('blur', () => { // Ki·ªÉm tra khi m·∫•t focus
                const qty = parseInt(discardQuantityInput.value); const max = parseInt(discardQuantityInput.max); let err = '';
                if (isNaN(qty) || qty < 1) err = 'SL > 0.'; else if (qty > max) err = `SL <= ${max}.`;
                if (err && discardQuantityError && confirmDiscardBtn) { discardQuantityError.textContent = err; discardQuantityError.style.display = 'block'; confirmDiscardBtn.disabled = true; }
                else if (discardQuantityError && confirmDiscardBtn) { discardQuantityError.textContent = ''; discardQuantityError.style.display = 'none'; confirmDiscardBtn.disabled = false; }
            });
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: discardQuantityInput not found."); }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: discardItemPopup element not found."); }

    // Popup X√°c nh·∫≠n S·ª≠a C·ªôt Thu L√¥i
    if (confirmRepairRodPopup) {
        const confirmBtn = confirmRepairRodPopup.querySelector('#confirm-repair-rod-btn');
        const cancelBtn = confirmRepairRodPopup.querySelector('#cancel-repair-rod-btn');
        const closeBtn = confirmRepairRodPopup.querySelector('.close-popup-btn');
        if (confirmBtn) { confirmBtn.addEventListener('click', handleConfirmRepair); listenerCount++; } else console.warn("Missing confirm-repair-rod-btn");
        if (cancelBtn) { cancelBtn.addEventListener('click', closeConfirmRepairPopup); listenerCount++; } else console.warn("Missing cancel-repair-rod-btn");
        if (closeBtn) { closeBtn.addEventListener('click', closeConfirmRepairPopup); listenerCount++; } else console.warn("Missing close-popup-btn in confirm-repair-rod-popup");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmRepairRodPopup not found."); }

    // Popup X√°c nh·∫≠n G·ª° C·ªôt Thu L√¥i
    if (confirmRemoveRodPopup) {
        const confirmBtn = confirmRemoveRodPopup.querySelector('#confirm-remove-rod-btn');
        const cancelBtn = confirmRemoveRodPopup.querySelector('#cancel-remove-rod-btn');
        const closeBtn = confirmRemoveRodPopup.querySelector('.close-popup-btn');
        if (confirmBtn) { confirmBtn.addEventListener('click', handleConfirmRemove); listenerCount++; } else console.warn("Missing confirm-remove-rod-btn");
        if (cancelBtn) { cancelBtn.addEventListener('click', closeConfirmRemovePopup); listenerCount++; } else console.warn("Missing cancel-remove-rod-btn");
        if (closeBtn) { closeBtn.addEventListener('click', closeConfirmRemovePopup); listenerCount++; } else console.warn("Missing close-popup-btn in confirm-remove-rod-popup");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmRemoveRodPopup not found."); }

    // Popup L∆∞u/Nh·∫≠p Game
    if (savegamePopup) {
        const closeSavegamePopupBtn = savegamePopup.querySelector('.close-button');
        if (closeSavegamePopupBtn) { closeSavegamePopupBtn.addEventListener('click', closeSavegamePopup); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: Close button not found in savegamePopup."); }
        if (btnSaveGame) { btnSaveGame.addEventListener('click', exportGameStateToFile); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: btn-savegame not found."); }
        if (btnImportSaveGame) { btnImportSaveGame.addEventListener('click', importGameStateFromFile); listenerCount++; }
        else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: btn-import-savegame not found."); }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: savegamePopup element not found."); }

    // Popup X√°c nh·∫≠n Kh√¥i Ph·ª•c Game
    const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
    if (confirmRestorePopup) {
        const confirmBtn = confirmRestorePopup.querySelector('#confirm-restore-btn');
        const cancelBtn = confirmRestorePopup.querySelector('#cancel-restore-btn');
        const closeBtn = confirmRestorePopup.querySelector('.close-button');
        if (confirmBtn) { confirmBtn.addEventListener('click', handleConfirmRestore); listenerCount++; }
        else console.warn("Missing #confirm-restore-btn in #popup-confirm-restoregame");
        if (cancelBtn) { cancelBtn.addEventListener('click', handleCancelRestore); listenerCount++; }
        else console.warn("Missing #cancel-restore-btn in #popup-confirm-restoregame");
        if (closeBtn) { closeBtn.addEventListener('click', handleCancelRestore); listenerCount++; } // N√∫t X c≈©ng l√† h·ªßy
        else console.warn("Missing .close-button in #popup-confirm-restoregame");
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: popup-confirm-restoregame not found."); }

    // Popup Ph·∫ßn Th∆∞·ªüng H·∫°t Ng·ªçc Tr·ªùi
    if (hatNgocTroiRewardPopup) {
        if (confirmRewardBtn) {
            confirmRewardBtn.addEventListener('click', grantRewardAndClosePopup);
            listenerCount++;
        } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: confirmRewardBtn not found for reward popup."); }
        // N√∫t ƒë√≥ng kh√°c n·∫øu c√≥
        const closeRewardPopupBtn = hatNgocTroiRewardPopup.querySelector('.close-button');
        if (closeRewardPopupBtn) {
            closeRewardPopupBtn.addEventListener('click', closeRewardPopup); // ƒê·∫£m b·∫£o c≈©ng ƒë√≥ng popup
            listenerCount++;
        }
    } else { console.warn("[V10 Buy Fix attachEventListeners] WARNING: hat-ngoc-troi-reward-popup element not found."); }

    // --- S·ª∞ KI·ªÜN V√íNG ƒê·ªúI TRANG ---
    console.log("[V10 Buy Fix attachEventListeners] Attaching Page Lifecycle listeners...");
    window.addEventListener('beforeunload', handlePageUnload);
    document.addEventListener('visibilitychange', handleVisibilityChange);
    listenerCount += 2;

    console.log(`[V10 Buy Fix attachEventListeners] Finished attaching approximately ${listenerCount} event listeners.`);
} // --- K·∫øt th√∫c h√†m attachEventListeners ---

        /** Kh·ªüi t·∫°o ho·∫∑c x√°c th·ª±c m·∫£ng d·ªØ li·ªáu gameState.plots d·ª±a tr√™n maxUnlockedPlots */
        function initializePlotsData() {
    // Tr·∫°ng th√°i m·∫∑c ƒë·ªãnh cho m·ªôt √¥ ƒë·∫•t, bao g·ªìm c√°c tr∆∞·ªùng m·ªõi nh·∫•t
    const defaultPlotState = {
        seedId: null,               // ID h·∫°t gi·ªëng ƒëang tr·ªìng (null n·∫øu tr·ªëng)
        plantTime: null,            // Timestamp khi b·∫Øt ƒë·∫ßu tr·ªìng
        hasPest: false,             // C·ªù b√°o c√≥ s√¢u hay kh√¥ng
        health: INITIAL_PLANT_HEALTH, // M√°u hi·ªán t·∫°i c·ªßa c√¢y
        fertility: BASE_FERTILITY,  // ƒê·ªô ph√¨ nhi√™u hi·ªán t·∫°i c·ªßa ƒë·∫•t (%)
        causeOfDeath: null,         // Nguy√™n nh√¢n ch·∫øt ('pest' ho·∫∑c null)
        pestDeathClickCount: 0,     // S·ªë l·∫ßn click ƒë·ªÉ d·ªçn c√¢y ch·∫øt do s√¢u mi·ªÖn ph√≠
        barrenHarvestPenaltyFactor: 1.0, // H·ªá s·ªë nh√¢n th·ªùi gian m·ªçc n·∫øu thu ho·∫°ch tr√™n ƒë·∫•t c·∫±n
        isDry: false,                // Tr·∫°ng th√°i kh√¥ h·∫°n
        fenceData: null,            // D·ªØ li·ªáu h√†ng r√†o
        fertilizerGrowthUsageCount: 0, // S·ªë l·∫ßn d√πng Ph√¢n B√≥n TƒÉng Tr∆∞·ªüng
        // --- TH√äM M·ªöI ---
        fertilizerProtectUsageCount: 0, // S·ªë l·∫ßn d√πng Ph√¢n B√≥n B·∫£o V·ªá
        hasFertilizerProtectBuff: false // C·ªù b√°o buff b·∫£o v·ªá s√¢u b·ªánh ƒëang ho·∫°t ƒë·ªông
        // --- K·∫æT TH√öC TH√äM M·ªöI ---
    };

    // ƒê·∫£m b·∫£o m·∫£ng c√≥ ƒë·ªß ch·ªó cho c√°c √¥ ƒë√£ m·ªü kh√≥a
    while (gameState.plots.length < gameState.maxUnlockedPlots) {
        const newId = gameState.plots.length;
        gameState.plots.push({ id: newId, ...JSON.parse(JSON.stringify(defaultPlotState)) });
    }

    // X√°c th·ª±c d·ªØ li·ªáu c√°c √¥ hi·ªán c√≥ (quan tr·ªçng khi t·∫£i t·ª´ save c≈© ho·∫∑c l·ªói)
    for(let i = 0; i < gameState.plots.length; i++) {
         const savedPlotData = gameState.plots[i] || {}; // L·∫•y d·ªØ li·ªáu l∆∞u, ho·∫∑c object r·ªóng n·∫øu ko c√≥
         gameState.plots[i] = {
            ...JSON.parse(JSON.stringify(defaultPlotState)), // B·∫Øt ƒë·∫ßu v·ªõi m·∫∑c ƒë·ªãnh m·ªõi nh·∫•t
            ...savedPlotData,                                 // Ghi ƒë√® b·∫±ng d·ªØ li·ªáu ƒë√£ t·∫£i
            id: i // Lu√¥n ƒë·∫£m b·∫£o ID ƒë√∫ng
         };
         // Gi·ªõi h·∫°n c√°c gi√° tr·ªã s·ªë trong kho·∫£ng h·ª£p l·ªá
         const plot = gameState.plots[i];
         plot.health = Math.max(0, Math.min(INITIAL_PLANT_HEALTH, plot.health));
         plot.fertility = Math.max(0, Math.min(BASE_FERTILITY, plot.fertility));
         plot.pestDeathClickCount = Math.max(0, plot.pestDeathClickCount || 0);
         plot.barrenHarvestPenaltyFactor = Math.max(1.0, plot.barrenHarvestPenaltyFactor || 1.0); // ƒê·∫£m b·∫£o kh√¥ng nh·ªè h∆°n 1
         plot.isDry = !!plot.isDry; // ƒê·∫£m b·∫£o l√† boolean
         plot.fertilizerGrowthUsageCount = Math.max(0, parseInt(plot.fertilizerGrowthUsageCount || 0)); // ƒê·∫£m b·∫£o l√† s·ªë kh√¥ng √¢m

         // --- TH√äM VALIDATE M·ªöI ---
         plot.fertilizerProtectUsageCount = Math.max(0, parseInt(savedPlotData.fertilizerProtectUsageCount || 0));
         // Load buff, ƒë·∫£m b·∫£o n√≥ ch·ªâ b·∫≠t n·∫øu c√≥ c√¢y s·ªëng v√† count > 0
         plot.hasFertilizerProtectBuff = (typeof savedPlotData.hasFertilizerProtectBuff === 'boolean' && plot.seedId && plot.health > 0 && plot.fertilizerProtectUsageCount > 0) ? savedPlotData.hasFertilizerProtectBuff : false;
         // ƒê·∫£m b·∫£o count v√† buff ƒë·ªìng b·ªô (n·∫øu buff on th√¨ count > 0, n·∫øu count=0 th√¨ buff off)
         if (plot.hasFertilizerProtectBuff && plot.fertilizerProtectUsageCount <= 0) {
              plot.hasFertilizerProtectBuff = false;
         } else if (!plot.hasFertilizerProtectBuff && plot.fertilizerProtectUsageCount > 0 && (!plot.seedId || plot.health <= 0)) {
              // N·∫øu √¥ tr·ªëng/ch·∫øt nh∆∞ng count > 0 -> reset count (buff ƒë√£ t·∫Øt ·ªü tr√™n)
              plot.fertilizerProtectUsageCount = 0;
         }
         // --- K·∫æT TH√öC VALIDATE M·ªöI ---

         // <<< TH√äM: Validate fenceData >>>
         if (savedPlotData.fenceData && typeof savedPlotData.fenceData === 'object' && savedPlotData.fenceData.id === 'raobaove' && ITEM_DATA.raobaove) {
             const fenceHealth = parseInt(savedPlotData.fenceData.health);
             if (!isNaN(fenceHealth) && fenceHealth >= 0 && fenceHealth <= ITEM_DATA.raobaove.health) {
                 plot.fenceData = { id: 'raobaove', health: fenceHealth };
             } else {
                  console.warn(`initializePlotsData: Fence health kh√¥ng h·ª£p l·ªá ·ªü √¥ ${i}, lo·∫°i b·ªè fenceData.`);
                  plot.fenceData = null;
             }
         } else {
             plot.fenceData = null; // M·∫∑c ƒë·ªãnh l√† null n·∫øu kh√¥ng c√≥ ho·∫∑c kh√¥ng h·ª£p l·ªá
         }
         // <<< K·∫æT TH√öC: Validate fenceData >>>

         // Ki·ªÉm tra v√† reset tr·∫°ng th√°i c√¢y n·∫øu d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá
         if (plot.seedId && (!plot.plantTime || !ITEM_DATA[plot.seedId])) {
             console.warn(`D·ªØ li·ªáu c√¢y ·ªü √¥ ${i} kh√¥ng h·ª£p l·ªá (seed: ${plot.seedId}, time: ${plot.plantTime}). ƒêang reset √¥.`);
             const currentFertility = plot.fertility;
             const currentPenaltyFactor = plot.barrenHarvestPenaltyFactor;
             const currentIsDry = plot.isDry;
             const currentFenceData = plot.fenceData; // Gi·ªØ l·∫°i h√†ng r√†o khi reset l·ªói
             Object.assign(plot, JSON.parse(JSON.stringify(defaultPlotState))); // Reset v·ªÅ m·∫∑c ƒë·ªãnh (ƒë√£ bao g·ªìm thu·ªôc t√≠nh m·ªõi)
             plot.id = i; // Gi·ªØ l·∫°i ID
             plot.fertility = currentFertility; // Ph·ª•c h·ªìi
             plot.barrenHarvestPenaltyFactor = currentPenaltyFactor; // Ph·ª•c h·ªìi
             plot.isDry = currentIsDry; // Ph·ª•c h·ªìi tr·∫°ng th√°i kh√¥ h·∫°n
             plot.fenceData = currentFenceData; // Ph·ª•c h·ªìi h√†ng r√†o
         }
         // N·∫øu c√¢y ƒëang s·ªëng nh∆∞ng buff b·∫£o v·ªá l·∫°i b·∫≠t m√† count = 0 -> t·∫Øt buff ƒëi (double check)
         else if (plot.seedId && plot.health > 0 && plot.hasFertilizerProtectBuff && plot.fertilizerProtectUsageCount <= 0) {
             plot.hasFertilizerProtectBuff = false;
             console.warn(`Plot ${i}: Fixed inconsistent fertilizer protect buff state (buff on but count is 0).`);
         }
         // N·∫øu c√¢y ch·∫øt ho·∫∑c √¥ tr·ªëng nh∆∞ng buff v·∫´n b·∫≠t -> t·∫Øt buff v√† reset count
         else if ((!plot.seedId || plot.health <= 0) && plot.hasFertilizerProtectBuff) {
             plot.hasFertilizerProtectBuff = false;
             plot.fertilizerProtectUsageCount = 0;
             console.warn(`Plot ${i}: Reset fertilizer protect buff on empty/dead plot.`);
         }
    }
    console.log(`ƒê√£ kh·ªüi t·∫°o/x√°c th·ª±c d·ªØ li·ªáu cho ${gameState.plots.length} √¥ ƒë·∫•t (bao g·ªìm isDry, protect buff).`);
}
// --- K·∫øt th√∫c h√†m initializePlotsData ---


        /** T·∫°o ho·∫∑c c·∫≠p nh·∫≠t c√°c ph·∫ßn t·ª≠ DOM cho √¥ ƒë·∫•t trong khu v∆∞·ªùn */
        function renderGarden() {
            // --- Code kh·ªüi t·∫°o ---
            gardenElement.innerHTML = ''; // X√≥a n·ªôi dung c≈©
            const now = Date.now();
            let offlineMessages = { pestFound: false, plantDied: false };
            const tornadoAffectedPlotIds = new Set(gameState.activeTornadoes.map(t => t.plotId));

            // --- [H√ÄM TR·ª¢ GI√öP V·∫º H√ÄNG R√ÄO - ƒê·∫∑t b√™n trong] ---
            const renderFenceIfNeeded = (targetElement, currentPlotData) => {
                const existingFenceVisual = targetElement.querySelector('.fence-visual-container');
                if (existingFenceVisual) targetElement.removeChild(existingFenceVisual);
                const existingFenceHealth = targetElement.querySelector('.fence-health-bar-wrapper');
                if (existingFenceHealth) targetElement.removeChild(existingFenceHealth);

                if (currentPlotData && currentPlotData.fenceData && ITEM_DATA.raobaove) {
                    const fenceItem = ITEM_DATA.raobaove;
                    const isFenceBroken = currentPlotData.fenceData.health <= 0;

                    // Visual H√†ng R√†o
                    const fenceVisualContainer = document.createElement('div');
                    fenceVisualContainer.classList.add('fence-visual-container');
                    fenceVisualContainer.style.cssText = `position: absolute; top: 13px; left: 0; width: 100%; height: 40%; display: flex; justify-content: center; align-items: flex-start; z-index: 2; pointer-events: none; opacity: ${isFenceBroken ? 0.6 : 0.9};`;
                    const fenceImg = document.createElement('img');
                    fenceImg.src = isFenceBroken ? `${fenceItem.imageFolder}/${fenceItem.brokenImageFile}` : `${fenceItem.imageFolder}/${fenceItem.imageFile}`;
                    fenceImg.alt = isFenceBroken ? "R√†o b·∫£o v·ªá h·ªèng" : "R√†o b·∫£o v·ªá";
                    fenceImg.style.cssText = `max-width: 120%; max-height: 120%; object-fit: contain;`;
                    fenceImg.onerror = () => { if (fenceImg.src !== 'Hinhanh/Caychet.png') fenceImg.src = 'Hinhanh/Caychet.png'; };
                    fenceVisualContainer.appendChild(fenceImg);
                    targetElement.appendChild(fenceVisualContainer);

                    // Thanh m√°u H√†ng R√†o (ch·ªâ hi·ªán khi ch∆∞a h·ªèng)
                    if (!isFenceBroken) {
                        const fenceHealthWrapper = document.createElement('div');
                        fenceHealthWrapper.classList.add('bar-wrapper', 'fence-health-bar-wrapper');
                        fenceHealthWrapper.style.cssText = `position: absolute; top: 2px; width: 60%; height: 4px; left: 20%; background-color: #555; border-radius: 2px; overflow: hidden; border: 1px solid #333; z-index: 3;`;
                        const fenceHealthFill = document.createElement('div');
                        fenceHealthFill.classList.add('bar-fill');
                        const fenceHealthPercent = (currentPlotData.fenceData.health / fenceItem.health) * 100;
                        fenceHealthFill.style.width = `${fenceHealthPercent}%`;
                        fenceHealthFill.style.backgroundColor = fenceHealthPercent < 30 ? '#ff9800' : (fenceHealthPercent < 60 ? '#03A9F4' : '#2196F3');
                        fenceHealthWrapper.appendChild(fenceHealthFill);
                        targetElement.appendChild(fenceHealthWrapper);
                    }
                }
            };
            // --- [K·∫æT TH√öC H√ÄM TR·ª¢ GI√öP V·∫º H√ÄNG R√ÄO] ---

            // --- V√≤ng l·∫∑p qua c√°c √¥ ƒë·∫•t (bao g·ªìm √¥ kh√≥a ti·∫øp theo) ---
            for (let i = 0; i <= gameState.maxUnlockedPlots; i++) {
                const isUnlocked = i < gameState.maxUnlockedPlots;
                const plotData = isUnlocked ? gameState.plots[i] : null;
                const rodData = isUnlocked ? getRodData(i) : null; // L·∫•y d·ªØ li·ªáu c·ªôt thu l√¥i
                const plotElement = document.createElement('div');
                plotElement.classList.add('plot');
                plotElement.dataset.plotId = i;

                // X·ª≠ l√Ω hi·ªáu ·ª©ng l·ªëc xo√°y (n·∫øu c√≥)
                const isAffectedByTornado = tornadoAffectedPlotIds.has(i);
                plotElement.classList.toggle('tornado-affected', isAffectedByTornado);
                const existingTornadoEmoji = plotElement.querySelector('.tornado-emoji-container');
                if (existingTornadoEmoji) plotElement.removeChild(existingTornadoEmoji);
                if (isAffectedByTornado) {
                    const tornadoEmojiContainer = document.createElement('div');
                    tornadoEmojiContainer.classList.add('tornado-emoji-container'); tornadoEmojiContainer.textContent = 'üå™Ô∏è';
                    plotElement.appendChild(tornadoEmojiContainer);
                }

                // --- X·ª≠ l√Ω √î ƒê·∫•t B·ªã Kh√≥a ---
                if (!isUnlocked) {
                    plotElement.classList.add('locked');
                    const cost = calculatePlotCost(i);
                    const plotInfo = document.createElement('div'); plotInfo.classList.add('plot-info');
                    plotInfo.textContent = `üîí Kh√≥a (Mua: ${cost}üí∞)`;
                    plotElement.appendChild(plotInfo);
                }
                // --- X·ª≠ l√Ω √î ƒê·∫•t C√≥ C·ªôt Thu L√¥i ---
                else if (rodData) {
                    // ... (Code v·∫Ω c·ªôt thu l√¥i, thanh m√°u, th√¥ng tin nh∆∞ trong h√†m g·ªëc - kh√¥ng thay ƒë·ªïi) ...
                     plotElement.classList.add('has-lightning-rod');
                     plotElement.classList.toggle('broken', rodData.health <= 0);
                     const visualContainerRod = document.createElement('div'); visualContainerRod.classList.add('plant-visual-container');
                     const rodVisual = document.createElement('div'); rodVisual.classList.add('plant-visual', 'visible');
                     const rodImg = document.createElement('img'); rodImg.src = 'Hinhanh/pic_cotthuloi.png'; rodImg.alt = 'C·ªôt thu l√¥i'; rodImg.style.cssText = 'max-width: 60%; max-height: 60%; object-fit: contain;';
                     rodImg.onerror = () => { if (rodImg.src !== 'Hinhanh/Caychet.png') rodImg.src = 'Hinhanh/Caychet.png'; };
                     rodVisual.appendChild(rodImg); visualContainerRod.appendChild(rodVisual); plotElement.appendChild(visualContainerRod);
                     const barsContainerRod = document.createElement('div'); barsContainerRod.classList.add('bars-container');
                     const rodHealthWrapper = document.createElement('div'); rodHealthWrapper.classList.add('bar-wrapper', 'health-bar-wrapper'); rodHealthWrapper.style.display = 'block';
                     const rodHealthFill = document.createElement('div'); rodHealthFill.classList.add('bar-fill', 'health-bar-fill');
                     const rodHealthPercent = (rodData.health / LIGHTNING_ROD_MAX_HEALTH) * 100; rodHealthFill.style.width = `${rodHealthPercent}%`;
                     if (rodData.health <= 0) { rodHealthFill.style.backgroundColor = '#757575'; } else if (rodData.health <= LIGHTNING_ROD_MAX_HEALTH * 0.25) { rodHealthFill.classList.add('low-health'); } else if (rodData.health <= LIGHTNING_ROD_MAX_HEALTH * 0.6) { rodHealthFill.classList.add('medium-health'); }
                     rodHealthWrapper.appendChild(rodHealthFill); barsContainerRod.appendChild(rodHealthWrapper); plotElement.appendChild(barsContainerRod);
                     const plotInfoRod = document.createElement('div'); plotInfoRod.classList.add('plot-info');
                     if (rodData.health <= 0) { plotInfoRod.textContent = `‚ö° C·ªôt thu l√¥i (H·ªèng!)`; plotInfoRod.style.backgroundColor = 'rgba(100, 0, 0, 0.7)'; } else { plotInfoRod.textContent = `‚ö° C·ªôt thu l√¥i (HP: ${rodData.health}/${LIGHTNING_ROD_MAX_HEALTH})`; }
                     plotElement.appendChild(plotInfoRod);
                }
                // --- X·ª≠ l√Ω √î ƒê·∫•t B√¨nh Th∆∞·ªùng (Kh√¥ng kh√≥a, kh√¥ng rod) ---
                else if (plotData) {
                     const isBarren = plotData.fertility <= 0;
                     plotElement.classList.toggle('barren-soil', isBarren); // Class ƒë·∫•t c·∫±n
                     plotElement.classList.toggle('dry-soil-effect', plotData.isDry); // Class ƒë·∫•t kh√¥
                     plotElement.classList.toggle('infested', plotData.hasPest); // Class c√≥ s√¢u

                     // T·∫°o c·∫•u tr√∫c DOM c∆° b·∫£n (visual, icon s√¢u, thanh bar, info, gif s√©t)
                     const visualContainer = document.createElement('div'); visualContainer.classList.add('plant-visual-container');
                     const plantVisual = document.createElement('div'); plantVisual.classList.add('plant-visual'); visualContainer.appendChild(plantVisual);
                     const pestIcon = document.createElement('div'); pestIcon.classList.add('pest-icon'); pestIcon.textContent = 'üêõ'; pestIcon.style.display = plotData.hasPest ? 'block' : 'none'; visualContainer.appendChild(pestIcon);
                     plotElement.appendChild(visualContainer);
                     const barsContainer = document.createElement('div'); barsContainer.classList.add('bars-container');
                     const healthBarWrapper = document.createElement('div'); healthBarWrapper.classList.add('bar-wrapper', 'health-bar-wrapper'); healthBarWrapper.style.display = 'none';
                     const healthBarFill = document.createElement('div'); healthBarFill.classList.add('bar-fill', 'health-bar-fill'); healthBarWrapper.appendChild(healthBarFill); barsContainer.appendChild(healthBarWrapper);
                     const fertilityBarWrapper = document.createElement('div'); fertilityBarWrapper.classList.add('bar-wrapper', 'fertility-bar-wrapper');
                     const fertilityBarFill = document.createElement('div'); fertilityBarFill.classList.add('bar-fill', 'fertility-bar-fill'); fertilityBarWrapper.appendChild(fertilityBarFill); barsContainer.appendChild(fertilityBarWrapper);
                     const plotInfo = document.createElement('div'); plotInfo.classList.add('plot-info');
                     plotElement.appendChild(barsContainer); plotElement.appendChild(plotInfo);
                     const gifContainer = document.createElement('div'); gifContainer.classList.add('lightning-gif-container'); const gifImage = document.createElement('img'); gifImage.src = 'Hinhanh/hieuungsetdanh.gif'; gifImage.alt = 'Hi·ªáu ·ª©ng s√©t ƒë√°nh'; gifContainer.appendChild(gifImage); plotElement.appendChild(gifContainer);

                     // --- !!! G·ªåI H√ÄM V·∫º H√ÄNG R√ÄO (n·∫øu c√≥) !!! ---
                     renderFenceIfNeeded(plotElement, plotData);
                     // --- !!! K·∫æT TH√öC G·ªåI H√ÄM V·∫º H√ÄNG R√ÄO !!! ---

                     // C·∫≠p nh·∫≠t class low-fertility (n·∫øu kh√¥ng c·∫±n)
                     const isLowFertility = plotData.fertility < LOW_FERTILITY_THRESHOLD;
                     plotElement.classList.toggle('low-fertility', isLowFertility && !isBarren);

                     // L·∫•y th√¥ng tin c√¢y v√† h·∫°t gi·ªëng
                     const stageInfo = getPlantStageInfo(plotData, now);
                     const seedInfo = plotData.seedId ? ITEM_DATA[plotData.seedId] : null;

                     // C·∫≠p nh·∫≠t THANH PH√å NHI√äU
                     const fertilityPercent = Math.max(0, plotData.fertility);
                     fertilityBarFill.style.width = `${fertilityPercent}%`;
                     fertilityBarFill.className = 'bar-fill fertility-bar-fill'; // Reset class
                     if (isBarren) fertilityBarFill.classList.add('barren'); else if (isLowFertility) fertilityBarFill.classList.add('low-fertility'); else if (fertilityPercent < 60) fertilityBarFill.classList.add('medium-fertility');

                     // --- X·ª≠ l√Ω khi C√ì C√ÇY tr·ªìng tr√™n √¥ ---
                     if (plotData.seedId && plotData.plantTime && seedInfo) {
                         plotElement.classList.add('planted');
                         healthBarWrapper.style.display = 'block'; // Hi·ªán thanh m√°u

                         if (stageInfo && !stageInfo.isError) {
                             // C·∫≠p nh·∫≠t h√¨nh ·∫£nh c√¢y
                             let img = plantVisual.querySelector('img'); if (!img) { img = document.createElement('img'); plantVisual.appendChild(img); }
                             const imgSrc = stageInfo.visualSrc || 'Hinhanh/Caychet.png'; if (img.src !== imgSrc) img.src = imgSrc; img.alt = seedInfo.name;
                             img.onerror = () => { if (img.src !== 'Hinhanh/Caychet.png') img.src = 'Hinhanh/Caychet.png'; };
                             plantVisual.classList.add('visible');
                             // C·∫≠p nh·∫≠t class ch·∫øt
                             plantVisual.classList.toggle('stage-dead', stageInfo.isDead);
                             plantVisual.classList.toggle('pest-death', stageInfo.isDead && (plotData.causeOfDeath === 'pest' || plotData.causeOfDeath === 'lightning' || plotData.causeOfDeath === 'tornado'));

                             // C·∫≠p nh·∫≠t THANH M√ÅU C√ÇY
                             const healthPercent = Math.max(0, plotData.health);
                             healthBarFill.style.width = `${healthPercent}%`;
                             healthBarFill.className = 'bar-fill health-bar-fill'; // Reset
                             if (healthPercent < 30) healthBarFill.classList.add('low-health'); else if (healthPercent < 70) healthBarFill.classList.add('medium-health');

                             // C·∫≠p nh·∫≠t th√¥ng tin text (plotInfo) bao g·ªìm H√†ng R√†o
                             // Chu·∫©n b·ªã c√°c ph·∫ßn th√¥ng tin
                             const fertilityText = isBarren ? ' (ƒê·∫•t C·∫∞N!)' : ` (ƒê·∫•t: ${Math.round(plotData.fertility)}%)`;
                             const dryText = plotData.isDry ? ' (Kh√¥!)' : '';
                             const pestText = plotData.hasPest ? ' (C√≥ s√¢u!)' : ''; // C√≥ s√¢u kh√¥ng?
                             const fenceText = plotData.fenceData ? (plotData.fenceData.health > 0 ? ` | üöß(${Math.round(plotData.fenceData.health)}%)` : ' | üöß(H·ªèng!)') : '';
                             let barrenWarning = ''; if (isBarren && plotData.barrenHarvestPenaltyFactor > 1.0) barrenWarning = ` (M·ªçc CH·∫¨M x${plotData.barrenHarvestPenaltyFactor.toFixed(2)}!)`; else if (isBarren) barrenWarning = ' (ƒê·∫•t C·∫∞N!)';

                             // X√≥a class c≈© c·ªßa plotInfo tr∆∞·ªõc khi th√™m m·ªõi
                             plotInfo.classList.remove('needs-cleanup-fee', 'free-cleanup-progress', 'broken-fence-info');
                             let infoText = ''; // Reset infoText

                             // ∆Øu ti√™n hi·ªÉn th·ªã th√¥ng b√°o R√ÄO H·ªéNG
                             if (plotData.fenceData && plotData.fenceData.health <= 0) {
                                 const removeCost = ITEM_DATA.raobaove?.removeCost || 5;
                                 infoText = `üöß R√†o H·ªèng! G·ª° b·ªè (${removeCost}üí∞)`;
                                 plotInfo.classList.add('broken-fence-info');
                             }
                             // --- Logic hi·ªÉn th·ªã tr·∫°ng th√°i c√¢y/ƒë·∫•t (n·∫øu r√†o kh√¥ng h·ªèng) ---
                             else {
                                 if (plotData.hasPest) { // <<<< ∆ØU TI√äN HI·ªÇN TH·ªä S√ÇU
                                     infoText = `üêõ S√ÇU!${pestText} (${seedInfo.name}) - HP: ${Math.round(plotData.health)}%${fertilityText}${dryText}${fenceText}`;
                                 } else if (stageInfo.isMature && plotData.health > 0) { // Tr∆∞·ªüng th√†nh V√Ä KH√îNG c√≥ s√¢u
                                     infoText = `‚úÖ Thu ho·∫°ch (${seedInfo.name})${fertilityText}${dryText}${fenceText}`;
                                 } else if (plotData.health <= 0) { // C√¢y ch·∫øt (v√† kh√¥ng c√≥ s√¢u)
                                     let deathReasonText = '';
                                     switch (plotData.causeOfDeath) {
                                         case 'pest': deathReasonText = 'Do S√¢u'; break; // Tr∆∞·ªùng h·ª£p n√†y kh√¥ng n√™n x·∫£y ra ·ªü nh√°nh n√†y, nh∆∞ng ƒë·ªÉ ph√≤ng ng·ª´a
                                         case 'dryness': deathReasonText = 'Do Kh√¥ H·∫°n'; break;
                                         case 'lightning': deathReasonText = 'Do S√©t ƒê√°nh'; break;
                                         case 'tornado': deathReasonText = 'Do Gi√≥ L·ªëc'; break;
                                         default: deathReasonText = 'T·ª± nhi√™n';
                                     }
                                     // X·ª≠ l√Ω hi·ªÉn th·ªã cho d·ªçn s√¢u ch·∫øt (n·∫øu logic tr∆∞·ªõc b·ªã s√≥t)
                                     if (plotData.causeOfDeath === 'pest') {
                                         const hasEnoughMoney = gameState.currency >= DEAD_PEST_CLEANUP_COST;
                                         if (!hasEnoughMoney && plotData.pestDeathClickCount > 0) {
                                             const clicksRemaining = DEAD_PEST_FREE_CLEANUP_CLICKS - plotData.pestDeathClickCount;
                                             infoText = `üíÄ Ch·∫øt (${deathReasonText})! Click ${clicksRemaining} l·∫ßn...${dryText}${fenceText}`;
                                             plotInfo.classList.add('free-cleanup-progress');
                                         } else {
                                             infoText = `üíÄ Ch·∫øt (${deathReasonText})! - D·ªçn (${DEAD_PEST_CLEANUP_COST}üí∞)${fertilityText}${dryText}${fenceText}`;
                                             plotInfo.classList.add('needs-cleanup-fee');
                                         }
                                     } else { // Ch·∫øt do nguy√™n nh√¢n kh√°c
                                         infoText = `üíÄ Ch·∫øt (${deathReasonText}) - Click d·ªçn${fertilityText}${dryText}${fenceText}`;
                                     }
                                     if (tickCounter <= 1) offlineMessages.plantDied = true;
                                 } else { // C√¢y ƒëang l·ªõn (kh√¥ng s√¢u)
                                     const effectiveGrowthTimeMs = stageInfo.effectiveGrowthTimeSec * 1000;
                                     const timeRemaining = Math.max(0, effectiveGrowthTimeMs - (now - plotData.plantTime));
                                     infoText = `${seedInfo.name} (${Math.round(stageInfo.growthProgress * 100)}%) - ${formatTime(timeRemaining, true)}${fertilityText}${barrenWarning}${dryText}${fenceText}`;
                                 }
                             }
                             plotInfo.textContent = infoText; // G√°n n·ªôi dung text cu·ªëi c√πng
                         } else { // L·ªói c√¢y tr·ªìng
                             // ... (x·ª≠ l√Ω l·ªói nh∆∞ c≈©, nh∆∞ng th√™m fenceText v√†o infoText) ...
                             let img = plantVisual.querySelector('img'); if (!img) { img = document.createElement('img'); plantVisual.appendChild(img); }
                             img.src = 'Hinhanh/General/ErrorPlant.png'; img.alt = 'L·ªói';
                             plantVisual.classList.add('visible', 'stage-dead');
                             const fertilityTextError = isBarren ? ' (ƒê·∫•t C·∫∞N!)' : ` (ƒê·∫•t: ${Math.round(plotData.fertility)}%)`;
                             const dryTextError = plotData.isDry ? ' (Kh√¥!)' : '';
                             const fenceTextError = plotData.fenceData ? (plotData.fenceData.health > 0 ? ` | üöß(${Math.round(plotData.fenceData.health)}%)` : ' | üöß(H·ªèng!)') : ''; // Th√™m fenceText
                             plotInfo.textContent = `L·ªói c√¢y tr·ªìng${fertilityTextError}${dryTextError}${fenceTextError}`;
                             healthBarWrapper.style.display = 'block';
                             const healthPercent = Math.max(0, plotData.health); healthBarFill.style.width = `${healthPercent}%`; healthBarFill.className = 'bar-fill health-bar-fill';
                             if (healthPercent < 30) healthBarFill.classList.add('low-health'); else if (healthPercent < 70) healthBarFill.classList.add('medium-health');
                             // Kh√¥ng c·∫ßn toggle infested v√¨ kh√¥ng c√≥ c√¢y h·ª£p l·ªá
                             pestIcon.style.display = 'none';
                             if (plotData.fenceData && plotData.fenceData.health <= 0) { plotInfo.classList.add('broken-fence-info'); }
                         }
                     }
                     // --- X·ª≠ l√Ω khi √î TR·ªêNG (Kh√¥ng c√≥ c√¢y v√† kh√¥ng c√≥ Rod) ---
                     else {
                         // G·ªçi h√†m v·∫Ω h√†ng r√†o ƒë√£ ƒë∆∞·ª£c th·ª±c hi·ªán ·ªü tr√™n
                         const fertilityTextEmpty = isBarren ? ' (ƒê·∫•t C·∫∞N!)' : ` (ƒê·ªô ph√¨: ${Math.round(plotData.fertility)}%)`;
                         let barrenPenaltyTextEmpty = ''; if (isBarren && plotData.barrenHarvestPenaltyFactor > 1.0) { barrenPenaltyTextEmpty = `\n(Tr·ªìng c√¢y s·∫Ω m·ªçc ch·∫≠m x${plotData.barrenHarvestPenaltyFactor.toFixed(2)})`; }
                         const dryTextEmpty = plotData.isDry ? ' (Kh√¥!)' : '';
                         const fenceTextEmpty = plotData.fenceData ? (plotData.fenceData.health > 0 ? ` | üöß(${Math.round(plotData.fenceData.health)}%)` : ' | üöß(H·ªèng!)') : '';

                         // X√≥a class c≈© v√† x√°c ƒë·ªãnh n·ªôi dung text d·ª±a tr√™n vi·ªác c√≥ r√†o h·ªèng hay kh√¥ng
                         plotInfo.classList.remove('needs-cleanup-fee', 'free-cleanup-progress', 'broken-fence-info');
                         if (plotData.fenceData && plotData.fenceData.health <= 0) {
                             const removeCost = ITEM_DATA.raobaove?.removeCost || 5;
                             plotInfo.textContent = `üöß R√†o H·ªèng! G·ª° b·ªè (${removeCost}üí∞)`;
                             plotInfo.classList.add('broken-fence-info');
                         } else {
                             plotInfo.textContent = `ƒê·∫•t tr·ªëng${fertilityTextEmpty}${dryTextEmpty}${barrenPenaltyTextEmpty}${fenceTextEmpty}`;
                         }

                         // Reset visual c√¢y v√† tr·∫°ng th√°i
                         plantVisual.innerHTML = ''; plantVisual.classList.remove('visible', 'stage-dead', 'pest-death');
                         plotElement.classList.remove('planted', 'infested'); // Ch·ªâ x√≥a `planted`, `infested`
                         if (!plotData.isDry) plotElement.classList.remove('dry-soil-effect');
                         pestIcon.style.display = 'none';
                     }
                     // --- K·∫øt th√∫c X·ª≠ l√Ω √î TR·ªêNG ---

                } else if (!isUnlocked) { /* √î kh√≥a ƒë√£ x·ª≠ l√Ω */ }
                else { /* L·ªói render */ console.error(`L·ªói render: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho √¥ ƒë√£ m·ªü kh√≥a ${i}`); plotElement.textContent = `L·ªói √¥ ${i}`; plotElement.style.backgroundColor = 'red'; plotElement.style.color = 'white'; }

                 // Th√™m √¥ v√†o DOM
                 if (isUnlocked || i === gameState.maxUnlockedPlots) { gardenElement.appendChild(plotElement); }

            } // --- K·∫øt th√∫c v√≤ng l·∫∑p for c√°c √¥ ƒë·∫•t ---

            // Hi·ªÉn th·ªã th√¥ng b√°o offline (n·∫øu l√† tick ƒë·∫ßu ti√™n)
            if (tickCounter <= 1) {
                let pestRemainedOffline = false;
                for (let i = 0; i < gameState.maxUnlockedPlots; i++) { if(gameState.plots[i]?.hasPest) { pestRemainedOffline = true; break; }}
                if (pestRemainedOffline) { setTimeout(() => showMessage("·ªêi! C√≥ v·∫ª s√¢u b·ªánh v·∫´n c√≤n tr√™n c√¢y khi b·∫°n v·∫Øng m·∫∑t!", "warning"), 500); }
                else if (offlineMessages.pestFound) { setTimeout(() => showMessage("C√≥ v·∫ª s√¢u b·ªánh ƒë√£ gh√© thƒÉm khi b·∫°n v·∫Øng m·∫∑t!", "warning"), 500); }
                if (offlineMessages.plantDied) { setTimeout(() => showMessage("M·ªôt s·ªë c√¢y tr·ªìng ƒë√£ kh√¥ng qua kh·ªèi khi b·∫°n v·∫Øng m·∫∑t.", "error"), 600); }
            }
        } // --- K·∫øt th√∫c h√†m renderGarden ---

function placeLightningRod(plotId) {
    if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || gameState.plots[plotId].seedId || isPlotWithRod(plotId)) {
        showMessage("Kh√¥ng th·ªÉ ƒë·∫∑t C·ªôt thu l√¥i ·ªü √¥ n√†y (ƒë√£ c√≥ c√¢y/rod ho·∫∑c kh√¥ng h·ª£p l·ªá).", "error");
        return;
    }
    const rodCount = gameState.inventory[LIGHTNING_ROD_ITEM_ID] || 0;
    if (rodCount <= 0) {
        showMessage(`H·∫øt C·ªôt thu l√¥i trong kho! H√£y mua th√™m.`, "error");
        return;
    }

    // --- Th·ª±c hi·ªán ƒë·∫∑t ---
    gameState.inventory[LIGHTNING_ROD_ITEM_ID]--; // Tr·ª´ kh·ªèi kho
    gameState.lightningRods.push({
        plotId: plotId,
        health: LIGHTNING_ROD_MAX_HEALTH,
        repairCost: LIGHTNING_ROD_INITIAL_REPAIR_COST
    });

    // C·∫≠p nh·∫≠t UI v√† L∆∞u game
    renderUI();
    renderGarden(); // V·∫Ω l·∫°i v∆∞·ªùn ƒë·ªÉ hi·ªán c·ªôt thu l√¥i
    if (inventoryModal.style.display === 'block') renderInventory(); // C·∫≠p nh·∫≠t kho n·∫øu ƒëang m·ªü
    saveGame();

    showMessage(`ƒê√£ ƒë·∫∑t C·ªôt thu l√¥i t·∫°i √¥ ${plotId + 1}!`, "success");
    logAction('place_rod', plotId, `ƒê·∫∑t C·ªôt thu l√¥i t·∫°i √¥ ${plotId + 1}.`, '‚ö°', LIGHTNING_ROD_ITEM_ID);
}

function handleLightningRodClick(plotId) {
    const rodData = getRodData(plotId);
    if (!rodData) {
        console.warn(`handleLightningRodClick ƒë∆∞·ª£c g·ªçi cho √¥ ${plotId} kh√¥ng c√≥ rod.`);
        return;
    }
    currentActionPlotId = plotId; // L∆∞u plotId ƒëang thao t√°c
    updateLightningRodActionModal(plotId); // C·∫≠p nh·∫≠t n·ªôi dung modal
    openModal('lightning-rod-action-modal'); // M·ªü modal h√†nh ƒë·ªông rod
}
function updateLightningRodActionModal(plotId) {
    const rodData = getRodData(plotId);
    if (!rodData || !lightningRodActionModal) return;

    const rodTitle = lightningRodActionModal.querySelector('#rod-action-title');
    const rodHealthDisplay = lightningRodActionModal.querySelector('#rod-health-display');
    const repairBtn = lightningRodActionModal.querySelector('#action-repair-rod');
    const removeBtn = lightningRodActionModal.querySelector('#action-remove-rod');

    if (rodTitle) rodTitle.textContent = `‚ö° C·ªôt Thu L√¥i (√î ${plotId + 1})`;

    if (rodHealthDisplay) {
         rodHealthDisplay.textContent = `${rodData.health}/${LIGHTNING_ROD_MAX_HEALTH}`;
         rodHealthDisplay.style.color = rodData.health <= 0 ? '#c62828' : (rodData.health < LIGHTNING_ROD_MAX_HEALTH * 0.5 ? '#fb8c00' : 'inherit');
    }


    if (repairBtn) {
        if (rodData.health <= 0) {
            const cost = rodData.repairCost || LIGHTNING_ROD_INITIAL_REPAIR_COST;
            repairBtn.textContent = `üîß S·ª≠a Ch·ªØa (${cost}üí∞)`;
            repairBtn.disabled = gameState.currency < cost;
            repairBtn.title = repairBtn.disabled ? `Kh√¥ng ƒë·ªß ti·ªÅn s·ª≠a (C·∫ßn ${cost}üí∞)` : `S·ª≠a ch·ªØa c·ªôt thu l√¥i (T·ªën ${cost}üí∞)`;
            repairBtn.style.display = 'block'; // Hi·ªán n√∫t s·ª≠a
        } else {
            repairBtn.style.display = 'none'; // ·∫®n n√∫t s·ª≠a n·∫øu rod ch∆∞a h·ªèng
        }
    }

    if (removeBtn) {
        removeBtn.disabled = false; // N√∫t g·ª° b·ªè lu√¥n ƒë∆∞·ª£c b·∫≠t
        removeBtn.title = "G·ª° b·ªè c·ªôt thu l√¥i kh·ªèi √¥ ƒë·∫•t n√†y";
    }
}

function handleRodActionClick(event) {
    const actionButton = event.target.closest('.action-button');
    if (!actionButton || actionButton.disabled || currentActionPlotId === null) return;

    const plotId = currentActionPlotId; // L·∫•y plotId ƒë√£ l∆∞u
    const actionId = actionButton.id;

    switch(actionId) {
        case 'action-repair-rod':
            openConfirmRepairPopup(plotId); // M·ªü popup x√°c nh·∫≠n s·ª≠a
            break;
        case 'action-remove-rod':
            openConfirmRemovePopup(plotId); // M·ªü popup x√°c nh·∫≠n g·ª°
            break;
        default:
             console.warn("H√†nh ƒë·ªông c·ªôt thu l√¥i kh√¥ng x√°c ƒë·ªãnh:", actionId);
    }
    // Kh√¥ng ƒë√≥ng modal ch√≠nh ·ªü ƒë√¢y, ƒë√≥ng sau khi x√°c nh·∫≠n
}

function openConfirmRepairPopup(plotId) {
    const rodData = getRodData(plotId);
    if (!rodData || rodData.health > 0) return;
    const cost = rodData.repairCost || LIGHTNING_ROD_INITIAL_REPAIR_COST;
    const msgElement = confirmRepairRodPopup.querySelector('#confirm-repair-message');
    const confirmBtn = confirmRepairRodPopup.querySelector('#confirm-repair-rod-btn');

    if (msgElement) msgElement.innerHTML = `B·∫°n c√≥ ch·∫Øc mu·ªën s·ª≠a c·ªôt thu l√¥i ·ªü √¥ <strong>${plotId + 1}</strong> v·ªõi gi√° <strong>${cost}üí∞</strong>?`;
    if (confirmBtn) {
        confirmBtn.dataset.plotId = plotId;
        confirmBtn.disabled = gameState.currency < cost;
    }
    confirmRepairRodPopup.style.display = 'flex';
     setTimeout(() => confirmBtn?.focus(), 50);
}
function closeConfirmRepairPopup() { confirmRepairRodPopup.style.display = 'none'; }
function handleConfirmRepair() {
    const confirmBtn = confirmRepairRodPopup.querySelector('#confirm-repair-rod-btn');
    const plotId = parseInt(confirmBtn?.dataset.plotId);
    if (!isNaN(plotId)) {
        repairRod(plotId);
    }
    closeConfirmRepairPopup();
    closeModal('lightning-rod-action-modal'); // ƒê√≥ng c·∫£ modal h√†nh ƒë·ªông g·ªëc
     currentActionPlotId = null;
}

function openConfirmRemovePopup(plotId) {
    const rodData = getRodData(plotId);
    if (!rodData) return;
    const msgElement = confirmRemoveRodPopup.querySelector('#confirm-remove-message');
    const confirmBtn = confirmRemoveRodPopup.querySelector('#confirm-remove-rod-btn');

    if (msgElement) msgElement.innerHTML = `B·∫°n c√≥ ch·∫Øc mu·ªën g·ª° b·ªè c·ªôt thu l√¥i ·ªü √¥ <strong>${plotId + 1}</strong> kh√¥ng? (Kh√¥ng th·ªÉ ho√†n t√°c)`;
    if (confirmBtn) confirmBtn.dataset.plotId = plotId;
    confirmRemoveRodPopup.style.display = 'flex';
    setTimeout(() => confirmBtn?.focus(), 50);
}
function closeConfirmRemovePopup() { confirmRemoveRodPopup.style.display = 'none'; }
function handleConfirmRemove() {
    const confirmBtn = confirmRemoveRodPopup.querySelector('#confirm-remove-rod-btn');
    const plotId = parseInt(confirmBtn?.dataset.plotId);
    if (!isNaN(plotId)) {
        removeRod(plotId);
    }
    closeConfirmRemovePopup();
    closeModal('lightning-rod-action-modal'); // ƒê√≥ng c·∫£ modal h√†nh ƒë·ªông g·ªëc
    currentActionPlotId = null;
}

/** [M·ªöI] H√†nh ƒë·ªông: S·ª≠a ch·ªØa c·ªôt thu l√¥i */
function repairRod(plotId) {
    const rodIndex = gameState.lightningRods.findIndex(r => r.plotId === plotId);
    if (rodIndex === -1) return;
    const rod = gameState.lightningRods[rodIndex];
    if (rod.health > 0) { showMessage("C·ªôt thu l√¥i n√†y ch∆∞a h·ªèng.", "info"); return; }

    const cost = rod.repairCost || LIGHTNING_ROD_INITIAL_REPAIR_COST;
    if (gameState.currency < cost) { showMessage(`Kh√¥ng ƒë·ªß ti·ªÅn s·ª≠a! C·∫ßn ${cost}üí∞.`, "error"); return; }

    // --- Th·ª±c hi·ªán s·ª≠a ---
    gameState.currency -= cost;
    rod.health = LIGHTNING_ROD_MAX_HEALTH; // Ph·ª•c h·ªìi m√°u
    rod.repairCost = Math.floor(cost * LIGHTNING_ROD_REPAIR_COST_MULTIPLIER); // T√≠nh ph√≠ s·ª≠a l·∫ßn sau

    // C·∫≠p nh·∫≠t UI, L∆∞u game
    renderUI();
    renderGarden();
    saveGame();

    showMessage(`ƒê√£ s·ª≠a C·ªôt thu l√¥i ·ªü √¥ ${plotId + 1} v·ªõi ${cost}üí∞. Ph√≠ s·ª≠a l·∫ßn t·ªõi: ${rod.repairCost}üí∞.`, "success");
    logAction('repair_rod', plotId, `S·ª≠a C·ªôt thu l√¥i (-${cost}üí∞). HP: ${rod.health}/${LIGHTNING_ROD_MAX_HEALTH}. Ph√≠ sau: ${rod.repairCost}üí∞.`, 'üîß', LIGHTNING_ROD_ITEM_ID);
}
function removeRod(plotId) {
    const rodIndex = gameState.lightningRods.findIndex(r => r.plotId === plotId);
    if (rodIndex === -1) { showMessage("Kh√¥ng t√¨m th·∫•y c·ªôt thu l√¥i ƒë·ªÉ g·ª°.", "warning"); return; }

    // --- Th·ª±c hi·ªán g·ª° ---
    gameState.lightningRods.splice(rodIndex, 1); // X√≥a kh·ªèi m·∫£ng

    // --- [QUY·∫æT ƒê·ªäNH] Kh√¥ng tr·∫£ l·∫°i v·∫≠t ph·∫©m v√†o kho ---
    // gameState.inventory[LIGHTNING_ROD_ITEM_ID] = (gameState.inventory[LIGHTNING_ROD_ITEM_ID] || 0) + 1;

    // C·∫≠p nh·∫≠t UI, L∆∞u game
    renderGarden(); // V·∫Ω l·∫°i v∆∞·ªùn
    if (inventoryModal.style.display === 'block') renderInventory(); // C·∫≠p nh·∫≠t kho n·∫øu c·∫ßn
    saveGame();

    showMessage(`ƒê√£ g·ª° b·ªè C·ªôt thu l√¥i kh·ªèi √¥ ${plotId + 1}.`, "info");
    logAction('remove_rod', plotId, `G·ª° b·ªè C·ªôt thu l√¥i kh·ªèi √¥ ${plotId + 1}.`, 'üóëÔ∏è', LIGHTNING_ROD_ITEM_ID);
}



        /** B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p game ch√≠nh. */
        function startGameLoop() {
            if (gameLoopInterval) {
                console.warn("V√≤ng l·∫∑p game ƒë√£ ch·∫°y.");
                return;
            }
            console.log(`ƒêang b·∫Øt ƒë·∫ßu v√≤ng l·∫∑p game v·ªõi kho·∫£ng th·ªùi gian: ${TICK_INTERVAL}ms`);
             gameTick(); // Ch·∫°y tick ƒë·∫ßu ti√™n ngay l·∫≠p t·ª©c
             gameLoopInterval = setInterval(gameTick, TICK_INTERVAL); // Thi·∫øt l·∫≠p interval
			 startHatNgocTroiTimer();
        }

        /** D·ª´ng v√≤ng l·∫∑p game ch√≠nh. */
        function stopGameLoop() {
             if (gameLoopInterval) {
        clearInterval(gameLoopInterval); // X√≥a interval
        gameLoopInterval = null; // ƒê·∫∑t l·∫°i bi·∫øn ID
        clearTimeout(hatNgocTroiTimeout); // <<< D·ª™NG TIMER KHI GAME LOOP D·ª™NG
        hatNgocTroiTimeout = null;        // <<< RESET BI·∫æN TIMER
        console.log("V√≤ng l·∫∑p game v√† timer H·∫°t Ng·ªçc Tr·ªùi ƒë√£ d·ª´ng.");
    }
        }

        /** Nh·ªãp ƒë·∫≠p ch√≠nh c·ªßa game, c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¢y tr·ªìng, UI, v√† s·ª± ki·ªán s√¢u b·ªánh. */
         async function gameTick() {
            const now = Date.now();
            gameState.lastUpdateTimestamp = now; // C·∫≠p nh·∫≠t timestamp ·ªü ƒë·∫ßu tick
            tickCounter++;

            let plotStateChangedDuringTick = false; // C·ªù theo d√µi thay ƒë·ªïi trong tick n√†y

            // C·∫≠p nh·∫≠t th·ªùi gian hi·ªÉn th·ªã (gi·ªù:ph√∫t)
            const currentTime = new Date();
            const hours = String(currentTime.getHours()).padStart(2, '0');
            const minutes = String(currentTime.getMinutes()).padStart(2, '0');
            const timeString = `${hours}:${minutes}`;
            if (gameTimeElement.textContent !== timeString) {
                gameTimeElement.textContent = timeString;
            }

            // --- X·ª≠ L√Ω Thay ƒê·ªïi Th·ªùi Ti·∫øt ---
            let weatherJustChanged = false;
            let previousWeatherId = gameState.currentWeather?.id;

            if (now >= gameState.nextWeatherChangeTimestamp) {
                const oldWeatherIdForEventCheck = previousWeatherId;
                gameState.currentWeather = chooseRandomWeather(); // Ch·ªçn th·ªùi ti·∫øt m·ªõi
                gameState.currentWeatherStartTime = now; // Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu chu k·ª≥ m·ªõi
                gameState.nextWeatherChangeTimestamp = now + WEATHER_CHANGE_INTERVAL_MS; // L√™n l·ªãch l·∫ßn ƒë·ªïi k·∫ø ti·∫øp
                const weatherDisplayName = gameState.currentWeather.name || gameState.currentWeather.icon;
                console.log(`Th·ªùi ti·∫øt ƒë√£ thay ƒë·ªïi th√†nh: ${weatherDisplayName} (ID: ${gameState.currentWeather.id})`);
                showMessage(`Th·ªùi ti·∫øt ƒë√£ ƒë·ªïi th√†nh ${weatherDisplayName}`, 'info');
                weatherJustChanged = true;
                weatherUpdateNeeded = true; // C·∫ßn v·∫Ω l·∫°i UI th·ªùi ti·∫øt

                // D·ª´ng √¢m thanh th·ªùi ti·∫øt C≈® n·∫øu hi·ªáu ·ª©ng ƒëang b·∫≠t
                if (areEffectSoundsEnabled) {
                    if (oldWeatherIdForEventCheck === 'rainy' && gameState.currentWeather.id !== 'rainy' && rainSound && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
                    if (oldWeatherIdForEventCheck === 'rainy_sunny' && gameState.currentWeather.id !== 'rainy_sunny' && rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
                }

                // X·ª≠ l√Ω hi·ªáu ·ª©ng t·ª©c th√¨: H·∫øt kh√¥ khi m∆∞a
                const rainyWeatherIdsForDryness = ['rainy', 'thunderstorm', 'rainy_sunny'];
                if (rainyWeatherIdsForDryness.includes(gameState.currentWeather.id)) {
                    let clearedDryPlots = 0;
                    for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                        const plot = gameState.plots[i];
                        if (plot && plot.isDry) {
                            plot.isDry = false; clearedDryPlots++; plotStateChangedDuringTick = true;
                        }
                    }
                    if (clearedDryPlots > 0) { setTimeout(() => { showMessage(`üåßÔ∏è M∆∞a ƒë√£ l√†m ${clearedDryPlots} √¥ ƒë·∫•t h·∫øt kh√¥!`, "success"); }, 200); }
                }

                // L√™n l·ªãch/h·ªßy l·ªãch s·ª± ki·ªán Tornado khi th·ªùi ti·∫øt ƒë·ªïi sang/kh·ªèi Windy
                if (gameState.currentWeather.id === 'windy') {
                    if (gameState.nextTornadoEventTimestamp <= 0 || gameState.nextTornadoEventTimestamp <= now) {
                        const nextInterval = TORNADO_EVENT_MIN_INTERVAL_MS_WINDY + Math.random() * (TORNADO_EVENT_MAX_INTERVAL_MS_WINDY - TORNADO_EVENT_MIN_INTERVAL_MS_WINDY);
                        gameState.nextTornadoEventTimestamp = now + nextInterval;
                        console.log(`(Weather Change to Windy) S·ª± ki·ªán l·ªëc ti·∫øp theo ƒë∆∞·ª£c l√™n l·ªãch sau ${formatTime(nextInterval)}`);
                    }
                } else { // N·∫øu kh√¥ng ph·∫£i Windy n·ªØa
                    gameState.nextTornadoEventTimestamp = 0; // H·ªßy l·ªãch
                    if (gameState.activeTornadoes.length > 0) {
                        console.log("Th·ªùi ti·∫øt kh√¥ng c√≤n l√† Windy, x√≥a c√°c hi·ªáu ·ª©ng l·ªëc ƒëang ho·∫°t ƒë·ªông.");
                        gameState.activeTornadoes = []; // X√≥a l·ªëc ƒëang ch·∫°y
                        plotStateChangedDuringTick = true; // C·∫ßn render l·∫°i v∆∞·ªùn
                    }
                }
                saveGame(); // L∆∞u game sau khi ƒë·ªïi th·ªùi ti·∫øt v√† x·ª≠ l√Ω hi·ªáu ·ª©ng
            }

            // Lu√¥n C·∫≠p Nh·∫≠t UI Th·ªùi Ti·∫øt M·ªñI TICK (bao g·ªìm hi·ªáu ·ª©ng l√†m t·ªëi)
            renderWeatherUI();
            weatherUpdateNeeded = false; // ƒê√£ c·∫≠p nh·∫≠t

            // X·ª¨ L√ù √ÇM THANH M∆ØA & M∆ØA N·∫ÆNG THEO N√öT HI·ªÜU ·ª®NG
            if (areEffectSoundsEnabled) {
                if (rainSound) {
                    if (gameState.currentWeather.id === 'rainy' && rainSound.paused) { try { await rainSound.play(); } catch (error) { /* B·ªè qua l·ªói */ } }
                    else if (gameState.currentWeather.id !== 'rainy' && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
                }
                if (rainySunnySound) {
                    if (gameState.currentWeather.id === 'rainy_sunny' && rainySunnySound.paused) { try { await rainySunnySound.play(); } catch (error) { /* B·ªè qua l·ªói */ } }
                    else if (gameState.currentWeather.id !== 'rainy_sunny' && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
                }
            } else { // T·∫Øt √¢m thanh n·∫øu hi·ªáu ·ª©ng b·ªã t·∫Øt
                if (rainSound && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
                if (rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
            }

            // KI·ªÇM TRA V√Ä √ÅP D·ª§NG KH√î H·∫†N KHI TR·ªúI N·∫ÆNG
            let dryCheckOccurredThisTick = false;
            if (gameState.currentWeather.id === 'sunny' && now >= gameState.nextDryCheckTimestamp && !dryCheckOccurredThisTick) {
                 dryCheckOccurredThisTick = true;
                 const eligiblePlotIndices = [];
                 for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                      if (gameState.activeTornadoes.some(t => t.plotId === i)) continue; // B·ªè qua √¥ ƒëang b·ªã tornado
                      if (isPlotWithRod(i)) continue; // B·ªè qua √¥ c√≥ rod
                      const plot = gameState.plots[i];
                      if (plot && !plot.isDry) { eligiblePlotIndices.push(i); } // Ch·ªâ x√©t √¥ ch∆∞a kh√¥
                 }
                 let numPlotsToAffect = 0;
                 if (eligiblePlotIndices.length > 0) {
                     const maxAffect = Math.min(eligiblePlotIndices.length, 3); // L√†m kh√¥ t·ªëi ƒëa 3 √¥
                     numPlotsToAffect = Math.floor(Math.random() * maxAffect) + 1; // √çt nh·∫•t 1 √¥
                 }
                 let becameDryCount = 0;
                 const shuffledEligible = eligiblePlotIndices.sort(() => 0.5 - Math.random());
                 for (let k = 0; k < numPlotsToAffect; k++) {
                     const plotIndexToAffect = shuffledEligible[k];
                     const plotToAffect = gameState.plots[plotIndexToAffect];
                     if (plotToAffect && !plotToAffect.isDry) {
                         plotToAffect.isDry = true; becameDryCount++; plotStateChangedDuringTick = true;
                     }
                 }
                 if (becameDryCount > 0) { showMessage(`ü•µ N·∫Øng g·∫Øt ƒë√£ l√†m kh√¥ ${becameDryCount} √¥ ƒë·∫•t!`, "warning"); }
                 // L√™n l·ªãch ki·ªÉm tra kh√¥ h·∫°n ti·∫øp theo (30-60 gi√¢y)
                 const nextIntervalSunny = (30 + Math.random() * 30) * 1000;
                 gameState.nextDryCheckTimestamp = now + nextIntervalSunny;
            } else if (gameState.currentWeather.id !== 'sunny' && now >= gameState.nextDryCheckTimestamp) { // N·∫øu kh√¥ng n·∫Øng, c≈©ng l√™n l·ªãch l·∫°i
                 dryCheckOccurredThisTick = true;
                 const randomIntervalOther = (60 + Math.random() * 60) * 1000; // 60-120 gi√¢y
                 gameState.nextDryCheckTimestamp = now + randomIntervalOther;
            }

            // --- X·ª≠ L√Ω S√¢u B·ªánh, H·ªìi M√°u, Gi·∫£m Ph√¨ Nhi√™u, Kh√¥ H·∫°n v√† TORNADO cho t·ª´ng √î ƒê·∫•t ---
            for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                // B·ªè qua √¥ c√≥ c·ªôt thu l√¥i (rod kh√¥ng b·ªã ·∫£nh h∆∞·ªüng b·ªüi logic n√†y)
                if (isPlotWithRod(i)) continue;
                const plot = gameState.plots[i];
                if (!plot) continue; // B·ªè qua n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu √¥ ƒë·∫•t

                let plotUpdatedByOthers = false; // C·ªù ri√™ng cho c√°c thay ƒë·ªïi th√¥ng th∆∞·ªùng

                // === ∆ØU TI√äN X·ª¨ L√ù T·∫§N C√îNG TORNADO (bao g·ªìm t√°c ƒë·ªông l√™n h√†ng r√†o) ===
                const activeTornado = gameState.activeTornadoes.find(t => t.plotId === i);
                if (activeTornado) {
                    const duration = TORNADO_EFFECT_DURATION_MS_WINDY;
                    // S·ªë tick c√≤n l·∫°i (√≠t nh·∫•t 1) ƒë·ªÉ chia s√°t th∆∞∆°ng
                    const ticksRemaining = Math.max(1, Math.ceil((activeTornado.expireTimestamp - now) / TICK_INTERVAL));
                    // T·ªïng s·ªë tick d·ª± ki·∫øn trong to√†n b·ªô th·ªùi gian hi·ªáu ·ª©ng
                    const totalTicksInDuration = Math.ceil(duration / TICK_INTERVAL);
                    let damageAppliedThisTick = false; // C·ªù xem c√≥ g√¢y s√°t th∆∞∆°ng trong tick n√†y kh√¥ng
                    let fenceTookHit = false; // C·ªù xem r√†o c√≥ h·ª©ng ch·ªãu kh√¥ng

                    // 1. Ki·ªÉm tra v√† t·∫•n c√¥ng H√†ng R√†o tr∆∞·ªõc n·∫øu c√≥ v√† c√≤n m√°u
                    if (plot.fenceData && plot.fenceData.health > 0 && ITEM_DATA.raobaove) {
                        fenceTookHit = true; // ƒê√°nh d·∫•u r√†o h·ª©ng ch·ªãu
                        const fenceMaxHealth = ITEM_DATA.raobaove.health;
                        let fenceDamage = 0; // S√°t th∆∞∆°ng h√†ng r√†o trong tick n√†y

                        // T√≠nh s√°t th∆∞∆°ng l√™n h√†ng r√†o d·ª±a tr√™n lo·∫°i tornado
                        if (activeTornado.isDestruction) { // Ph√° h·ªßy ho√†n to√†n r√†o trong th·ªùi gian c√≤n l·∫°i
                            fenceDamage = ticksRemaining > 0 ? plot.fenceData.health / ticksRemaining : plot.fenceData.health;
                        } else { // G√¢y thi·ªát h·∫°i m·ªôt ph·∫ßn (% m√°u t·ªëi ƒëa)
                            const totalFenceDmg = fenceMaxHealth * TORNADO_PARTIAL_DAMAGE_FACTOR;
                            // Chia ƒë·ªÅu t·ªïng s√°t th∆∞∆°ng cho t·ªïng s·ªë tick c·ªßa hi·ªáu ·ª©ng
                            fenceDamage = totalTicksInDuration > 0 ? totalFenceDmg / totalTicksInDuration : 0;
                        }

                        const oldFenceHealth = plot.fenceData.health;
                        plot.fenceData.health = Math.max(0, plot.fenceData.health - fenceDamage); // Gi·∫£m m√°u r√†o
						
        if (plot.fenceData.health <= 0 && oldFenceHealth > 0) {
            // R√†o v·ª´a b·ªã ph√° h·ªßy b·ªüi c∆°n l·ªëc N√ÄY!
            console.warn(`(Tornado Fence Break) R√†o √¥ ${i} b·ªã ph√° h·ªßy! D·ª´ng hi·ªáu ·ª©ng l·ªëc cho √¥ n√†y.`);
            // Hi·ªÉn th·ªã th√¥ng b√°o cho ng∆∞·ªùi ch∆°i (ƒë√£ c√≥ s·∫µn)
            showMessage(`üöß R√†o b·∫£o v·ªá ·ªü √¥ ${i + 1} b·ªã gi√≥ l·ªëc ph√° h·ªèng!`, "error");
            logAction('fence_broken', i, `R√†o b·∫£o v·ªá √¥ ${i + 1} b·ªã gi√≥ l·ªëc ph√° h·ªèng.`, 'üí•üöß', 'raobaove');

            // *** H√ÄNH ƒê·ªòNG QUAN TR·ªåNG: X√≥a c∆°n l·ªëc ƒëang ho·∫°t ƒë·ªông cho √¥ n√†y ***
            const tornadoIndex = gameState.activeTornadoes.findIndex(t => t.plotId === i);
            if (tornadoIndex !== -1) {
                gameState.activeTornadoes.splice(tornadoIndex, 1); // X√≥a ph·∫ßn t·ª≠ kh·ªèi m·∫£ng
                console.log(` -> ƒê√£ lo·∫°i b·ªè activeTornado cho √¥ ${i} v√¨ r√†o b·ªã ph√° h·ªßy.`);
            }

            plotStateChangedDuringTick = true; // ƒê·∫£m b·∫£o v∆∞·ªùn ƒë∆∞·ª£c v·∫Ω l·∫°i
            continue; // *** QUAN TR·ªåNG: B·ªè qua ph·∫ßn c√≤n l·∫°i c·ªßa x·ª≠ l√Ω l·ªëc V√Ä x·ª≠ l√Ω plot th√¥ng th∆∞·ªùng cho √¥ n√†y TRONG TICK N√ÄY ***
        }
       
						
						
						
						
                        if (plot.fenceData.health !== oldFenceHealth) {
                            damageAppliedThisTick = true; // ƒê√°nh d·∫•u c√≥ s√°t th∆∞∆°ng
                            // --- LOG TH√äM ---
                            console.log(`(Tornado Tick) R√†o √¥ ${i} h·ª©ng ${fenceDamage.toFixed(1)} dmg. M√°u c√≤n: ${plot.fenceData.health.toFixed(1)}. Lo·∫°i: ${activeTornado.isDestruction ? 'Ph√° h·ªßy' : 'Thi·ªát h·∫°i n·∫∑ng'}.`);
                            // ---------------
                        }
                        // X·ª≠ l√Ω khi r√†o b·ªã ph√° h·ªßy (m√°u v·ªÅ 0 t·ª´ > 0)
                        if (plot.fenceData.health <= 0 && oldFenceHealth > 0) {
                            console.warn(`(Tornado Hits Fence) R√†o b·∫£o v·ªá ·ªü √¥ ${i} b·ªã ph√° h·ªßy!`);
                            showMessage(`üöß R√†o b·∫£o v·ªá ·ªü √¥ ${i + 1} b·ªã gi√≥ l·ªëc ph√° h·ªèng!`, "error");
                            logAction('fence_broken', i, `R√†o b·∫£o v·ªá √¥ ${i + 1} b·ªã gi√≥ l·ªëc ph√° h·ªèng.`, 'üí•üöß', 'raobaove');
                        }
                    } // K·∫øt th√∫c x·ª≠ l√Ω h√†ng r√†o

                    // 2. N·∫øu h√†ng r√†o KH√îNG h·ª©ng ch·ªãu (kh√¥ng c√≥ ho·∫∑c ƒë√£ h·ªèng), m·ªõi t·∫•n c√¥ng c√¢y/ƒë·∫•t
                    if (!fenceTookHit) {
                        // --- LOG TH√äM ---
                        console.log(`(Tornado Tick) R√†o √¥ ${i} kh√¥ng h·ª©ng ch·ªãu. T·∫•n c√¥ng c√¢y/ƒë·∫•t. Lo·∫°i: ${activeTornado.isDestruction ? 'Ph√° h·ªßy' : 'Thi·ªát h·∫°i n·∫∑ng'}.`);
                        // ---------------
                        if (activeTornado.isDestruction) { // Ph√° h·ªßy ho√†n to√†n c√¢y/ƒë·∫•t
                            // Chia ƒë·ªÅu m√°u/ph√¨ nhi√™u c√≤n l·∫°i cho s·ªë tick c√≤n l·∫°i
                            const healthDamage = ticksRemaining > 0 ? plot.health / ticksRemaining : plot.health;
                            const fertilityDamage = ticksRemaining > 0 ? plot.fertility / ticksRemaining : plot.fertility;
                            // G√¢y s√°t th∆∞∆°ng cho c√¢y n·∫øu c√≥
                            if (plot.seedId && plot.health > 0) {
                                const oldH = plot.health;
                                plot.health = Math.max(0, plot.health - healthDamage);
                                if(plot.health !== oldH) {
                                     damageAppliedThisTick = true;
                                     // --- LOG TH√äM ---
                                     console.log(` -> C√¢y √¥ ${i} ch·ªãu ${healthDamage.toFixed(1)} dmg (ph√° h·ªßy). HP c√≤n: ${plot.health.toFixed(1)}.`);
                                     // ---------------
                                }
                                // X·ª≠ l√Ω khi c√¢y ch·∫øt do b·ªã h·ªßy di·ªát
                                if(plot.health === 0 && oldH > 0) {
                                    plot.causeOfDeath = 'tornado'; plot.hasPest = false; plot.isDry = false; plot.pestDeathClickCount = 0;
                                    const plantName = ITEM_DATA[plot.seedId]?.name || 'C√¢y';
                                    console.warn(`(Tornado Destr) Plot ${i} (${plantName}) b·ªã h·ªßy di·ªát.`);
                                    logAction('plant_death', i, `${plantName} √¥ ${i+1} b·ªã h·ªßy di·ªát do gi√≥ l·ªëc.`, 'üíÄüå™Ô∏è', plot.seedId);
                                }
                            }
                            // Ho·∫∑c g√¢y s√°t th∆∞∆°ng cho ƒë·∫•t tr·ªëng n·∫øu c√≥
                            else if (!plot.seedId && plot.fertility > 0) {
                                const oldF = plot.fertility;
                                plot.fertility = Math.max(0, plot.fertility - fertilityDamage);
                                if(plot.fertility !== oldF) {
                                    damageAppliedThisTick = true;
                                     // --- LOG TH√äM ---
                                     console.log(` -> ƒê·∫•t √¥ ${i} ch·ªãu ${fertilityDamage.toFixed(1)} dmg (ph√° h·ªßy). Ph√¨ c√≤n: ${plot.fertility.toFixed(1)}.`);
                                     // ---------------
                                }
                                // X·ª≠ l√Ω khi ƒë·∫•t th√†nh c·∫±n c·ªói
                                if(plot.fertility === 0 && oldF > 0) {
                                    plot.barrenHarvestPenaltyFactor = 1.0; plot.isDry = false;
                                    console.log(`(Tornado Destr) Plot ${i} (tr·ªëng) th√†nh c·∫±n c·ªói.`);
                                    logAction('soil_barren', i, `ƒê·∫•t √¥ ${i+1} th√†nh c·∫±n do gi√≥ l·ªëc.`, 'üß±üå™Ô∏è', null);
                                }
                            }
                        } else { // G√¢y thi·ªát h·∫°i m·ªôt ph·∫ßn (% m√°u/ph√¨ nhi√™u HI·ªÜN T·∫†I) cho c√¢y/ƒë·∫•t
                            // T·ªïng s√°t th∆∞∆°ng d·ª± ki·∫øn l√† % m√°u/ph√¨ nhi√™u HI·ªÜN T·∫†I
                            const totalHDmg = plot.health * TORNADO_PARTIAL_DAMAGE_FACTOR;
                            const totalFDmg = plot.fertility * TORNADO_PARTIAL_DAMAGE_FACTOR;
                            // Chia ƒë·ªÅu t·ªïng s√°t th∆∞∆°ng cho t·ªïng s·ªë tick c·ªßa hi·ªáu ·ª©ng
                            const healthDamageTick = totalTicksInDuration > 0 ? totalHDmg / totalTicksInDuration : 0;
                            const fertilityDamageTick = totalTicksInDuration > 0 ? totalFDmg / totalTicksInDuration : 0;
                            // G√¢y s√°t th∆∞∆°ng cho c√¢y n·∫øu c√≥
                            if (plot.seedId && plot.health > 0) {
                                const oldH = plot.health;
                                plot.health = Math.max(0, plot.health - healthDamageTick);
                                if(plot.health !== oldH) {
                                    damageAppliedThisTick = true;
                                    // --- LOG TH√äM ---
                                    console.log(` -> C√¢y √¥ ${i} ch·ªãu ${healthDamageTick.toFixed(1)} dmg (thi·ªát h·∫°i n·∫∑ng). HP c√≤n: ${plot.health.toFixed(1)}.`);
                                    // ---------------
                                }
                                // X·ª≠ l√Ω khi c√¢y ch·∫øt do thi·ªát h·∫°i n·∫∑ng
                                if(plot.health === 0 && oldH > 0) {
                                    plot.causeOfDeath = 'tornado'; plot.hasPest = false; plot.isDry = false; plot.pestDeathClickCount = 0;
                                    const plantName = ITEM_DATA[plot.seedId]?.name || 'C√¢y';
                                    console.warn(`(Tornado Part) Plot ${i} (${plantName}) ch·∫øt do thi·ªát h·∫°i n·∫∑ng.`);
                                    logAction('plant_death', i, `${plantName} √¥ ${i+1} ch·∫øt do thi·ªát h·∫°i gi√≥ l·ªëc.`, 'üíÄüå™Ô∏è', plot.seedId);
                                }
                            }
                            // Ho·∫∑c g√¢y s√°t th∆∞∆°ng cho ƒë·∫•t tr·ªëng n·∫øu c√≥
                            else if (!plot.seedId && plot.fertility > 0) {
                                const oldF = plot.fertility;
                                plot.fertility = Math.max(0, plot.fertility - fertilityDamageTick);
                                if(plot.fertility !== oldF) {
                                    damageAppliedThisTick = true;
                                    // --- LOG TH√äM ---
                                    console.log(` -> ƒê·∫•t √¥ ${i} ch·ªãu ${fertilityDamageTick.toFixed(1)} dmg (thi·ªát h·∫°i n·∫∑ng). Ph√¨ c√≤n: ${plot.fertility.toFixed(1)}.`);
                                    // ---------------
                                }
                                // X·ª≠ l√Ω khi ƒë·∫•t th√†nh c·∫±n c·ªói do thi·ªát h·∫°i n·∫∑ng
                                if(plot.fertility === 0 && oldF > 0) {
                                    plot.barrenHarvestPenaltyFactor = 1.0; plot.isDry = false;
                                    console.log(`(Tornado Part) Plot ${i} (tr·ªëng) th√†nh c·∫±n c·ªói do thi·ªát h·∫°i n·∫∑ng.`);
                                    logAction('soil_barren', i, `ƒê·∫•t √¥ ${i+1} th√†nh c·∫±n do thi·ªát h·∫°i gi√≥ l·ªëc.`, 'üß±üå™Ô∏è', null);
                                }
                            }
                        }
                    } // K·∫øt th√∫c x·ª≠ l√Ω c√¢y/ƒë·∫•t

                    // ƒê√°nh d·∫•u thay ƒë·ªïi tr·∫°ng th√°i chung n·∫øu c√≥ s√°t th∆∞∆°ng
                    if (damageAppliedThisTick) plotStateChangedDuringTick = true;
                    // QUAN TR·ªåNG: B·ªè qua c√°c x·ª≠ l√Ω kh√°c (s√¢u, h·ªìi m√°u,...) cho √¥ n√†y trong tick n√†y n·∫øu ƒëang b·ªã tornado
                    continue;
                } // K·∫øt th√∫c x·ª≠ l√Ω n·∫øu √¥ ƒëang b·ªã tornado

                // --- Ph·∫ßn x·ª≠ l√Ω plot th√¥ng th∆∞·ªùng (n·∫øu KH√îNG b·ªã tornado) ---

                // A. S√°t th∆∞∆°ng s√¢u (n·∫øu c√≥ s√¢u v√† c√¢y c√≤n s·ªëng)
                if (plot.hasPest && plot.health > 0) {
                    const stageInfo = getPlantStageInfo(plot, now); // L·∫•y th√¥ng tin giai ƒëo·∫°n
                    const damage = PEST_DAMAGE_PER_TICK * (stageInfo?.isMature ? PEST_DAMAGE_MATURE_REDUCTION_FACTOR : 1); // Gi·∫£m s√°t th∆∞∆°ng n·∫øu tr∆∞·ªüng th√†nh
                    const oldHealth = plot.health;
                    plot.health = Math.max(0, plot.health - damage); // Gi·∫£m m√°u
                    if (plot.health === 0 && oldHealth > 0) { // N·∫øu ch·∫øt do s√¢u
                        plot.causeOfDeath = 'pest'; plot.hasPest = false; plot.pestDeathClickCount = 0; plot.isDry = false;
                        plotUpdatedByOthers = true;
                        const plantName = ITEM_DATA[plot.seedId]?.name || 'C√¢y';
                        console.warn(`(Pest Damage) Plot ${i} (${plantName}) died from pest.`);
                        logAction('plant_death', i, `${plantName} √¥ ${i+1} ch·∫øt do s√¢u.`, 'üíÄüêõ', plot.seedId);
                    } else if(plot.health !== oldHealth) { // N·∫øu ch·ªâ gi·∫£m m√°u
                        plotUpdatedByOthers = true;
                    }
                }

                // B. S√¢u m·ªõi xu·∫•t hi·ªán (ch·ªâ khi th·ªùi ti·∫øt ph√π h·ª£p, c√¢y s·ªëng, ch∆∞a c√≥ s√¢u)
                const noPestWeather = ['sunny', 'cloudy', 'windy', 'lightning'];
                if (!noPestWeather.includes(gameState.currentWeather.id) && plot.seedId && plot.health > 0 && !plot.hasPest && Math.random() < PEST_APPEARANCE_CHANCE_PER_TICK_PER_PLOT) {
                    plot.hasPest = true;
                    const plantName = ITEM_DATA[plot.seedId]?.name || 'c√¢y';
                    showMessage(`·ªêi! S√¢u xu·∫•t hi·ªán tr√™n ${plantName} ·ªü √¥ ${i+1}!`, "pest-event");
                    plotUpdatedByOthers = true;
                    logAction('pest_appear', i, `S√¢u xu·∫•t hi·ªán tr√™n ${plantName}.`, 'üêõ‚ú®', plot.seedId);
                }

                // C. H·ªìi m√°u V√Ä ti√™u hao ph√¨ nhi√™u n·∫øu c√¢y tr∆∞·ªüng th√†nh (n·∫øu kh√¥ng s√¢u, kh√¥ng kh√¥)
                if (plot.seedId && plot.health > 0 && plot.health < INITIAL_PLANT_HEALTH && !plot.hasPest && !plot.isDry) {
                    const oldHealth = plot.health;
                    plot.health = Math.min(INITIAL_PLANT_HEALTH, plot.health + HEALTH_REGEN_PER_TICK); // TƒÉng m√°u
                    const healthGained = plot.health - oldHealth;
                    if (healthGained > 0) { // N·∫øu m√°u th·ª±c s·ª± tƒÉng
                        plotUpdatedByOthers = true;
                        const stageInfoForRegen = getPlantStageInfo(plot, now);
                        const seedInfoForRegen = ITEM_DATA[plot.seedId];
                        // Ti√™u hao ph√¨ n·∫øu c√¢y tr∆∞·ªüng th√†nh, c√≥ hao ƒë·∫•t, ƒë·∫•t c√≤n ph√¨
                        if (stageInfoForRegen && stageInfoForRegen.isMature && seedInfoForRegen && seedInfoForRegen.fertilityCost > 0 && seedInfoForRegen.growthTime > 0 && plot.fertility > 0) {
                            const fertilityDecreasePerGrowthSecond = (seedInfoForRegen.fertilityCost * BASE_FERTILITY) / seedInfoForRegen.growthTime;
                            const fertilityDecreaseThisTick = fertilityDecreasePerGrowthSecond * (TICK_INTERVAL / 1000);
                            if (fertilityDecreaseThisTick > 0) {
                                const oldFertility = plot.fertility;
                                plot.fertility = Math.max(0, plot.fertility - fertilityDecreaseThisTick); // Gi·∫£m ph√¨
                                // X·ª≠ l√Ω n·∫øu ƒë·∫•t th√†nh c·∫±n do h·ªìi m√°u
                                if (oldFertility > 0 && plot.fertility <= 0) {
                                     plot.barrenHarvestPenaltyFactor = 1.0;
                                     console.log(`(Mature Regen) Plot ${i} became barren due to regeneration cost.`);
                                }
                            }
                        }
                    }
                }

                // D. Gi·∫£m ph√¨ do c√¢y l·ªõn (ch·ªâ khi c√¢y ƒëang l·ªõn, c√≤n s·ªëng, ƒë·∫•t c√≤n ph√¨)
                if (plot.seedId && plot.health > 0) {
                    const seedInfo = ITEM_DATA[plot.seedId];
                    const stageInfo = getPlantStageInfo(plot, now);
                    // ƒêi·ªÅu ki·ªán: c√≥ hao ƒë·∫•t, ƒë·∫•t c√≤n ph√¨, c√¢y ƒëang l·ªõn
                    if (seedInfo?.fertilityCost > 0 && seedInfo.growthTime > 0 && plot.fertility > 0 && stageInfo && !stageInfo.isMature && !stageInfo.isDead) {
                        const decreasePerSecond = (seedInfo.fertilityCost * BASE_FERTILITY) / seedInfo.growthTime;
                        const decreaseThisTick = decreasePerSecond * (TICK_INTERVAL / 1000);
                        if (decreaseThisTick > 0) {
                            const oldF = plot.fertility;
                            plot.fertility = Math.max(0, plot.fertility - decreaseThisTick); // Gi·∫£m ph√¨
                            if (plot.fertility !== oldF) plotUpdatedByOthers = true; // ƒê√°nh d·∫•u thay ƒë·ªïi
                            // X·ª≠ l√Ω n·∫øu ƒë·∫•t th√†nh c·∫±n do c√¢y l·ªõn
                             if (oldF > 0 && plot.fertility <= 0) {
                                 plot.barrenHarvestPenaltyFactor = 1.0;
                                 console.log(`(Growth Cost) Plot ${i} became barren due to plant growth cost.`);
                            }
                        }
                    }
                }

                // E. H·∫≠u qu·∫£ kh√¥ h·∫°n (gi·∫£m m√°u c√¢y ho·∫∑c ƒë·ªô ph√¨ ƒë·∫•t tr·ªëng)
                if (plot.isDry) {
                    let changedByDryness = false;
                    if (plot.seedId && plot.health > 0) { // C√¢y tr·ªìng b·ªã kh√¥
                        const oldH = plot.health;
                        plot.health = Math.max(0, plot.health - DRY_HEALTH_DRAIN_PER_TICK); // Gi·∫£m m√°u
                        if (plot.health === 0 && oldH > 0) { // Ch·∫øt do kh√¥
                            plot.causeOfDeath = 'dryness'; plot.hasPest = false; plot.isDry = false;
                            changedByDryness = true;
                            const plantName = ITEM_DATA[plot.seedId]?.name || 'C√¢y';
                            console.warn(`(Dryness Damage) Plot ${i} (${plantName}) died from dryness.`);
                            logAction('plant_death', i, `${plantName} √¥ ${i+1} ch·∫øt do kh√¥ h·∫°n.`, 'üíÄüèúÔ∏è', plot.seedId);
                        } else if(plot.health !== oldH) { // Ch·ªâ gi·∫£m m√°u
                            changedByDryness = true;
                        }
                    } else if (!plot.seedId && plot.fertility > 0) { // ƒê·∫•t tr·ªëng b·ªã kh√¥
                        const oldF = plot.fertility;
                        plot.fertility = Math.max(0, plot.fertility - DRY_FERTILITY_DRAIN_PER_TICK); // Gi·∫£m ph√¨
                        if (plot.fertility !== oldF) {
                            changedByDryness = true;
                            if(plot.fertility === 0 && oldF > 0) { // ƒê·∫•t th√†nh c·∫±n do kh√¥
                                plot.barrenHarvestPenaltyFactor = 1.0;
                                console.log(`(Dryness Damage) Plot ${i} (empty) became barren due to dryness.`);
                                logAction('soil_barren', i, `ƒê·∫•t √¥ ${i+1} th√†nh c·∫±n do kh√¥ h·∫°n.`, 'üß±üèúÔ∏è', null);
                            }
                        }
                    }
                    if (changedByDryness) plotUpdatedByOthers = true; // ƒê√°nh d·∫•u thay ƒë·ªïi
                }
                // --- K·∫øt th√∫c x·ª≠ l√Ω plot th√¥ng th∆∞·ªùng ---

                // C·∫≠p nh·∫≠t c·ªù tr·∫°ng th√°i chung n·∫øu plot n√†y c√≥ thay ƒë·ªïi
                if (plotUpdatedByOthers) plotStateChangedDuringTick = true;

            } // K·∫øt th√∫c v√≤ng l·∫∑p for c√°c √¥ ƒë·∫•t

            // --- TƒÉng Ph√¨ Nhi√™u Do M∆∞a (m·ªói 15 gi√¢y) ---
            const fertilityBoostingWeather = ['rainy', 'thunderstorm', 'rainy_sunny'];
            let rainBoostApplied = false;
            if (fertilityBoostingWeather.includes(gameState.currentWeather.id) && tickCounter % 15 === 0) {
                for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                     if (isPlotWithRod(i) || gameState.activeTornadoes.some(t => t.plotId === i)) continue; // B·ªè qua √¥ c√≥ rod/tornado
                     const plot = gameState.plots[i];
                     if (plot && plot.fertility < BASE_FERTILITY) { // Ch·ªâ tƒÉng n·∫øu ch∆∞a max
                         const oldF = plot.fertility;
                         plot.fertility = Math.min(BASE_FERTILITY, plot.fertility + 1); // TƒÉng 1%
                         if (plot.fertility !== oldF) {
                             rainBoostApplied = true;
                             if (oldF <= 0 && plot.fertility > 0) { plot.barrenHarvestPenaltyFactor = 1.0; } // Reset penalty n·∫øu h·∫øt c·∫±n
                         }
                     }
                }
                if (rainBoostApplied) plotStateChangedDuringTick = true; // C·∫≠p nh·∫≠t c·ªù chung
            }

            // --- X·ª¨ L√ù S√âT ƒê√ÅNH ---
            let strikeOccurred = false; let strikeType = null; let strikeDmgPlant = 0; let strikeDmgSoil = 0;
            // X√°c su·∫•t v√† s√°t th∆∞∆°ng cho Thunderstorm
            if (gameState.currentWeather.id === 'thunderstorm' && Math.random() < THUNDERSTORM_STRIKE_CHANCE_PER_TICK) {
                strikeType = 'thunderstorm'; strikeDmgPlant = PLANT_HEALTH_DAMAGE; strikeDmgSoil = SOIL_FERTILITY_DAMAGE;
            }
            // X√°c su·∫•t v√† s√°t th∆∞∆°ng cho Lightning (ch·ªâ h√¨nh ·∫£nh nh∆∞ng v·∫´n c√≥ th·ªÉ g√¢y s√°t th∆∞∆°ng)
            else if (gameState.currentWeather.id === 'lightning' && Math.random() < LIGHTNING_VISUAL_STRIKE_CHANCE_PER_TICK) {
                strikeType = 'lightning'; strikeDmgPlant = LIGHTNING_PLANT_DAMAGE; strikeDmgSoil = LIGHTNING_SOIL_DAMAGE;
            }

            if (strikeType) { // N·∫øu c√≥ s√©t ƒë√°nh
                strikeOccurred = true; const unlockedPlots = gameState.maxUnlockedPlots;
                if (unlockedPlots > 0) {
                    const targetIdx = Math.floor(Math.random() * unlockedPlots); // Ch·ªçn √¥ m·ª•c ti√™u ng·∫´u nhi√™n
                    // Kh√¥ng ƒë√°nh v√†o √¥ ƒëang b·ªã tornado
                    if (!gameState.activeTornadoes.some(t => t.plotId === targetIdx)) {
                        playLightningSound(); // Ph√°t √¢m thanh (n·∫øu hi·ªáu ·ª©ng b·∫≠t)
                        const targetPlotEl = gardenElement.querySelector(`.plot[data-plot-id="${targetIdx}"]`);
                        const plotData = gameState.plots[targetIdx];
                        const isRodPlot = isPlotWithRod(targetIdx); // M·ª•c ti√™u c√≥ ph·∫£i l√† rod kh√¥ng?
                        const protectingRod = findRodInRange(targetIdx); // C√≥ rod n√†o b·∫£o v·ªá kh√¥ng?

                        // --- Tr∆∞·ªùng h·ª£p 1: ƒê∆∞·ª£c c·ªôt thu l√¥i kh√°c b·∫£o v·ªá ---
                        if (protectingRod) {
                             protectingRod.health = Math.max(0, protectingRod.health - 1); // Gi·∫£m m√°u rod b·∫£o v·ªá
                             plotStateChangedDuringTick = true;
                             const rodEl = gardenElement.querySelector(`.plot[data-plot-id="${protectingRod.plotId}"]`);
                             if (rodEl) { rodEl.classList.add('thunderstruck'); setTimeout(() => rodEl.classList.remove('thunderstruck'), 500); }
                             showMessage(`‚ö° C·ªôt thu l√¥i √¥ ${protectingRod.plotId + 1} h·ª©ng s√©t thay √¥ ${targetIdx + 1}! (HP: ${protectingRod.health}/${LIGHTNING_ROD_MAX_HEALTH})`, "warning");
                             logAction('lightning_intercepted', protectingRod.plotId, `Rod h·ª©ng s√©t thay √¥ ${targetIdx + 1}. HP ${protectingRod.health}.`, 'üõ°Ô∏è‚ö°', LIGHTNING_ROD_ITEM_ID);
                             if (protectingRod.health <= 0) {
                                 showMessage(`‚ö†Ô∏è C·ªôt thu l√¥i ·ªü √¥ ${protectingRod.plotId + 1} ƒë√£ h·ªèng!`, "error", 4500);
                                 logAction('rod_broken', protectingRod.plotId, `Rod ·ªü √¥ ${protectingRod.plotId + 1} h·ªèng do s√©t.`, 'üíî‚ö°', LIGHTNING_ROD_ITEM_ID);
                             }
                             saveGame(); // L∆∞u tr·∫°ng th√°i rod
                        }
                        // --- Tr∆∞·ªùng h·ª£p 2: S√©t ƒë√°nh tr√∫ng ch√≠nh c·ªôt thu l√¥i ---
                        else if (isRodPlot) {
                             const rodData = getRodData(targetIdx);
                             if (rodData && rodData.health > 0) { // Ch·ªâ gi·∫£m m√°u n·∫øu rod c√≤n ho·∫°t ƒë·ªông
                                  rodData.health = Math.max(0, rodData.health - 1);
                                  plotStateChangedDuringTick = true;
                                  const rodEl = gardenElement.querySelector(`.plot[data-plot-id="${targetIdx}"]`);
                                  if (rodEl) { rodEl.classList.add('thunderstruck'); setTimeout(() => rodEl.classList.remove('thunderstruck'), 500); }
                                  showMessage(`‚ö° C·ªôt thu l√¥i √¥ ${targetIdx + 1} b·ªã s√©t ƒë√°nh! (HP: ${rodData.health}/${LIGHTNING_ROD_MAX_HEALTH})`, "warning");
                                  logAction('lightning_strike_rod', targetIdx, `Rod b·ªã s√©t ƒë√°nh. HP ${rodData.health}.`, 'üí•‚ö°', LIGHTNING_ROD_ITEM_ID);
                                  if (rodData.health <= 0) {
                                      showMessage(`‚ö†Ô∏è C·ªôt thu l√¥i ·ªü √¥ ${targetIdx + 1} ƒë√£ h·ªèng!`, "error", 4500);
                                      logAction('rod_broken', targetIdx, `Rod ·ªü √¥ ${targetIdx + 1} h·ªèng do s√©t.`, 'üíî‚ö°', LIGHTNING_ROD_ITEM_ID);
                                  }
                                  saveGame();
                             }
                        }
                        // --- Tr∆∞·ªùng h·ª£p 3: S√©t ƒë√°nh tr√∫ng √¥ th∆∞·ªùng (kh√¥ng rod, kh√¥ng ƒë∆∞·ª£c b·∫£o v·ªá) ---
                        else if (targetPlotEl && plotData && !targetPlotEl.classList.contains('locked')) {
                             targetPlotEl.classList.add('thunderstruck'); // Hi·ªáu ·ª©ng rung l·∫Øc + GIF
                             setTimeout(() => targetPlotEl.classList.remove('thunderstruck'), STRIKE_DURATION_MS);

                             let dmgApplied = false; let msgType = 'warning'; let strikeMsg = `‚ö° S√©t ƒë√°nh tr√∫ng √¥ ${targetIdx + 1}!`;
                             const plantName = plotData.seedId ? (ITEM_DATA[plotData.seedId]?.name || 'C√¢y') : null;

                             // G√¢y s√°t th∆∞∆°ng cho c√¢y n·∫øu c√≥ v√† c√≤n s·ªëng
                             if (plotData.seedId && plotData.health > 0) {
                                  const oldH = plotData.health;
                                  plotData.health = Math.max(0, plotData.health - strikeDmgPlant);
                                  const lost = oldH - plotData.health;
                                  if(lost > 0) { strikeMsg += `\n${plantName} m·∫•t ${lost.toFixed(0)} HP!`; dmgApplied = true; plotStateChangedDuringTick = true; }
                                  if(plotData.health === 0 && oldH > 0) { // N·∫øu c√¢y ch·∫øt do s√©t
                                      plotData.causeOfDeath = 'lightning'; plotData.hasPest=false; plotData.isDry=false; plotData.pestDeathClickCount=0;
                                      strikeMsg += `\n${plantName} ch·∫øt! üíÄ`; msgType='error';
                                      logAction('plant_death', targetIdx, `${plantName} √¥ ${targetIdx + 1} ch·∫øt do s√©t ƒë√°nh.`, 'üíÄ‚ö°', plotData.seedId);
                                  }
                             }
                             // Ho·∫∑c g√¢y s√°t th∆∞∆°ng cho ƒë·∫•t tr·ªëng n·∫øu c√≤n ph√¨ nhi√™u
                             else if (!plotData.seedId && plotData.fertility > 0) {
                                  const oldF = plotData.fertility;
                                  plotData.fertility = Math.max(0, plotData.fertility - strikeDmgSoil);
                                  const lost = oldF - plotData.fertility;
                                  if(lost > 0) { strikeMsg += `\nƒê·∫•t gi·∫£m ${lost.toFixed(0)}% ph√¨!`; dmgApplied = true; plotStateChangedDuringTick = true; }
                                  if(plotData.fertility === 0 && oldF > 0) { // N·∫øu ƒë·∫•t th√†nh c·∫±n do s√©t
                                      strikeMsg += `\nƒê·∫•t c·∫±n!`; msgType='error'; plotData.barrenHarvestPenaltyFactor=1.0;
                                      logAction('soil_barren', targetIdx, `ƒê·∫•t √¥ ${targetIdx + 1} th√†nh c·∫±n do s√©t ƒë√°nh.`, 'üß±‚ö°', null);
                                  }
                             }

                             if(dmgApplied) { showMessage(strikeMsg, msgType, 4000); logAction('lightning_strike', targetIdx, strikeMsg.replace('\n',' - '), '‚ö°', null); }
                        }
                    } // end if (!isTornadoAffected)
                } // end if (unlockedPlots > 0)
            } // end if (strikeType)
            // --- K·∫æT TH√öC X·ª¨ L√ù S√âT ---

            // --- X·ª¨ L√ù S·ª∞ KI·ªÜN TORNADO (WINDY üå™Ô∏è) - K√çCH HO·∫†T ---
            // Ch·ªâ k√≠ch ho·∫°t n·∫øu ƒëang l√† Windy, ƒë·∫øn th·ªùi ƒëi·ªÉm, v√† ƒë√£ ƒë∆∞·ª£c l√™n l·ªãch (> 0)
            if (gameState.currentWeather.id === 'windy' && gameState.nextTornadoEventTimestamp > 0 && now >= gameState.nextTornadoEventTimestamp) {
                console.log("(Windy Event) K√≠ch ho·∫°t s·ª± ki·ªán gi√≥ l·ªëc!");
                let affectedPlotsInfo = []; let messages = ["üå™Ô∏è Gi√≥ l·ªëc qu√©t qua v∆∞·ªùn!"];
                const maxPlots = gameState.maxUnlockedPlots;
                const numAffected = Math.floor(Math.random() * Math.min(maxPlots, 5)) + 1; // 1-5 √¥
                const availableIndices = []; // T√¨m √¥ h·ª£p l·ªá (kh√¥ng rod, kh√¥ng tornado kh√°c)
                for(let i=0; i<maxPlots; ++i) { if(!gameState.activeTornadoes.some(t => t.plotId === i) && !isPlotWithRod(i)) { availableIndices.push(i); } }
                const targets = availableIndices.sort(() => 0.5 - Math.random()).slice(0, numAffected); // Ch·ªçn ng·∫´u nhi√™n

                targets.forEach(id => {
                    const plot = gameState.plots[id]; if(!plot) return;
                    let name= plot.seedId ? (ITEM_DATA[plot.seedId]?.name || "?") : "ƒê·∫•t tr·ªëng";
                    let type= plot.seedId ? "plant" : "empty";
                    affectedPlotsInfo.push({plotId: id+1, name, type});
                    const isDestr = Math.random() < TORNADO_DESTRUCTION_CHANCE; // Quy·∫øt ƒë·ªãnh ph√° h·ªßy hay thi·ªát h·∫°i
                    const msg = isDestr ? "ph√° h·ªßy!" : `thi·ªát h·∫°i n·∫∑ng (${(TORNADO_PARTIAL_DAMAGE_FACTOR*100).toFixed(0)}%)!`;
                    gameState.activeTornadoes.push({ // Th√™m v√†o danh s√°ch ho·∫°t ƒë·ªông
                        plotId: id, expireTimestamp: now + TORNADO_EFFECT_DURATION_MS_WINDY,
                        isDestruction: isDestr, targetType: type
                    });
                    messages.push(`- ${name} √¥ ${id+1} b·ªã ${msg}`);
                    plotStateChangedDuringTick = true; // ƒê√°nh d·∫•u thay ƒë·ªïi
                });

                if(affectedPlotsInfo.length > 0) {
                    showMessage(messages.join('\n'), 'error', 3800 + affectedPlotsInfo.length*800);
                    logAction('tornado_event', null, `L·ªëc ·∫£nh h∆∞·ªüng √¥: ${affectedPlotsInfo.map(p=>p.plotId).join(',')}.`, 'üå™Ô∏è');
                }
                // L√™n l·ªãch cho s·ª± ki·ªán tornado ti·∫øp theo
                const nextInt = TORNADO_EVENT_MIN_INTERVAL_MS_WINDY + Math.random()*(TORNADO_EVENT_MAX_INTERVAL_MS_WINDY - TORNADO_EVENT_MIN_INTERVAL_MS_WINDY);
                gameState.nextTornadoEventTimestamp = now + nextInt;
                console.log(`(Windy) L·ªëc ti·∫øp theo sau ${formatTime(nextInt)}`);
            }
            // --- K·∫æT TH√öC S·ª∞ KI·ªÜN TORNADO ---

            // --- X√ìA TORNADO H·∫æT H·∫†N ---
            const initialTornadoCount = gameState.activeTornadoes.length;
            gameState.activeTornadoes = gameState.activeTornadoes.filter(t => t.expireTimestamp > now); // L·ªçc b·ªè nh·ªØng c√°i ƒë√£ h·∫øt h·∫°n
            if (gameState.activeTornadoes.length < initialTornadoCount) {
                plotStateChangedDuringTick = true; // C·∫ßn render l·∫°i n·∫øu c√≥ tornado b·ªã x√≥a
                console.log(`ƒê√£ x√≥a ${initialTornadoCount - gameState.activeTornadoes.length} tornado h·∫øt h·∫°n.`);
            }
            // --- K·∫æT TH√öC X√ìA TORNADO ---

            // === Render l·∫°i v∆∞·ªùn N·∫æU c√≥ thay ƒë·ªïi tr·∫°ng th√°i c·ªßa b·∫•t k·ª≥ √¥ n√†o ===
            if (plotStateChangedDuringTick) {
                renderGarden(); // V·∫Ω l·∫°i khu v∆∞·ªùn
            }

            // C·∫≠p nh·∫≠t modal n·∫øu ƒëang m·ªü v√† d·ªØ li·ªáu √¥ t∆∞∆°ng ·ª©ng c√≥ th·ªÉ ƒë√£ thay ƒë·ªïi
            if (plantActionModal.style.display === 'block' && currentActionPlotId !== null && gameState.plots[currentActionPlotId]) { updatePlantActionModalButtons(currentActionPlotId); }
            if (emptyPlotActionModal.style.display === 'block' && currentActionPlotId !== null && gameState.plots[currentActionPlotId]) { updateEmptyPlotActionModal(currentActionPlotId); }
            if (lightningRodActionModal.style.display === 'block' && currentActionPlotId !== null && isPlotWithRod(currentActionPlotId)) { updateLightningRodActionModal(currentActionPlotId); }

            // T·ª± ƒë·ªông l∆∞u game ƒë·ªãnh k·ª≥
            if (tickCounter % AUTO_SAVE_INTERVAL_TICKS === 0 && tickCounter > 0) {
                saveGame();
            }
        } // --- K·∫øt th√∫c h√†m gameTick ---

       
        /**
         * [C·∫¨P NH·∫¨T Req 4] T√≠nh to√°n th·ªùi gian ph√°t tri·ªÉn hi·ªáu qu·∫£ (t√≠nh b·∫±ng gi√¢y) d·ª±a tr√™n ƒë·ªô ph√¨ nhi√™u v√† h·ªá s·ªë ph·∫°t.
         */
         function getEffectiveGrowthTime(plot) {
            if (!plot || !plot.seedId) return 0;
            const seedInfo = ITEM_DATA[plot.seedId];
            if (!seedInfo || seedInfo.type !== 'seed') return 0;

            const baseGrowthTime = seedInfo.growthTime;
            if (baseGrowthTime <= 0) return 0;

            const plotFertility = plot.fertility;
            const penaltyFactor = plot.barrenHarvestPenaltyFactor || 1.0;

            // √Åp d·ª•ng h·ªá s·ªë ph·∫°t CH·ªà KHI ƒë·∫•t c·∫±n (<= 0%)
            if (plotFertility <= 0 && penaltyFactor > 1.0) {
                const totalEffectiveTime = baseGrowthTime * penaltyFactor;
                // console.log(`Plot ${plot.id} barren. Base: ${baseGrowthTime}s, Factor: ${penaltyFactor}, Effective: ${totalEffectiveTime}s`);
                return Math.max(baseGrowthTime, totalEffectiveTime); // ƒê·∫£m b·∫£o kh√¥ng √≠t h∆°n th·ªùi gian g·ªëc
            }

            // Tr·∫£ v·ªÅ th·ªùi gian g·ªëc n·∫øu ƒë·∫•t kh√¥ng c·∫±n ho·∫∑c kh√¥ng c√≥ penalty factor > 1
            return baseGrowthTime;
        }


        /** L·∫•y th√¥ng tin to√†n di·ªán v·ªÅ tr·∫°ng th√°i, ƒë·ªô tr∆∞·ªüng th√†nh v√† NGU·ªíN H√åNH ·∫¢NH c·ªßa c√¢y. */
        function getPlantStageInfo(plot, currentTime) {
            // --- Ph·∫ßn kh·ªüi t·∫°o gi√° tr·ªã m·∫∑c ƒë·ªãnh ---
            const defaultReturn = {
                visualSrc: '', stageIndex: -1, isMature: false, isDead: false, growthProgress: 0,
                health: plot.health, fertility: plot.fertility, hasPest: plot.hasPest,
                effectiveGrowthTimeSec: 0, isError: false, causeOfDeath: plot.causeOfDeath,
                barrenHarvestPenaltyFactor: plot.barrenHarvestPenaltyFactor || 1.0
            };

            if (!plot.seedId || !plot.plantTime) {
                return { ...defaultReturn, fertility: plot.fertility, health: INITIAL_PLANT_HEALTH, barrenHarvestPenaltyFactor: plot.barrenHarvestPenaltyFactor || 1.0 };
            }

            const seedInfo = ITEM_DATA[plot.seedId];
            if (!seedInfo || seedInfo.type !== 'seed' || !seedInfo.imageFolder) {
                console.error(`SeedId "${plot.seedId}" kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu imageFolder trong √¥ ${plot.id}`);
                return { ...defaultReturn, isError: true, health: plot.health, fertility: plot.fertility, hasPest: plot.hasPest, causeOfDeath: plot.causeOfDeath, barrenHarvestPenaltyFactor: plot.barrenHarvestPenaltyFactor || 1.0 };
            }

            // --- Ph·∫ßn t√≠nh to√°n th·ªùi gian, ti·∫øn tr√¨nh, giai ƒëo·∫°n ---
            const effectiveGrowthTimeSec = getEffectiveGrowthTime(plot);
            const totalGrowthTimeMs = effectiveGrowthTimeSec * 1000;
            const elapsedTime = currentTime - plot.plantTime;
            const growthProgress = totalGrowthTimeMs > 0 ? Math.min(1, elapsedTime / totalGrowthTimeMs) : 1;

            let stageIndex = -1;
            let visualSrc = '';
            const isDead = plot.health <= 0;
            const baseImagePath = `Hinhanh/${seedInfo.imageFolder}/`;

            // --- X·ª≠ l√Ω c√¢y ch·∫øt ---
            if (isDead) {
                stageIndex = -2;
                // S·ª≠ d·ª•ng ·∫£nh ch·∫øt chung cho s√¢u, s√©t, l·ªëc
                if (plot.causeOfDeath === 'pest' || plot.causeOfDeath === 'lightning' || plot.causeOfDeath === 'tornado') {
                    visualSrc = 'Hinhanh/Caychet.png';
                } else { // Ch·∫øt t·ª± nhi√™n, kh√¥ h·∫°n, kh√¥ng r√µ
                    visualSrc = baseImagePath + 'Caychet.png';
                }
            } else { // C√¢y c√≤n s·ªëng
                const stageThresholds = [0, 0.3, 0.7, 1.0];
                for (let i = stageThresholds.length - 1; i >= 0; i--) {
                    if (growthProgress >= stageThresholds[i] - 0.0001) {
                        stageIndex = i;
                        visualSrc = baseImagePath + `pic_hatgiong_giaidoan${i + 1}.png`;
                        break;
                    }
                }
                if (stageIndex === -1 && growthProgress >= 0) { // Fallback n·∫øu kh√¥ng l·ªçt v√≤ng l·∫∑p
                    stageIndex = 0;
                    visualSrc = baseImagePath + 'pic_hatgiong_giaidoan1.png';
                }
            }

            // --- Ph·∫ßn x√°c ƒë·ªãnh isMature v√† fallback images ---
            const isMature = (growthProgress >= 1.0 - 0.0001) && !isDead && !plot.hasPest;
            // Fallback images
            if (isMature && !visualSrc && !isDead) {
                 visualSrc = baseImagePath + `pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
                 stageIndex = PLANT_GROWTH_STAGES - 1;
            }
            if (isDead && !visualSrc) {
                if (plot.causeOfDeath === 'pest' || plot.causeOfDeath === 'lightning' || plot.causeOfDeath === 'tornado') {
                     visualSrc = 'Hinhanh/Caychet.png';
                } else {
                     visualSrc = baseImagePath + 'pic_hatgiong_giaidoanchet.png';
                }
            }
            if (!visualSrc && stageIndex >= 0 && !isDead) visualSrc = 'Hinhanh/General/ErrorPlant.png';
            if (!visualSrc) visualSrc = 'Hinhanh/Caychet.png';

            // --- Tr·∫£ v·ªÅ k·∫øt qu·∫£ t·ªïng h·ª£p ---
            return {
                visualSrc, stageIndex, isMature, isDead, growthProgress,
                health: plot.health, fertility: plot.fertility, hasPest: plot.hasPest,
                effectiveGrowthTimeSec, isError: false, causeOfDeath: plot.causeOfDeath,
                barrenHarvestPenaltyFactor: plot.barrenHarvestPenaltyFactor || 1.0
            };
        } // --- K·∫øt th√∫c h√†m getPlantStageInfo ---

        /** Render c√°c ph·∫ßn t·ª≠ UI ch√≠nh (ti·ªÅn, s·ªë √¥ ƒë·∫•t). */
        function renderUI() {
            currencyElement.textContent = gameState.currency;
            plotCountElement.textContent = `${gameState.maxUnlockedPlots}`;
        }

        /** ƒêi·ªÅn v√†o modal c·ª≠a h√†ng v·ªõi c√°c tab v√† v·∫≠t ph·∫©m. */
        

        /** Render modal kho ƒë·ªì v·ªõi √¥ nh·∫≠p s·ªë l∆∞·ª£ng b√°n. */
       function renderInventory() {
    inventoryHarvestedList.innerHTML = '';
    inventoryPurchasedList.innerHTML = '';
    let harvestedCount = 0;
    let purchasedCount = 0;

    // --- T√≠nh to√°n v√† c·∫≠p nh·∫≠t ti√™u ƒë·ªÅ kho ƒë·ªì ---
    const currentTotalCount = getTotalInventoryCount(); // S·ª≠ d·ª•ng h√†m ƒë√£ c·∫≠p nh·∫≠t
    const inventoryTitleElement = inventoryModal.querySelector('.modal-header h2');
    if (inventoryTitleElement) {
        inventoryTitleElement.textContent = `üéí T√∫i ƒê·ªì C·ªßa B·∫°n (${currentTotalCount}/${gameState.maxInventoryCapacity})`;
    }

    // --- Render Tab ƒê√£ Thu Ho·∫°ch (C√ì CH·∫§T L∆Ø·ª¢NG) ---
    const harvestedItemIds = Object.keys(gameState.harvestedItems);
    harvestedItemIds.sort((a, b) => (ITEM_DATA[a]?.name || '').localeCompare(ITEM_DATA[b]?.name || ''));

    harvestedItemIds.forEach(itemId => {
        const qualityData = gameState.harvestedItems[itemId];
        if (!qualityData) { // Th√™m ki·ªÉm tra ph√≤ng l·ªói
             delete gameState.harvestedItems[itemId];
             return;
        }
        // T√≠nh t·ªïng s·ªë l∆∞·ª£ng t·ª´ c√°c b·∫≠c ch·∫•t l∆∞·ª£ng
        const totalQuantity = (qualityData[QUALITY_TIERS.PERFECT] || 0) +
                              (qualityData[QUALITY_TIERS.GOOD] || 0) +
                              (qualityData[QUALITY_TIERS.FAIR] || 0) +
                              (qualityData[QUALITY_TIERS.POOR] || 0);

        if (totalQuantity > 0) {
            harvestedCount++;
            const item = ITEM_DATA[itemId];
            if (!item || item.type !== 'seed') {
                console.warn(`V·∫≠t ph·∫©m thu ho·∫°ch "${itemId}" kh√¥ng ph·∫£i h·∫°t gi·ªëng ho·∫∑c kh√¥ng t·ªìn t·∫°i.`);
                // X√≥a d·ªØ li·ªáu l·ªói kh·ªèi kho
                delete gameState.harvestedItems[itemId];
                return;
            }

            const itemCard = document.createElement('div');
            itemCard.classList.add('item-card', 'no-hover');
            itemCard.dataset.itemId = itemId;

            let iconSrc = item.imageFolder ? `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png` : 'Hinhanh/Caychet.png';
            const imgTagInv = `<img src="${iconSrc}" alt="${item.name}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
            const iconHtml = `<span class="item-icon">${imgTagInv}</span>`;

            const baseValue = item.harvestYield || 0;
            let totalPotentialValue = 0; // T·ªïng gi√° tr·ªã n·∫øu b√°n h·∫øt

            // X√¢y d·ª±ng chu·ªói hi·ªÉn th·ªã chi ti·∫øt ch·∫•t l∆∞·ª£ng v√† t√≠nh t·ªïng gi√° tr·ªã
            let qualityDetailsHtml = '<div class="item-quality-details" style="font-size: 0.75rem; margin-bottom: 6px; text-align: left; padding: 0 5px;">';
            let qualityParts = [];
            const tierOrder = [QUALITY_TIERS.PERFECT, QUALITY_TIERS.GOOD, QUALITY_TIERS.FAIR, QUALITY_TIERS.POOR];
            tierOrder.forEach(tier => {
                const count = qualityData[tier] || 0;
                if (count > 0) {
                    const tierValue = Math.round(baseValue * (QUALITY_VALUE_MULTIPLIERS[tier] || 0));
                    qualityParts.push(`${QUALITY_DISPLAY_NAMES[tier]}: ${count} (Gi√°: ${tierValue}üí∞)`);
                    totalPotentialValue += count * tierValue;
                }
            });
            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p kh√¥ng c√≥ ch·∫•t l∆∞·ª£ng n√†o (d√π totalQuantity > 0, n√™n kh√¥ng x·∫£y ra)
            if (qualityParts.length === 0) qualityParts.push("Kh√¥ng c√≥ d·ªØ li·ªáu ch·∫•t l∆∞·ª£ng");
            qualityDetailsHtml += qualityParts.join('<br>') + '</div>';

            itemCard.innerHTML = `
                ${iconHtml}
                <div class="item-name">${item.name}</div>
                <div class="item-quantity">T·ªïng s·ªë l∆∞·ª£ng: <span class="current-quantity">${totalQuantity}</span></div>
                <!-- Hi·ªÉn th·ªã chi ti·∫øt ch·∫•t l∆∞·ª£ng -->
                ${qualityDetailsHtml}
                <div class="item-harvest-value">T·ªïng gi√° tr·ªã (b√°n h·∫øt): <span>${totalPotentialValue}üí∞</span></div>
                <div class="sell-container">
                    <div class="sell-quantity-selector">
                        <label for="sell-qty-${itemId}">B√°n SL:</label>
                        <input type="number" id="sell-qty-${itemId}" class="sell-quantity-input" value="1" min="1" max="${totalQuantity}" step="1" data-item-id="${itemId}">
                    </div>
                    <div class="sell-buttons-row" style="display: flex; justify-content: center; gap: 8px; width: 100%; margin-top: 5px;">
                        <button class="sell-button sell-selected-button" data-item-id="${itemId}" title="B√°n s·ªë l∆∞·ª£ng ƒë√£ ch·ªçn (∆Øu ti√™n ch·∫•t l∆∞·ª£ng th·∫•p)">B√°n</button>
                        <button class="sell-button sell-all-button" data-item-id="${itemId}" title="B√°n h·∫øt ${totalQuantity} ${item.name} (Gi√° tr·ªã: ${totalPotentialValue}üí∞)">B√°n H·∫øt</button>
                    </div>
                </div>
            `;
            inventoryHarvestedList.appendChild(itemCard);
        } else {
            // N·∫øu t·ªïng s·ªë l∆∞·ª£ng = 0 nh∆∞ng key v·∫´n t·ªìn t·∫°i, x√≥a n√≥ ƒëi
            if (gameState.harvestedItems[itemId]) {
                delete gameState.harvestedItems[itemId];
            }
        }
    });

    // --- Render Tab ƒê√£ Mua ---
    const purchasedItemIds = Object.keys(gameState.inventory);
    purchasedItemIds.sort((a, b) => {
        const itemA = ITEM_DATA[a]; const itemB = ITEM_DATA[b];
        if (!itemA) return 1; if (!itemB) return -1;
        // S·ª≠a l·∫°i th·ª© t·ª± ∆∞u ti√™n: tool -> upgrade -> seed
        const typeOrderInv = { 'tool': 1, 'upgrade': 2, 'seed': 3 };
        const orderAInv = typeOrderInv[itemA.type] || 99;
        const orderBInv = typeOrderInv[itemB.type] || 99;
        if (orderAInv !== orderBInv) return orderAInv - orderBInv;
        // Trong c√πng type 'tool', ∆∞u ti√™n pesticide r·ªìi ƒë·∫øn gi√°
        if (itemA.type === 'tool') {
            if (itemA.id === 'pesticide') return -1;
            if (itemB.id === 'pesticide') return 1;
            const priceDiff = (itemA.price || 0) - (itemB.price || 0);
            if (priceDiff !== 0) return priceDiff;
        }
        // S·∫Øp x·∫øp theo gi√° cho seed v√† upgrade
        const priceDiffGeneral = (itemA.price || 0) - (itemB.price || 0);
        if (priceDiffGeneral !== 0) return priceDiffGeneral;
        // N·∫øu gi√° b·∫±ng nhau, s·∫Øp x·∫øp theo t√™n
        return (itemA.name || '').localeCompare(itemB.name || '');
    });

    purchasedItemIds.forEach(itemId => {
        const quantity = gameState.inventory[itemId];
        if (quantity > 0) {
            purchasedCount++;
            const item = ITEM_DATA[itemId];
            if (!item) { console.warn(`V·∫≠t ph·∫©m ƒë√£ mua "${itemId}" kh√¥ng t√¨m th·∫•y trong ITEM_DATA.`); return; }

            const itemCard = document.createElement('div');
            itemCard.classList.add('item-card', 'no-hover');
            itemCard.dataset.itemId = itemId;

            let iconHtml = '';
            let detailsHtml = '';
            let quantityClass = '';

            // ---- LOGIC L·∫§Y ICON ƒê√É ƒê∆Ø·ª¢C S·ª¨A ----
            let iconSrc = 'Hinhanh/Caychet.png'; // ·∫¢nh m·∫∑c ƒë·ªãnh
            if (item.type === 'seed' && item.imageFolder) {
                iconSrc = `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
            } else if (item.type === 'tool' && item.imageFolder && item.imageFile) {
                iconSrc = `${item.imageFolder}/${item.imageFile}`;
            }
            // <<< ƒêI·ªÄU KI·ªÜN ƒê√É TH√äM CHO UPGRADE >>>
            else if (item.type === 'upgrade' && item.imageFolder && item.imageFile) {
                // L·∫•y ·∫£nh t·ª´ imageFolder v√† imageFile gi·ªëng nh∆∞ tool
                iconSrc = `${item.imageFolder}/${item.imageFile}`;
            }
            // ---- K·∫æT TH√öC S·ª¨A LOGIC ICON ----

            const imgTagPurch = `<img src="${iconSrc}" alt="${item.name}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
            iconHtml = `<span class="item-icon">${imgTagPurch}</span>`;

            // T·∫°o details v√† class cho quantity (logic kh√¥ng ƒë·ªïi)
            if (item.type === 'seed') {
                detailsHtml = `<div class="item-details" style="font-size: 0.7rem;">(L·ªõn: ${formatTime(item.growthTime * 1000, true)}, Hao: ${(item.fertilityCost*100).toFixed(0)}% ƒë·∫•t)</div>`;
            } else if (item.id === 'pesticide') {
                detailsHtml = `<div class="item-details" style="font-size: 0.75rem;">${item.description || ''}</div>`;
                quantityClass = 'pesticide';
            } else if (item.type === 'tool') { // Ph√¢n b√≥n & c√°c tool kh√°c (kh√¥ng ph·∫£i upgrade)
                 detailsHtml = `<div class="item-details" style="font-size: 0.75rem;">`;
                 if (typeof item.fertilityBoost === 'number') detailsHtml += `<div>üí© Ph√¨: +${(item.fertilityBoost * 100).toFixed(0)}%</div>`;
                 // Th√™m m√¥ t·∫£ n·∫øu c√≥ v√† kh√¥ng ch·ªâ l√† v·ªÅ ph√¨ nhi√™u
                 if (item.description) detailsHtml += `<div>${item.description}</div>`;
                 detailsHtml += `</div>`;
                 if (typeof item.fertilityBoost === 'number') quantityClass = 'fertilizer';
            } else if (item.type === 'upgrade') { // Th√™m x·ª≠ l√Ω cho upgrade
                detailsHtml = `<div class="item-details" style="font-size: 0.75rem;">${item.description || 'N√¢ng c·∫•p'}</div>`;
                quantityClass = 'upgrade'; // C√≥ th·ªÉ th√™m class ri√™ng n·∫øu mu·ªën style kh√°c
            }

            // T·∫°o innerHTML cho th·∫ª v·∫≠t ph·∫©m
            itemCard.innerHTML = `
                ${iconHtml}
                <div class="item-name">${item.name}</div>
                <div class="item-quantity ${quantityClass}">S·ªë l∆∞·ª£ng: ${quantity}</div>
                ${detailsHtml}
                <button class="action-button discard-purchased-button" data-item-id="${itemId}" title="B·ªè v·∫≠t ph·∫©m n√†y..." style="background-color: #e74c3c; margin-top: 8px; padding: 5px 10px; font-size: 0.75rem;">B·ªè ƒëi...</button>
            `;
            inventoryPurchasedList.appendChild(itemCard);
        }
   });

    // --- Hi·ªÉn th·ªã/·∫©n th√¥ng b√°o tr·ªëng v√† danh s√°ch ---
    inventoryHarvestedEmptyMessage.style.display = harvestedCount === 0 ? 'block' : 'none';
    inventoryPurchasedEmptyMessage.style.display = purchasedCount === 0 ? 'block' : 'none';
    const activeTab = inventoryTabsContainer.querySelector('.tab-button.active')?.dataset.tab || 'harvested';
    switchInventoryTab(activeTab); // G·ªçi l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªÉn th·ªã ƒë√∫ng
    inventoryHarvestedList.style.display = (harvestedCount > 0 && inventoryHarvestedList.classList.contains('active-list')) ? 'grid' : 'none';
    inventoryPurchasedList.style.display = (purchasedCount > 0 && inventoryPurchasedList.classList.contains('active-list')) ? 'grid' : 'none';
} // --- K·∫øt th√∫c h√†m renderInventory ---
function buyInventoryUpgrade(itemId) {
    const item = ITEM_DATA[itemId];
    console.log(`Attempting to buy upgrade: ${itemId}`); // Debug log

    // --- Ki·ªÉm tra c∆° b·∫£n ---
    if (!item || item.type !== 'upgrade' || !item.upgradeCapacity) {
        showMessage("L·ªói: V·∫≠t ph·∫©m n√¢ng c·∫•p kh√¥ng h·ª£p l·ªá!", "error");
        console.error(`buyInventoryUpgrade: Invalid item or missing upgradeCapacity for ${itemId}`);
        return;
    }

    const requiredCapacity = item.upgradeCapacity.from;
    const newCapacity = item.upgradeCapacity.to;
    const cost = item.price;

    // --- Ki·ªÉm tra ƒëi·ªÅu ki·ªán mua ---
    if (gameState.maxInventoryCapacity !== requiredCapacity) {
        showMessage(`Y√™u c·∫ßu s·ª©c ch·ª©a kho hi·ªán t·∫°i l√† ${requiredCapacity} ƒë·ªÉ mua "${item.name}". Kho c·ªßa b·∫°n ƒëang l√† ${gameState.maxInventoryCapacity}.`, "warning");
        console.warn(`buyInventoryUpgrade: Capacity requirement not met for ${itemId}. Current: ${gameState.maxInventoryCapacity}, Required: ${requiredCapacity}`);
        return;
    }

    if (gameState.currency < cost) {
        showMessage(`Kh√¥ng ƒë·ªß ti·ªÅn mua "${item.name}"! C·∫ßn ${cost}üí∞.`, "error");
        console.warn(`buyInventoryUpgrade: Insufficient funds for ${itemId}. Have: ${gameState.currency}, Need: ${cost}`);
        // C·∫≠p nh·∫≠t l·∫°i n√∫t trong shop ƒë·ªÉ ƒë·∫£m b·∫£o n√≥ disabled
        if (shopModal.style.display === 'block') updateShopButtons();
        return;
    }

    // --- Th·ª±c hi·ªán n√¢ng c·∫•p ---
    gameState.currency -= cost;
    gameState.maxInventoryCapacity = newCapacity;
    console.log(`Inventory capacity upgraded to ${newCapacity}`);

    // --- C·∫≠p nh·∫≠t giao di·ªán & L∆∞u game ---
    renderUI(); // C·∫≠p nh·∫≠t ti·ªÅn
    renderInventory(); // C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ kho ƒë·ªì
    updateShopButtons(); // V√¥ hi·ªáu h√≥a n√∫t v·ª´a mua, c√≥ th·ªÉ k√≠ch ho·∫°t n√∫t n√¢ng c·∫•p ti·∫øp theo
    saveGame();

    // --- Th√¥ng b√°o & Log ---
    showMessage(`Ch√∫c m·ª´ng! Kho ƒë·ªì ƒë√£ ƒë∆∞·ª£c n√¢ng c·∫•p l√™n ${newCapacity} ch·ªó!`, "success");
    logAction('buy_upgrade', null, `Mua n√¢ng c·∫•p "${item.name}", kho l√™n ${newCapacity} ch·ªó (-${cost}üí∞).`, '‚¨ÜÔ∏èüéí', itemId);

    // --- C·∫≠p nh·∫≠t l·∫°i shop m·ªôt l·∫ßn n·ªØa ƒë·ªÉ ch·∫Øc ch·∫Øn ---
    // (ƒê√¥i khi renderInventory ho·∫∑c renderUI c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn updateShopButtons tr∆∞·ªõc ƒë√≥)
     if (shopModal.style.display === 'block') {
         setTimeout(updateShopButtons, 50); // Delay nh·ªè ƒë·ªÉ ƒë·∫£m b·∫£o c√°c c·∫≠p nh·∫≠t kh√°c ho√†n t·∫•t
     }
}




	  
function clearPlantOnly(plotId) {
             // 1. Ki·ªÉm tra ƒë·∫ßu v√†o (gi·ªëng clearPlot)
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                 console.warn(`C·ªë g·∫Øng d·ªçn c√¢y tr√™n √¥ kh√¥ng h·ª£p l·ªá/b·ªã kh√≥a ${plotId}.`);
                 return;
             }
             const plot = gameState.plots[plotId];

             // 2. L∆∞u tr·ªØ th√¥ng tin *tr∆∞·ªõc* khi reset (gi·ªëng clearPlot)
             const wasPlanted = !!plot.seedId;
             const originalSeedId = plot.seedId;
             const plantName = wasPlanted ? (ITEM_DATA[originalSeedId]?.name || 'c√¢y') : '√¥ ƒë·∫•t';
             const wasDead = wasPlanted && plot.health <= 0;
             const causeOfDeath = plot.causeOfDeath;
             const wasPestDeath = wasDead && causeOfDeath === 'pest';
             const wasFreePestCleanup = wasPestDeath && (plot.pestDeathClickCount || 0) >= DEAD_PEST_FREE_CLEANUP_CLICKS;

             // 3. --- Reset Tr·∫°ng Th√°i C√¢y Tr·ªìng (KH√îNG ch·∫°m v√†o fenceData) ---
             plot.seedId = null;
             plot.plantTime = null;
             plot.hasPest = false;
             plot.health = INITIAL_PLANT_HEALTH;
             plot.causeOfDeath = null;
             plot.pestDeathClickCount = 0;
             // plot.fertility KH√îNG reset
             plot.barrenHarvestPenaltyFactor = 1.0; // Reset h·ªá s·ªë ph·∫°t
             plot.isDry = false; // Reset kh√¥ h·∫°n
             // --- Reset Buff khi Ch·ªâ D·ªçn C√¢y ---
             plot.fertilizerGrowthUsageCount = 0; // Reset b·ªô ƒë·∫øm khi ch·ªâ d·ªçn c√¢y
             plot.fertilizerProtectUsageCount = 0; // Reset b·ªô ƒë·∫øm khi ch·ªâ d·ªçn c√¢y
             plot.hasFertilizerProtectBuff = false; // Reset buff khi ch·ªâ d·ªçn c√¢y
             // --- K·∫øt Th√∫c Reset Buff ---
             // *** D√≤ng plot.fenceData = null; ƒë√£ b·ªã X√ìA b·ªè ***

             // 4. C·∫≠p nh·∫≠t giao di·ªán v√† L∆∞u game (gi·ªëng clearPlot)
             renderGarden();
             saveGame();

             // 5. Log Action (gi·ªëng clearPlot, c√≥ th·ªÉ gi·ªØ nguy√™n ho·∫∑c s·ª≠a nh·∫π text n·∫øu mu·ªën)
             let logDetails = '';
             let logIcon = '‚õèÔ∏è';
             if (wasPlanted) {
                 if (wasPestDeath) {
                     logIcon = 'üíÄ';
                     logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt do s√¢u, ${wasFreePestCleanup ? 'mi·ªÖn ph√≠' : 't·ªën ph√≠'}).`; // B·ªè '·ªü √¥...'
                 } else if (wasDead && causeOfDeath === 'dryness') {
                     logIcon = 'üíÄ';
                     logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt do kh√¥ h·∫°n).`;
                 } else if (wasDead && causeOfDeath === 'lightning') {
                     logIcon = 'üíÄ‚ö°';
                     logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt do s√©t ƒë√°nh).`;
                 } else if (wasDead && causeOfDeath === 'tornado') { // Th√™m case gi√≥ l·ªëc
                    logIcon = 'üíÄüå™Ô∏è';
                    logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt do gi√≥ l·ªëc).`;
                 } else if (wasDead) {
                     logIcon = 'üíÄ';
                     logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt t·ª± nhi√™n/kh√°c).`;
                 } else {
                     logDetails = `√î ${plotId + 1}: X·ªõi b·ªè ${plantName} (ƒëang s·ªëng).`;
                 }
             } else {
                 logDetails = `ƒê√£ x·ªõi/d·ªçn √¥ ƒë·∫•t tr·ªëng ${plotId + 1}.`;
             }
             logAction('clear_plant', plotId, logDetails, logIcon, originalSeedId); // C√≥ th·ªÉ ƒë·ªïi type log n·∫øu mu·ªën

             // 6. Hi·ªÉn th·ªã Th√¥ng b√°o (gi·ªëng clearPlot, c√≥ th·ªÉ gi·ªØ nguy√™n)
              if (!(wasPestDeath && !wasFreePestCleanup)) {
                 if (wasFreePestCleanup) { /* Message ƒë√£ hi·ªán khi ƒë·ªß click */ }
                 else if (wasDead && causeOfDeath === 'dryness') { showMessage(`ƒê√£ d·ªçn ${plantName} ch·∫øt kh√¥ kh·ªèi √¥ ${plotId + 1}.`, "info"); }
                 else if (wasDead && causeOfDeath === 'lightning') { showMessage(`ƒê√£ d·ªçn ${plantName} ch·∫øt do s√©t ƒë√°nh kh·ªèi √¥ ${plotId + 1}.`, "info"); }
                 else if (wasDead && causeOfDeath === 'tornado') { showMessage(`ƒê√£ d·ªçn ${plantName} ch·∫øt do gi√≥ l·ªëc kh·ªèi √¥ ${plotId + 1}.`, "info"); }
                 else if (wasPlanted && !wasDead) { showMessage(`ƒê√£ x·ªõi b·ªè ${plantName} ƒëang s·ªëng ·ªü √¥ ${plotId + 1}.`, "warning"); }
                 else if (wasDead) { showMessage(`ƒê√£ d·ªçn ${plantName} ch·∫øt kh·ªèi √¥ ${plotId + 1}.`, "info"); }
             }

             // 7. ƒê√≥ng modal h√†nh ƒë·ªông n·∫øu n√≥ ƒëang m·ªü (gi·ªëng clearPlot)
             if (plantActionModal.style.display === 'block' && currentActionPlotId === plotId) {
                 closeModal('plant-action-modal');
                 currentActionPlotId = null;
             }
         } // --- K·∫øt th√∫c h√†m clearPlantOnly ---
	  
	/** ƒê√≥ng popup x√°c nh·∫≠n b·ªè v·∫≠t ph·∫©m */
function closeDiscardItemPopup() {
    if (discardItemPopup) {
        discardItemPopup.style.display = 'none';
        // T√πy ch·ªçn: Reset input v√† error message khi ƒë√≥ng
        if(discardQuantityInput) discardQuantityInput.value = 1;
        if(discardQuantityError) discardQuantityError.textContent = '';
        if(confirmDiscardBtn) delete confirmDiscardBtn.dataset.itemId;
    }
}  
	  

		 function discardPurchasedItem(itemId, quantityToDiscard) {
    // 1. Validate itemId v√† l·∫•y th√¥ng tin item
    const item = ITEM_DATA[itemId];
    if (!item) {
        console.error(`discardPurchasedItem: V·∫≠t ph·∫©m kh√¥ng t·ªìn t·∫°i: ${itemId}`);
        showMessage("L·ªói: Kh√¥ng th·ªÉ b·ªè v·∫≠t ph·∫©m kh√¥ng t·ªìn t·∫°i.", "error");
        return;
    }

    // 2. Ki·ªÉm tra s·ªë l∆∞·ª£ng hi·ªán c√≥ trong kho ƒê√É MUA
    const currentQuantity = gameState.inventory[itemId] || 0;

    // 3. Validate quantityToDiscard (ƒë·∫£m b·∫£o l√† s·ªë, > 0 v√† <= s·ªë l∆∞·ª£ng hi·ªán c√≥)
    const validQuantityToDiscard = parseInt(quantityToDiscard);
    if (isNaN(validQuantityToDiscard) || validQuantityToDiscard <= 0) {
         showMessage(`S·ªë l∆∞·ª£ng (${quantityToDiscard}) c·∫ßn b·ªè kh√¥ng h·ª£p l·ªá.`, "error");
         console.warn(`discardPurchasedItem: S·ªë l∆∞·ª£ng b·ªè kh√¥ng h·ª£p l·ªá: ${quantityToDiscard}`);
         return;
    }
    if (validQuantityToDiscard > currentQuantity) {
         showMessage(`Kh√¥ng th·ªÉ b·ªè ${validQuantityToDiscard} ${item.name}, b·∫°n ch·ªâ c√≥ ${currentQuantity}.`, "error");
         console.warn(`discardPurchasedItem: S·ªë l∆∞·ª£ng b·ªè (${validQuantityToDiscard}) > s·ªë l∆∞·ª£ng hi·ªán c√≥ (${currentQuantity}) cho ${itemId}.`);
         return;
    }

    // 4. Th·ª±c hi·ªán b·ªè v·∫≠t ph·∫©m
    gameState.inventory[itemId] -= validQuantityToDiscard;
    console.log(`ƒê√£ b·ªè ${validQuantityToDiscard} ${item.name}.`);

    // 5. X√≥a key n·∫øu s·ªë l∆∞·ª£ng v·ªÅ 0
    if (gameState.inventory[itemId] <= 0) {
        delete gameState.inventory[itemId];
        console.log(`ƒê√£ x√≥a h·∫øt ${item.name} (ID: ${itemId}) kh·ªèi kho ƒë√£ mua.`);
    } else {
        console.log(`C√≤n l·∫°i: ${gameState.inventory[itemId]} ${item.name}.`);
    }

    // 6. C·∫≠p nh·∫≠t UI v√† c√°c modal li√™n quan
    renderInventory(); // Quan tr·ªçng: C·∫≠p nh·∫≠t l·∫°i kho ƒë·ªì ngay l·∫≠p t·ª©c
    updateShopButtons(); // N·∫øu b·ªè thu·ªëc/ph√¢n b√≥n c√≥ th·ªÉ ·∫£nh h∆∞·ªüng shop
    if (seedSelectionModal.style.display === 'block' && item.type === 'seed') populateSeedSelection();
    if (fertilizerSelectionModal.style.display === 'block' && item.type === 'tool' && typeof item.fertilityBoost === 'number') populateFertilizerSelection();
    if (plantActionModal.style.display === 'block' && currentActionPlotId !== null) updatePlantActionModalButtons(currentActionPlotId);
    if (emptyPlotActionModal.style.display === 'block' && currentActionPlotId !== null) updateEmptyPlotActionModal(currentActionPlotId);

    // 7. Hi·ªÉn th·ªã th√¥ng b√°o
    showMessage(`ƒê√£ b·ªè ${validQuantityToDiscard} ${item.name} kh·ªèi t√∫i ƒë·ªì.`, "info");

    // 8. L∆∞u game
    saveGame();

    // 9. Log h√†nh ƒë·ªông - C·∫¨P NH·∫¨T CHI TI·∫æT LOG
    logAction('discard', null, `B·ªè t·ª´ kho: ${validQuantityToDiscard} ${item.name}.`, 'üóëÔ∏è', itemId);
}

		function handleDiscardPurchasedItemClick(event) {
    // S·ª≠ d·ª•ng event delegation: T√¨m n√∫t ".discard-purchased-button" g·∫ßn nh·∫•t v·ªõi ph·∫ßn t·ª≠ ƒë∆∞·ª£c click.
    const discardButton = event.target.closest('.discard-purchased-button');

    // N·∫øu kh√¥ng click v√†o n√∫t n√†y ho·∫∑c ph·∫ßn t·ª≠ cha c·ªßa n√≥, th√¨ b·ªè qua.
    if (!discardButton) {
        return;
    }

    console.log("[DEBUG] N√∫t 'B·ªè ƒëi...' ƒë√£ ƒë∆∞·ª£c click."); // Log khi n√∫t ƒë∆∞·ª£c click

    // T√¨m th·∫ª .item-card cha ƒë·ªÉ l·∫•y itemId
    const itemCard = discardButton.closest('.item-card');
    if (!itemCard) {
        console.error("[L·ªói] Kh√¥ng t√¨m th·∫•y th·∫ª '.item-card' cha c·ªßa n√∫t b·ªè v·∫≠t ph·∫©m.");
        return;
    }

    const itemId = itemCard.dataset.itemId;

    // Ki·ªÉm tra xem itemId c√≥ h·ª£p l·ªá v√† t·ªìn t·∫°i trong d·ªØ li·ªáu game kh√¥ng
    if (!itemId || !ITEM_DATA[itemId]) {
        console.error(`[L·ªói] Kh√¥ng t√¨m th·∫•y itemId h·ª£p l·ªá ('${itemId}') ho·∫∑c d·ªØ li·ªáu cho item n√†y trong ITEM_DATA.`);
        showMessage("L·ªói: Kh√¥ng th·ªÉ x√°c ƒë·ªãnh v·∫≠t ph·∫©m c·∫ßn b·ªè.", "error");
        return;
    }

    const item = ITEM_DATA[itemId];
    const currentQuantity = gameState.inventory[itemId] || 0; // L·∫•y s·ªë l∆∞·ª£ng hi·ªán c√≥ t·ª´ gameState

    console.log(`[DEBUG] Th√¥ng tin v·∫≠t ph·∫©m: ID=${itemId}, T√™n=${item.name}, S·ªë l∆∞·ª£ng hi·ªán c√≥=${currentQuantity}`);

    // Ki·ªÉm tra xem ng∆∞·ªùi ch∆°i c√≥ th·ª±c s·ª± c√≤n v·∫≠t ph·∫©m n√†y kh√¥ng
    if (currentQuantity <= 0) {
        showMessage(`B·∫°n kh√¥ng c√≤n ${item.name} ƒë·ªÉ b·ªè.`, "warning");
        console.warn(`[C·∫£nh b√°o] C·ªë g·∫Øng b·ªè '${itemId}' nh∆∞ng s·ªë l∆∞·ª£ng l√† ${currentQuantity}. C√≥ th·ªÉ giao di·ªán ch∆∞a c·∫≠p nh·∫≠t.`);
        // C·∫≠p nh·∫≠t l·∫°i giao di·ªán kho ƒë·ªì ph√≤ng tr∆∞·ªùng h·ª£p n√∫t v·∫´n hi·ªÉn th·ªã khi item ƒë√£ h·∫øt
        if (inventoryModal.style.display === 'block') {
            renderInventory();
        }
        return;
    }

    // X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n ·∫£nh icon (l·∫•y logic t·ª´ h√†m renderInventory ho·∫∑c populateShop)
    let iconSrc = 'Hinhanh/Caychet.png'; // Icon m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng t√¨m th·∫•y
    if (item.type === 'seed' && item.imageFolder) {
        iconSrc = `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
    } else if (item.type === 'tool' && item.imageFolder && item.imageFile) {
        iconSrc = `${item.imageFolder}/${item.imageFile}`;
    }
    console.log(`[DEBUG] ƒê∆∞·ªùng d·∫´n icon ƒë∆∞·ª£c x√°c ƒë·ªãnh: ${iconSrc}`);

    // N·∫øu m·ªçi th·ª© h·ª£p l·ªá, g·ªçi h√†m ƒë·ªÉ m·ªü popup x√°c nh·∫≠n
    console.log("[DEBUG] ƒêang g·ªçi h√†m openDiscardItemPopup...");
    openDiscardItemPopup(itemId, item.name, currentQuantity, iconSrc);

} // --- K·∫øt th√∫c h√†m handleDiscardPurchasedItemClick ---
function openDiscardItemPopup(itemId, itemName, currentQuantity, iconSrc) {
    console.log(`[DEBUG] --- B·∫Øt ƒë·∫ßu m·ªü Popup X√°c Nh·∫≠n B·ªè cho: ${itemName} (ID: ${itemId}) ---`);

    // 1. L·∫•y tham chi·∫øu ƒë·∫øn c√°c ph·∫ßn t·ª≠ DOM b√™n trong popup
    const popupElement = document.getElementById('discard-item-popup');
    const iconContainer = document.getElementById('discard-item-icon'); // Span ch·ª©a img
    const nameElement = document.getElementById('discard-item-name');
    const currentQuantityElement = document.getElementById('discard-current-quantity');
    const quantityInputElement = document.getElementById('discard-quantity-input');
    const confirmButton = document.getElementById('confirm-discard-btn');
    const errorElement = document.getElementById('discard-quantity-error'); // Span hi·ªÉn th·ªã l·ªói

    // 2. Ki·ªÉm tra nghi√™m ng·∫∑t xem t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ c·∫ßn thi·∫øt c√≥ t·ªìn t·∫°i kh√¥ng
    let domError = false;
    if (!popupElement) { console.error("[L·ªói DOM] Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ popup ch√≠nh #discard-item-popup!"); domError = true; }
    if (!iconContainer) { console.error("[L·ªói DOM] Kh√¥ng t√¨m th·∫•y container icon #discard-item-icon!"); domError = true; }
    if (!nameElement) { console.error("[L·ªói DOM] Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ t√™n #discard-item-name!"); domError = true; }
    if (!currentQuantityElement) { console.error("[L·ªói DOM] Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ s·ªë l∆∞·ª£ng hi·ªán t·∫°i #discard-current-quantity!"); domError = true; }
    if (!quantityInputElement) { console.error("[L·ªói DOM] Kh√¥ng t√¨m th·∫•y √¥ nh·∫≠p s·ªë l∆∞·ª£ng #discard-quantity-input!"); domError = true; }
    if (!confirmButton) { console.error("[L·ªói DOM] Kh√¥ng t√¨m th·∫•y n√∫t x√°c nh·∫≠n #confirm-discard-btn!"); domError = true; }
    if (!errorElement) { console.error("[L·ªói DOM] Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ b√°o l·ªói #discard-quantity-error!"); domError = true; }

    // N·∫øu c√≥ l·ªói t√¨m DOM, d·ª´ng l·∫°i v√† b√°o l·ªói
    if (domError) {
        showMessage("L·ªói giao di·ªán: Kh√¥ng th·ªÉ hi·ªÉn th·ªã h·ªôp tho·∫°i x√°c nh·∫≠n.", "error");
        return;
    }

    console.log("[DEBUG] ƒê√£ t√¨m th·∫•y t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ DOM c·∫ßn thi·∫øt c·ªßa popup.");

    // 3. T√¨m th·∫ª <img> b√™n trong container icon
    const iconImageElement = iconContainer.querySelector('img');
    if (!iconImageElement) {
        console.error("[L·ªói DOM] Kh√¥ng t√¨m th·∫•y th·∫ª <img> b√™n trong #discard-item-icon. H√£y ki·ªÉm tra l·∫°i c·∫•u tr√∫c HTML.");
        // C√¢n nh·∫Øc t·∫°o th·∫ª img n·∫øu mu·ªën linh ho·∫°t h∆°n, nh∆∞ng hi·ªán t·∫°i b√°o l·ªói v√† d·ª´ng
        return;
    }

    // 4. C·∫≠p nh·∫≠t n·ªôi dung popup v·ªõi th√¥ng tin v·∫≠t ph·∫©m
    iconImageElement.src = iconSrc;
    iconImageElement.alt = itemName; // C·∫≠p nh·∫≠t alt text
    // G·∫Øn onerror ƒë·ªÉ hi·ªÉn th·ªã icon l·ªói n·∫øu src kh√¥ng h·ª£p l·ªá
    iconImageElement.onerror = () => {
        console.warn(`[C·∫£nh b√°o] Kh√¥ng t·∫£i ƒë∆∞·ª£c icon t·ª´: ${iconSrc}. Hi·ªÉn th·ªã icon m·∫∑c ƒë·ªãnh.`);
        if (iconImageElement.src !== 'Hinhanh/Caychet.png') {
            iconImageElement.src = 'Hinhanh/Caychet.png';
        }
    };
    nameElement.textContent = itemName;             // ƒê·∫∑t t√™n v·∫≠t ph·∫©m
    currentQuantityElement.textContent = currentQuantity; // Hi·ªÉn th·ªã s·ªë l∆∞·ª£ng hi·ªán c√≥

    // 5. Thi·∫øt l·∫≠p √¥ nh·∫≠p s·ªë l∆∞·ª£ng
    quantityInputElement.value = 1;                 // Reset gi√° tr·ªã v·ªÅ 1
    quantityInputElement.min = 1;                   // S·ªë l∆∞·ª£ng t·ªëi thi·ªÉu l√† 1
    quantityInputElement.max = currentQuantity;     // S·ªë l∆∞·ª£ng t·ªëi ƒëa l√† s·ªë hi·ªán c√≥

    // 6. Reset tr·∫°ng th√°i l·ªói v√† n√∫t
    errorElement.textContent = '';                  // X√≥a th√¥ng b√°o l·ªói c≈©
    errorElement.style.display = 'none';            // ·∫®n v√πng b√°o l·ªói
    confirmButton.disabled = false;                 // B·∫≠t l·∫°i n√∫t x√°c nh·∫≠n (n·∫øu tr∆∞·ªõc ƒë√≥ b·ªã t·∫Øt)

    // 7. L∆∞u tr·ªØ itemId v√†o data attribute c·ªßa n√∫t x√°c nh·∫≠n
    // H√†m handleConfirmDiscardClick s·∫Ω ƒë·ªçc gi√° tr·ªã n√†y ƒë·ªÉ bi·∫øt c·∫ßn b·ªè item n√†o
    confirmButton.dataset.itemId = itemId;
    console.log(`[DEBUG] ƒê√£ g·∫Øn itemId '${itemId}' v√†o dataset c·ªßa n√∫t x√°c nh·∫≠n.`);

    // 8. Hi·ªÉn th·ªã popup
    console.log("[DEBUG] Chu·∫©n b·ªã hi·ªÉn th·ªã popup b·∫±ng c√°ch ƒë·∫∑t style.display = 'block'.");
    popupElement.style.display = 'block'; // Ho·∫∑c 'flex' t√πy v√†o CSS c·ªßa b·∫°n

    // 9. T√πy ch·ªçn: T·ª± ƒë·ªông focus v√†o √¥ nh·∫≠p s·ªë l∆∞·ª£ng ƒë·ªÉ ng∆∞·ªùi d√πng nh·∫≠p d·ªÖ h∆°n
    // D√πng setTimeout ƒë·ªÉ ƒë·∫£m b·∫£o tr√¨nh duy·ªát ƒë√£ render popup tr∆∞·ªõc khi focus
    setTimeout(() => {
        quantityInputElement.focus();
        console.log("[DEBUG] ƒê√£ focus v√†o √¥ nh·∫≠p s·ªë l∆∞·ª£ng.");
    }, 50); // Delay nh·ªè

    console.log("[DEBUG] --- Popup X√°c Nh·∫≠n B·ªè ƒë√£ ƒë∆∞·ª£c m·ªü th√†nh c√¥ng ---");

} // --- K·∫øt th√∫c h√†m openDiscardItemPopup ---





		/** X·ª≠ l√Ω click n√∫t "X√°c nh·∫≠n b·ªè" trong popup */
function handleConfirmDiscardClick() {
    if (!confirmDiscardBtn || !discardQuantityInput || !discardQuantityError) return;

    const itemId = confirmDiscardBtn.dataset.itemId;
    const quantityToDiscardStr = discardQuantityInput.value;
    const quantityToDiscard = parseInt(quantityToDiscardStr);
    const currentMax = parseInt(discardQuantityInput.max);

    // --- Validation ---
    let isValid = true;
    let errorMsg = '';

    if (!itemId) {
        errorMsg = 'L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c v·∫≠t ph·∫©m.';
        isValid = false;
    } else if (isNaN(quantityToDiscard) || quantityToDiscard < 1) {
        errorMsg = 'S·ªë l∆∞·ª£ng ph·∫£i l√† s·ªë l·ªõn h∆°n 0.';
        isValid = false;
    } else if (quantityToDiscard > currentMax) {
        errorMsg = `S·ªë l∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° ${currentMax}.`;
        isValid = false;
    }

    // --- Hi·ªÉn th·ªã l·ªói ho·∫∑c th·ª±c hi·ªán ---
    if (!isValid) {
        discardQuantityError.textContent = errorMsg;
        discardQuantityError.style.display = 'block';
        confirmDiscardBtn.disabled = true; // Disable n√∫t n·∫øu l·ªói
    } else {
        discardQuantityError.textContent = '';
        discardQuantityError.style.display = 'none';
        confirmDiscardBtn.disabled = false;

        // G·ªçi h√†m discard v·ªõi s·ªë l∆∞·ª£ng h·ª£p l·ªá
        discardPurchasedItem(itemId, quantityToDiscard);
        closeDiscardItemPopup(); // ƒê√≥ng popup sau khi th·ª±c hi·ªán
    }
}

// Th√™m listener ƒë·ªÉ b·∫≠t l·∫°i n√∫t Confirm khi ng∆∞·ªùi d√πng thay ƒë·ªïi input
if (discardQuantityInput) {
    discardQuantityInput.addEventListener('input', () => {
        if (confirmDiscardBtn) confirmDiscardBtn.disabled = false;
        if (discardQuantityError) {
             discardQuantityError.textContent = '';
             discardQuantityError.style.display = 'none';
        }
    });
     // Th√™m ki·ªÉm tra khi blur (m·∫•t focus) ƒë·ªÉ b·∫Øt l·ªói s·ªõm h∆°n
     discardQuantityInput.addEventListener('blur', () => {
        const quantityToDiscard = parseInt(discardQuantityInput.value);
        const currentMax = parseInt(discardQuantityInput.max);
        let errorMsg = '';
        if (isNaN(quantityToDiscard) || quantityToDiscard < 1) {
            errorMsg = 'S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0.';
        } else if (quantityToDiscard > currentMax) {
             errorMsg = `S·ªë l∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° ${currentMax}.`;
        }

        if (errorMsg) {
             discardQuantityError.textContent = errorMsg;
             discardQuantityError.style.display = 'block';
             if(confirmDiscardBtn) confirmDiscardBtn.disabled = true;
        } else {
             discardQuantityError.textContent = '';
             discardQuantityError.style.display = 'none';
             if(confirmDiscardBtn) confirmDiscardBtn.disabled = false;
        }
     });
}








        /** ƒêi·ªÅn v√†o modal ch·ªçn h·∫°t gi·ªëng d·ª±a tr√™n h·∫°t gi·ªëng c√≥ s·∫µn trong kho ƒê√É MUA. */
        function populateSeedSelection() {
            console.log("ƒêang ƒëi·ªÅn modal ch·ªçn h·∫°t gi·ªëng...");
            seedSelectionList.innerHTML = '';
            let availableSeedCount = 0;

            const availableSeedIds = Object.keys(gameState.inventory)
                .filter(itemId => {
                    const item = ITEM_DATA[itemId];
                    return item && item.type === 'seed' && gameState.inventory[itemId] > 0;
                })
                .sort((a, b) => (ITEM_DATA[a]?.price || 0) - (ITEM_DATA[b]?.price || 0));

            availableSeedIds.forEach(seedId => {
                availableSeedCount++;
                const item = ITEM_DATA[seedId];
                const quantity = gameState.inventory[seedId];
                const itemCard = document.createElement('div');
                itemCard.classList.add('item-card');

                 let iconSrc = item.imageFolder ? `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png` : 'Hinhanh/Caychet.png';
                 const imgTagSeed = `<img src="${iconSrc}" alt="${item.name}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
                 const iconHtml = `<span class="item-icon">${imgTagSeed}</span>`;

                itemCard.innerHTML = `
                    ${iconHtml}
                    <div class="item-name">${item.name}</div>
                    <div class="item-quantity">C√≥ s·∫µn (ƒë√£ mua): ${quantity}</div>
                    <div class="item-details" style="font-size: 0.7rem;">(L·ªõn: ${formatTime(item.growthTime * 1000, true)}, Hao: ${(item.fertilityCost*100).toFixed(0)}% ƒë·∫•t)</div>
                    <button class="plant-button" data-seed-id="${item.id}">Tr·ªìng H·∫°t N√†y</button>
                `;
                seedSelectionList.appendChild(itemCard);
            });

            seedSelectionEmptyMessage.style.display = availableSeedCount === 0 ? 'block' : 'none';
            seedSelectionList.style.display = availableSeedCount > 0 ? 'grid' : 'none';
            console.log(`Modal ch·ªçn h·∫°t gi·ªëng ƒë√£ ƒëi·ªÅn v·ªõi ${availableSeedCount} lo·∫°i h·∫°t (t·ª´ kho ƒë√£ mua).`);
        }

        /** X·ª≠ l√Ω click v√†o n√∫t tr·ªìng trong modal ch·ªçn h·∫°t gi·ªëng. */
        function handleSeedSelectionClick(event) {
            const plantButton = event.target.closest('.plant-button');
            if (plantButton) {
                const selectedSeedId = plantButton.dataset.seedId;
                if (currentPlantingPlotId !== null && gameState.plots[currentPlantingPlotId]) {
                    plantSeed(currentPlantingPlotId, selectedSeedId);
                    closeModal('seed-selection-modal');
                } else {
                    showMessage("L·ªói: Kh√¥ng th·ªÉ tr·ªìng, vui l√≤ng ch·ªçn l·∫°i √¥ ƒë·∫•t.", "error");
                    console.error("L·ªói logic: handleSeedSelectionClick kh√¥ng t√¨m th·∫•y currentPlantingPlotId h·ª£p l·ªá.");
                    closeModal('seed-selection-modal');
                    currentPlantingPlotId = null;
                }
            }
        }

         /** ƒêi·ªÅn v√†o modal ch·ªçn ph√¢n b√≥n d·ª±a tr√™n ph√¢n b√≥n c√≥ trong kho ƒê√É MUA. */
         function populateFertilizerSelection() {
            console.log("ƒêang ƒëi·ªÅn modal ch·ªçn ph√¢n b√≥n...");
            fertilizerSelectionList.innerHTML = '';
            let availableFertilizerCount = 0;

            // L·∫•y danh s√°ch ID ph√¢n b√≥n h·ª£p l·ªá t·ª´ kho
            const availableFertilizerIds = Object.keys(gameState.inventory)
                 .filter(itemId => {
                    const item = ITEM_DATA[itemId];
                    // ƒêi·ªÅu ki·ªán m·ªõi: l√† tool V√Ä (c√≥ fertilityBoost HO·∫∂C l√† fertilizer_growth HO·∫∂C l√† fertilizer_protect) V√Ä s·ªë l∆∞·ª£ng > 0
                    return item && item.type === 'tool' &&
                           (typeof item.fertilityBoost === 'number' || itemId === 'fertilizer_growth' || itemId === 'fertilizer_protect') &&
                           gameState.inventory[itemId] > 0;
                 })
                 .sort((a, b) => (ITEM_DATA[a]?.price || 0) - (ITEM_DATA[b]?.price || 0)); // S·∫Øp x·∫øp theo gi√°

             availableFertilizerIds.forEach(fertilizerId => {
                 availableFertilizerCount++;
                 const item = ITEM_DATA[fertilizerId];
                 const quantity = gameState.inventory[fertilizerId];
                 const itemCard = document.createElement('div');
                 itemCard.classList.add('item-card');

                 // L·∫•y icon
                 let iconSrc = (item.imageFolder && item.imageFile) ? `${item.imageFolder}/${item.imageFile}` : 'Hinhanh/Caychet.png';
                 const imgTagFert = `<img src="${iconSrc}" alt="${item.name}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
                 const iconHtml = `<span class="item-icon">${imgTagFert}</span>`;

                 // --- Hi·ªÉn th·ªã chi ti·∫øt d·ª±a tr√™n lo·∫°i ph√¢n b√≥n (ƒê√É C·∫¨P NH·∫¨T) ---
                 let detailsHtml = `<div class="item-details" style="font-size: 0.75rem;">`;
                 if (fertilizerId === 'fertilizer_growth') {
                    detailsHtml += `<div>‚è≥ L·ªõn: -5% TG</div>`;
                    detailsHtml += `<div>‚ù§Ô∏è S·ª©c kho·∫ª: +20%</div>`;
                    detailsHtml += `<div>üö´ T·ªëi ƒëa ${item.usageLimitPerPlant || 3} l·∫ßn/c√¢y</div>`;
                 } else if (fertilizerId === 'fertilizer_protect') { // <<< TH√äM CASE CHO B·∫¢O V·ªÜ >>>
                     detailsHtml += `<div>üí© Ph√¨: +${(item.fertilityBoost * 100).toFixed(0)}%</div>`;
                     detailsHtml += `<div>üõ°Ô∏è Gi·∫£m t·ªâ l·ªá s√¢u</div>`;
                     detailsHtml += `<div>üö´ T·ªëi ƒëa ${item.usageLimitPerPlant || 3} l·∫ßn/c√¢y</div>`;
                 } else if (typeof item.fertilityBoost === 'number') { // Ph√¢n b√≥n tƒÉng ph√¨ c≈©
                    detailsHtml += `<div>üí© Ph√¨: +${(item.fertilityBoost * 100).toFixed(0)}%</div>`;
                 } else { // Lo·∫°i tool kh√°c (n·∫øu c√≥)
                     detailsHtml += `<div>${item.description || 'C√¥ng c·ª•'}</div>`;
                 }
                 detailsHtml += `</div>`;
                 // --- K·∫øt Th√∫c Hi·ªÉn th·ªã chi ti·∫øt ---

                 // N√∫t S·ª≠ d·ª•ng
                 itemCard.innerHTML = `
                     ${iconHtml}
                     <div class="item-name">${item.name}</div>
                     <div class="item-quantity">C√≥ s·∫µn (ƒë√£ mua): ${quantity}</div>
                     ${detailsHtml}
                     <button class="use-button" data-fertilizer-id="${item.id}">B√≥n Ph√¢n N√†y</button>
                 `;
                 fertilizerSelectionList.appendChild(itemCard);
             });

             // Hi·ªÉn th·ªã th√¥ng b√°o tr·ªëng ho·∫∑c danh s√°ch
             fertilizerSelectionEmptyMessage.style.display = availableFertilizerCount === 0 ? 'block' : 'none';
             fertilizerSelectionList.style.display = availableFertilizerCount > 0 ? 'grid' : 'none';
             console.log(`Modal ch·ªçn ph√¢n b√≥n ƒë√£ ƒëi·ªÅn v·ªõi ${availableFertilizerCount} lo·∫°i (t·ª´ kho ƒë√£ mua).`);
         }


        /** C·∫≠p nh·∫≠t c√°c n√∫t v√† th√¥ng tin trong Modal H√†nh ƒê·ªông C√¢y Tr·ªìng */
		function updatePlantActionModalButtons(plotId) {
            // --- Ki·ªÉm tra ƒë·∫ßu v√†o v√† l·∫•y d·ªØ li·ªáu c∆° b·∫£n ---
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                console.warn(`updatePlantActionModalButtons ƒë∆∞·ª£c g·ªçi v·ªõi plotId kh√¥ng h·ª£p l·ªá: ${plotId}`);
                if (plantActionModal.style.display === 'block') { closeModal('plant-action-modal'); currentActionPlotId = null; }
                return;
            }
            const plotData = gameState.plots[plotId];
            const seedInfo = plotData.seedId ? ITEM_DATA[plotData.seedId] : null;
            if (!plotData.seedId || !seedInfo) {
                // N·∫øu kh√¥ng c√≥ c√¢y, kh√¥ng n√™n m·ªü modal n√†y, nh∆∞ng ƒë·ªÉ ph√≤ng l·ªói, ta ƒë√≥ng n√≥ l·∫°i.
                console.warn(`Modal h√†nh ƒë·ªông c√¢y ƒë∆∞·ª£c m·ªü cho √¥ ${plotId} kh√¥ng c√≥ c√¢y ho·∫∑c c√¢y l·ªói. ƒêang ƒë√≥ng.`);
                closeModal('plant-action-modal'); currentActionPlotId = null; return;
            }
            // <<< TH√äM: L·∫•y th√¥ng tin Ph√¢n B√≥n B·∫£o V·ªá >>>
            const itemProtect = ITEM_DATA['fertilizer_protect']; // L·∫•y th√¥ng tin c·∫•u h√¨nh item

            // --- L·∫•y th√¥ng tin giai ƒëo·∫°n, tr·∫°ng th√°i ƒë·∫•t v√† h√†ng r√†o ---
            const now = Date.now();
            const stageInfo = getPlantStageInfo(plotData, now);
            const isBarren = plotData.fertility <= 0;
            const isDry = plotData.isDry;
            const fenceData = plotData.fenceData; // L·∫•y d·ªØ li·ªáu h√†ng r√†o c·ªßa √¥ ƒë·∫•t hi·ªán t·∫°i
            const fenceItemInfo = ITEM_DATA.raobaove; // L·∫•y th√¥ng tin c·∫•u h√¨nh h√†ng r√†o t·ª´ ITEM_DATA

            // --- C·∫≠p nh·∫≠t Ti√™u ƒë·ªÅ Modal ---
            plantActionTitle.textContent = `ChƒÉm S√≥c ${seedInfo.name} (√î ${plotId + 1})`;

            // --- C·∫≠p nh·∫≠t Th√¥ng tin Hi·ªÉn th·ªã (bao g·ªìm c·∫£ h√†ng r√†o v√† buff b·∫£o v·ªá) ---
            let barrenPenaltyInfo = '';
            if (isBarren && plotData.barrenHarvestPenaltyFactor > 1.0) barrenPenaltyInfo = ` (M·ªçc ch·∫≠m x${plotData.barrenHarvestPenaltyFactor.toFixed(2)})`;
            else if (isBarren) barrenPenaltyInfo = ' (ƒê·∫•t C·∫∞N!)';
            let fertilityInfoStr = isBarren ? `ƒê·∫•t C·∫∞N!` : `ƒê·∫•t: ${Math.round(plotData.fertility)}%`;
            let dryInfoStr = isDry ? ' | üèúÔ∏è Kh√¥!' : '';
            let fenceInfoStr = ''; // Chu·ªói th√¥ng tin h√†ng r√†o
            if (fenceData) { // Ki·ªÉm tra xem c√≥ d·ªØ li·ªáu h√†ng r√†o kh√¥ng
                fenceInfoStr = fenceData.health > 0
                    ? ` | üöß R√†o: ${Math.round(fenceData.health)}%` // R√†o c√≤n t·ªët
                    : ' | üöß R√†o H·ªèng!'; // R√†o ƒë√£ h·ªèng
            }
            let infoStr = `HP: ${Math.round(plotData.health)}% | ${fertilityInfoStr}${barrenPenaltyInfo}${dryInfoStr}${fenceInfoStr}`; // Th√™m fenceInfoStr
            if (stageInfo && !stageInfo.isMature && !stageInfo.isDead) infoStr += ` | L·ªõn: ${Math.round(stageInfo.growthProgress * 100)}%`;
            if (plotData.hasPest) infoStr += ` | üêõ C√≥ s√¢u!`;
            if (stageInfo.isDead) {
                let deathReasonText = 'T·ª± nhi√™n/Kh√°c';
                if (plotData.causeOfDeath === 'pest') deathReasonText = 'Do s√¢u';
                else if (plotData.causeOfDeath === 'dryness') deathReasonText = 'Do kh√¥ h·∫°n';
                else if (plotData.causeOfDeath === 'lightning') deathReasonText = 'Do s√©t ƒë√°nh';
                else if (plotData.causeOfDeath === 'tornado') deathReasonText = 'Do gi√≥ l·ªëc';
                infoStr = `üíÄ C√¢y ƒë√£ ch·∫øt (${deathReasonText}) | ${fertilityInfoStr}${dryInfoStr}${fenceInfoStr}`; // Th√™m fenceInfoStr
            }

            // --- TH√äM TH√îNG TIN BUFF B·∫¢O V·ªÜ ---
            if (plotData.hasFertilizerProtectBuff && itemProtect) {
                 const limitProtect = itemProtect.usageLimitPerPlant || 3;
                 // Th√™m icon v√† s·ªë l·∫ßn ƒë√£ d√πng / gi·ªõi h·∫°n
                 infoStr += ` | üõ°Ô∏è(${plotData.fertilizerProtectUsageCount}/${limitProtect})`;
            }
            // --- K·∫æT TH√öC TH√äM ---

            plantActionInfo.textContent = infoStr; // G√°n chu·ªói cu·ªëi c√πng

            // --- L·∫•y s·ªë l∆∞·ª£ng v·∫≠t ph·∫©m trong kho ---
            const pesticideCount = gameState.inventory.pesticide || 0;
            let totalFertilizerCount = 0; // T·ªïng s·ªë l∆∞·ª£ng c√°c lo·∫°i ph√¢n b√≥n h·ª£p l·ªá
            // let hasFertilityBoostingFertilizer = false; // Kh√¥ng c·∫ßn c·ªù n√†y n·ªØa

            for (const itemId in gameState.inventory) {
                 const item = ITEM_DATA[itemId]; const quantity = gameState.inventory[itemId];
                 // Ch·ªâ t√≠nh c√°c lo·∫°i ph√¢n b√≥n h·ª£p l·ªá (tƒÉng ph√¨, tƒÉng tr∆∞·ªüng, b·∫£o v·ªá)
                 if (item && quantity > 0 && item.type === 'tool' &&
                     (typeof item.fertilityBoost === 'number' || itemId === 'fertilizer_growth' || itemId === 'fertilizer_protect'))
                 {
                     totalFertilizerCount += quantity;
                 }
            }
            const fenceCount = gameState.inventory.raobaove || 0; // L·∫•y s·ªë l∆∞·ª£ng R√†o b·∫£o v·ªá
            const hasFenceItem = fenceCount > 0; // Ki·ªÉm tra xem c√≥ R√†o b·∫£o v·ªá trong kho kh√¥ng
            const hasPesticide = pesticideCount > 0;
            // const hasAnyFertilizer = totalFertilizerCount > 0; // D√πng totalFertilizerCount > 0 thay th·∫ø

            // --- X√≥a c√°c n√∫t c≈© v√† t·∫°o l·∫°i ---
            plantActionButtonsContainer.innerHTML = '';

            // --- T·∫°o l·∫°i c√°c n√∫t theo th·ª© t·ª± logic ---

            // 1. N√∫t Thu ho·∫°ch / B√°n ngay (n·∫øu c√¢y ch√≠n, kh√¥ng s√¢u, kh√¥ng ch·∫øt)
            if (stageInfo && stageInfo.isMature && !plotData.hasPest && plotData.health > 0) {
                // N√∫t Thu Ho·∫°ch
                const harvestButton = document.createElement('button');
                harvestButton.id = 'action-harvest-plant';
                harvestButton.classList.add('action-button'); harvestButton.style.backgroundColor = '#4CAF50';
                harvestButton.textContent = `üß∫ Thu Ho·∫°ch (V√†o Kho)`; harvestButton.disabled = false;
                harvestButton.title = `Thu ho·∫°ch ${seedInfo.name}`; harvestButton.style.gridColumn = '1 / -1';
                plantActionButtonsContainer.appendChild(harvestButton);

                // N√∫t B√°n Ngay
                const sellNowButton = document.createElement('button');
                sellNowButton.id = 'action-sell-now'; sellNowButton.classList.add('action-button', 'sell-now');
                // T√≠nh gi√° b√°n d·ª±a tr√™n ch·∫•t l∆∞·ª£ng (m√°u)
                const qualityTierSell = getQualityTier(plotData.health);
                const valueMultiplierSell = qualityTierSell ? QUALITY_VALUE_MULTIPLIERS[qualityTierSell] : 0;
                const sellValue = Math.round(1 * (seedInfo.harvestYield || 0) * valueMultiplierSell);
                sellNowButton.textContent = `üí∞ B√°n Ngay (${sellValue}üí∞)`; sellNowButton.disabled = false;
                sellNowButton.title = `B√°n tr·ª±c ti·∫øp ${seedInfo.name} (+${sellValue}üí∞)`; sellNowButton.style.gridColumn = '1 / -1';
                plantActionButtonsContainer.appendChild(sellNowButton);
            }

            // 2. N√∫t Tr·ª´ S√¢u (n·∫øu c√≥ s√¢u, c√≥ thu·ªëc, c√¢y s·ªëng)
            const treatPestBtnNew = document.createElement('button');
            treatPestBtnNew.id = 'action-treat-pest';
            treatPestBtnNew.classList.add('action-button', 'treat-pest');
            treatPestBtnNew.textContent = `üíä Tr·ª´ S√¢u (${pesticideCount})`;
            treatPestBtnNew.disabled = !(plotData.hasPest && hasPesticide && plotData.health > 0);
            treatPestBtnNew.title = treatPestBtnNew.disabled ? ((!plotData.hasPest || plotData.health <=0) ? "C√¢y kh√¥ng c√≥ s√¢u ho·∫∑c ƒë√£ ch·∫øt" : `H·∫øt Thu·ªëc Tr·ª´ S√¢u (C√≥: ${pesticideCount})`) : `D√πng Thu·ªëc Tr·ª´ S√¢u (C√≥: ${pesticideCount})`;
            plantActionButtonsContainer.appendChild(treatPestBtnNew);

            // 3. N√∫t B√≥n Ph√¢n (n·∫øu c√≥ ph√¢n b√≥n, c√¢y s·ªëng) - B·ªè ki·ªÉm tra max ph√¨ ·ªü ƒë√¢y
            const selectFertilizerBtnNew = document.createElement('button');
            selectFertilizerBtnNew.id = 'action-select-fertilizer';
            selectFertilizerBtnNew.classList.add('action-button', 'select-fertilizer');
            selectFertilizerBtnNew.textContent = `üí© B√≥n Ph√¢n (${totalFertilizerCount})`; // Hi·ªÉn th·ªã t·ªïng c√°c lo·∫°i ph√¢n b√≥n
            // Disable n·∫øu kh√¥ng c√≥ lo·∫°i ph√¢n b√≥n n√†o HO·∫∂C c√¢y ch·∫øt
            selectFertilizerBtnNew.disabled = !(totalFertilizerCount > 0 && plotData.health > 0);
            // C·∫≠p nh·∫≠t title ƒë·ªÉ r√µ r√†ng h∆°n
            if (selectFertilizerBtnNew.disabled) {
                if (totalFertilizerCount <= 0) selectFertilizerBtnNew.title = `H·∫øt Ph√¢n B√≥n (C√≥: ${totalFertilizerCount})`;
                else selectFertilizerBtnNew.title = "Kh√¥ng b√≥n ph√¢n cho c√¢y ch·∫øt";
            } else {
                selectFertilizerBtnNew.title = `Ch·ªçn Ph√¢n B√≥n (C√≥: ${totalFertilizerCount})`;
            }
            plantActionButtonsContainer.appendChild(selectFertilizerBtnNew);

            // --- 4 & 5. LOGIC N√öT H√ÄNG R√ÄO (Gi·ªØ nguy√™n) ---
            if (!fenceData) {
                if (plotData.health > 0 && hasFenceItem) {
                    const addFenceBtn = document.createElement('button');
                    addFenceBtn.id = 'action-add-fence'; addFenceBtn.classList.add('action-button');
                    addFenceBtn.style.backgroundColor = '#009688';
                    addFenceBtn.textContent = `üöß Th√™m R√†o (${fenceCount})`;
                    addFenceBtn.title = `D√πng 1 R√†o b·∫£o v·ªá cho √¥ n√†y (C√≤n: ${fenceCount})`;
                    addFenceBtn.disabled = false;
                    plantActionButtonsContainer.appendChild(addFenceBtn);
                }
            } else {
                const removeFenceBtn = document.createElement('button');
                removeFenceBtn.id = 'action-remove-fence'; removeFenceBtn.classList.add('action-button');
                let removeCost = 0; let buttonText = "üóëÔ∏è G·ª° R√†o"; let buttonTitle = "G·ª° b·ªè h√†ng r√†o b·∫£o v·ªá kh·ªèi √¥ n√†y (Mi·ªÖn ph√≠)";
                let buttonColor = '#7f8c8d'; removeFenceBtn.disabled = false;
                if (fenceData.health <= 0) {
                    removeCost = fenceItemInfo?.removeCost || 5;
                    buttonText = `üóëÔ∏è G·ª° R√†o H·ªèng (${removeCost}üí∞)`;
                    buttonTitle = gameState.currency < removeCost ? `Kh√¥ng ƒë·ªß ti·ªÅn g·ª° r√†o h·ªèng (C·∫ßn ${removeCost}üí∞)` : `G·ª° b·ªè h√†ng r√†o ƒë√£ h·ªèng (T·ªën ${removeCost}üí∞)`;
                    buttonColor = '#e74c3c'; removeFenceBtn.disabled = gameState.currency < removeCost;
                }
                removeFenceBtn.textContent = buttonText; removeFenceBtn.title = buttonTitle;
                removeFenceBtn.style.backgroundColor = buttonColor; removeFenceBtn.dataset.removeCost = removeCost;
                plantActionButtonsContainer.appendChild(removeFenceBtn);
            }
            // --- K·∫æT TH√öC LOGIC N√öT H√ÄNG R√ÄO ---

            // 6. N√∫t T∆∞·ªõi N∆∞·ªõc (n·∫øu c√¢y kh√¥ v√† s·ªëng)
            const newWaterButton = document.createElement('button');
            newWaterButton.id = 'modal-content-Tuoinuoc'; // Gi·ªØ ID c≈© n·∫øu CSS d·ª±a v√†o n√≥
            newWaterButton.classList.add('action-button');
            newWaterButton.textContent = 'üíß T∆∞·ªõi N∆∞·ªõc';
            newWaterButton.disabled = !(isDry && plotData.health > 0);
            newWaterButton.title = (isDry && plotData.health > 0) ? 'T∆∞·ªõi n∆∞·ªõc cho c√¢y ƒëang b·ªã kh√¥ n√†y' : (plotData.health <= 0 ? 'Kh√¥ng th·ªÉ t∆∞·ªõi c√¢y ƒë√£ ch·∫øt' : 'C√¢y kh√¥ng c·∫ßn t∆∞·ªõi n∆∞·ªõc');
            plantActionButtonsContainer.appendChild(newWaterButton);

            // 7. N√∫t X·ªõi ƒê·∫•t / D·ªçn D·∫πp (Gi·ªØ nguy√™n logic ph·ª©c t·∫°p)
            const clearPlantBtnNew = document.createElement('button');
            clearPlantBtnNew.id = 'action-clear-plant';
            clearPlantBtnNew.classList.add('action-button', 'clear-plant');
            clearPlantBtnNew.disabled = false; // N√∫t n√†y lu√¥n b·∫≠t ƒë·ªÉ x·ª≠ l√Ω logic trong handleClearPlantAction
            let clearPlantTitle = "";
            clearPlantBtnNew.textContent = '‚õèÔ∏è X·ªõi ƒê·∫•t (B·ªè)'; // M·∫∑c ƒë·ªãnh
            clearPlantBtnNew.classList.remove('costly'); // Reset class costly

            if (plotData.health > 0) { // C√¢y ƒëang s·ªëng
                clearPlantTitle = "B·ªè c√¢y tr·ªìng n√†y ƒëi (Kh√¥ng thu ho·∫°ch ƒë∆∞·ª£c)";
            } else { // C√¢y ƒë√£ ch·∫øt
                if (plotData.causeOfDeath === 'pest') { // Ch·∫øt do s√¢u -> Ki·ªÉm tra ph√≠
                    const hasEnoughMoney = gameState.currency >= DEAD_PEST_CLEANUP_COST;
                    if (hasEnoughMoney) { // ƒê·ªß ti·ªÅn d·ªçn
                        clearPlantBtnNew.textContent = `‚õèÔ∏è D·ªçn S·∫°ch (${DEAD_PEST_CLEANUP_COST}üí∞)`;
                        clearPlantBtnNew.classList.add('costly');
                        clearPlantTitle = `D·ªçn √¥ ƒë·∫•t b·ªã s√¢u ph√° ho·∫°i (T·ªën ${DEAD_PEST_CLEANUP_COST}üí∞)`;
                    } else { // Kh√¥ng ƒë·ªß ti·ªÅn -> H∆∞·ªõng d·∫´n click
                        const clicksRemaining = DEAD_PEST_FREE_CLEANUP_CLICKS - (plotData.pestDeathClickCount || 0);
                        clearPlantBtnNew.textContent = `‚õèÔ∏è D·ªçn S·∫°ch (Click ${clicksRemaining} l·∫ßn)`;
                        clearPlantBtnNew.classList.add('costly'); // V·∫´n l√† costly v√¨ li√™n quan ƒë·∫øn s√¢u ch·∫øt
                        clearPlantTitle = `Kh√¥ng ƒë·ªß ti·ªÅn (${gameState.currency}/${DEAD_PEST_CLEANUP_COST}üí∞)! ƒê√≥ng c·ª≠a s·ªï, click √¥ ƒë·∫•t ${clicksRemaining} l·∫ßn ƒë·ªÉ d·ªçn mi·ªÖn ph√≠.`;
                        // C√≥ th·ªÉ c√¢n nh·∫Øc disable n√∫t n√†y lu√¥n khi kh√¥ng ƒë·ªß ti·ªÅn?
                        // clearPlantBtnNew.disabled = true; // T√πy ch·ªçn: Disable n√∫t n·∫øu kh√¥ng ƒë·ªß ti·ªÅn
                    }
                } else { // Ch·∫øt do nguy√™n nh√¢n kh√°c -> Mi·ªÖn ph√≠
                    clearPlantBtnNew.textContent = `‚õèÔ∏è D·ªçn C√¢y Ch·∫øt`;
                    clearPlantTitle = "D·ªçn c√¢y ƒë√£ ch·∫øt (Mi·ªÖn ph√≠)";
                }
            }
            clearPlantBtnNew.title = clearPlantTitle;
            plantActionButtonsContainer.appendChild(clearPlantBtnNew);

            // 8. N√∫t C·ª≠a H√†ng
            const shopButton = document.createElement('button');
            shopButton.id = 'action-open-shop';
            shopButton.classList.add('action-button'); shopButton.style.backgroundColor = '#ff9800';
            shopButton.textContent = 'üõí C·ª≠a H√†ng'; shopButton.title = 'M·ªü c·ª≠a h√†ng'; shopButton.disabled = false;
            plantActionButtonsContainer.appendChild(shopButton);

        } // --- K·∫øt th√∫c h√†m updatePlantActionModalButtons ---
	  
	  

         /** C·∫≠p nh·∫≠t modal h√†nh ƒë·ªông √¥ tr·ªëng */
          function updateEmptyPlotActionModal(plotId) {
             // --- Ki·ªÉm tra ƒë·∫ßu v√†o ---
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || gameState.plots[plotId].seedId || isPlotWithRod(plotId)) {
                 console.warn(`updateEmptyPlotActionModal ƒë∆∞·ª£c g·ªçi cho √¥ ${plotId} kh√¥ng h·ª£p l·ªá, c√≥ c√¢y ho·∫∑c c√≥ rod.`);
                  if (emptyPlotActionModal.style.display === 'block') {
                      closeModal('empty-plot-action-modal');
                      currentActionPlotId = null;
                  }
                 return;
             }
             const plotData = gameState.plots[plotId];
             const isBarren = plotData.fertility <= 0;
             const fenceData = plotData.fenceData; // L·∫•y d·ªØ li·ªáu h√†ng r√†o
             const fenceItemInfo = ITEM_DATA.raobaove; // L·∫•y th√¥ng tin c·∫•u h√¨nh h√†ng r√†o

             // --- C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ v√† th√¥ng tin √¥ ƒë·∫•t ---
             emptyPlotActionTitle.textContent = `√î ƒê·∫•t ${plotId + 1}`;
             let barrenPenaltyInfo = '';
             if (isBarren && plotData.barrenHarvestPenaltyFactor > 1.0) {
                 barrenPenaltyInfo = ` (Tr·ªìng c√¢y s·∫Ω m·ªçc ch·∫≠m x${plotData.barrenHarvestPenaltyFactor.toFixed(2)})`;
             } else if (isBarren) {
                  barrenPenaltyInfo = ' (C·∫∞N KI·ªÜT!)';
             }
             const fertilityText = isBarren ? `C·∫∞N KI·ªÜT 0%` : `${Math.round(plotData.fertility)}%`;
             const dryTextEmpty = plotData.isDry ? ' (Kh√¥!)' : '';
             // Th√™m th√¥ng tin h√†ng r√†o v√†o info
             let fenceInfoStrModal = '';
             if (fenceData) {
                  fenceInfoStrModal = fenceData.health > 0
                      ? ` | üöß R√†o: ${Math.round(fenceData.health)}%`
                      : ' | üöß R√†o H·ªèng!';
             }
             emptyPlotActionInfo.textContent = `ƒê·ªô ph√¨ nhi√™u: ${fertilityText}${barrenPenaltyInfo}${dryTextEmpty}${fenceInfoStrModal}`; // Th√™m fenceInfoStrModal

             // --- X√≥a c√°c n√∫t c≈© ---
             emptyPlotActionButtonsContainer.innerHTML = '';

             // --- T√≠nh to√°n s·ªë l∆∞·ª£ng v·∫≠t ph·∫©m c√≥ s·∫µn ---
             let availableSeedTypesCount = 0;
             let totalFertilizerCount = 0;
             let hasFertilityBoostingFertilizer = false;
             const hasLightningRodItem = (gameState.inventory[LIGHTNING_ROD_ITEM_ID] || 0) > 0;
             const fenceCount = gameState.inventory.raobaove || 0; // L·∫•y s·ªë l∆∞·ª£ng r√†o trong kho
             const hasFenceItem = fenceCount > 0; // Ki·ªÉm tra c√≥ r√†o trong kho kh√¥ng

             for (const itemId in gameState.inventory) {
                  const item = ITEM_DATA[itemId];
                  const quantity = gameState.inventory[itemId];
                  if (item && quantity > 0) {
                      if (item.type === 'seed') {
                          availableSeedTypesCount++;
                      } else if (item.type === 'tool') {
                           if (itemId === 'fertilizer_growth' || typeof item.fertilityBoost === 'number') {
                              totalFertilizerCount += quantity;
                           }
                           if (typeof item.fertilityBoost === 'number') {
                                hasFertilityBoostingFertilizer = true;
                           }
                      }
                  }
             }
             // -----------------------------------------------------------------

             // === [LOGIC ∆ØU TI√äN] KI·ªÇM TRA V√Ä TH√äM N√öT "G·ª† R√ÄO H·ªéNG" ===
             let brokenFenceButtonAdded = false;
             if (fenceData && fenceData.health <= 0 && fenceItemInfo) {
                 const removeCost = fenceItemInfo.removeCost || 5;
                 const canAfford = gameState.currency >= removeCost;

                 const removeBrokenFenceBtn = document.createElement('button');
                 removeBrokenFenceBtn.classList.add('action-button', 'remove-broken-fence');
                 removeBrokenFenceBtn.dataset.action = 'remove_broken_fence';
                 removeBrokenFenceBtn.dataset.plotId = plotId;
                 removeBrokenFenceBtn.dataset.cost = removeCost;
                 removeBrokenFenceBtn.innerHTML = `üóëÔ∏è G·ª° R√†o H·ªèng (${removeCost}üí∞)`;
                 removeBrokenFenceBtn.disabled = !canAfford;
                 removeBrokenFenceBtn.title = canAfford
                     ? `G·ª° b·ªè h√†ng r√†o ƒë√£ h·ªèng (T·ªën ${removeCost}üí∞)`
                     : `Kh√¥ng ƒë·ªß ti·ªÅn g·ª° r√†o h·ªèng (C·∫ßn ${removeCost}üí∞)`;

                 emptyPlotActionButtonsContainer.appendChild(removeBrokenFenceBtn);
                 brokenFenceButtonAdded = true;
             }
             // === K·∫æT TH√öC LOGIC KI·ªÇM TRA R√ÄO H·ªéNG ===

             // --- Th√™m c√°c n√∫t h√†nh ƒë·ªông kh√°c (Tr·ªìng, B√≥n, ƒê·∫∑t Rod, T∆∞·ªõi, Th√™m/G·ª° R√†o...) ---

             // N√∫t 1: Tr·ªìng c√¢y ho·∫∑c Mua h·∫°t gi·ªëng
             if (availableSeedTypesCount > 0) {
                 const plantBtn = document.createElement('button');
                 plantBtn.classList.add('action-button', 'plant'); plantBtn.dataset.action = 'plant'; plantBtn.dataset.plotId = plotId;
                 plantBtn.innerHTML = `üå± Tr·ªìng C√¢y (C√≥ ${availableSeedTypesCount} lo·∫°i)`; plantBtn.title = "Ch·ªçn h·∫°t gi·ªëng t·ª´ kho ƒë·ªÉ tr·ªìng";
                 emptyPlotActionButtonsContainer.appendChild(plantBtn);
             } else {
                  const buySeedBtn = document.createElement('button');
                  buySeedBtn.classList.add('action-button', 'shop'); buySeedBtn.dataset.action = 'shop_seed'; buySeedBtn.dataset.plotId = plotId;
                  buySeedBtn.innerHTML = 'üõí Mua H·∫°t Gi·ªëng'; buySeedBtn.title = "M·ªü c·ª≠a h√†ng mua h·∫°t gi·ªëng";
                  emptyPlotActionButtonsContainer.appendChild(buySeedBtn);
             }

             // N√∫t 2: B√≥n ph√¢n
             if (plotData.fertility < BASE_FERTILITY) {
                 const fertilizeBtn = document.createElement('button');
                 fertilizeBtn.classList.add('action-button', 'fertilize'); fertilizeBtn.dataset.action = 'fertilize'; fertilizeBtn.dataset.plotId = plotId;
                 fertilizeBtn.innerHTML = `üí© B√≥n Ph√¢n (C√≥ ${totalFertilizerCount})`;
                 fertilizeBtn.disabled = !hasFertilityBoostingFertilizer; // Ch·ªâ b·∫≠t n·∫øu c√≥ lo·∫°i ph√¢n tƒÉng ph√¨
                 fertilizeBtn.title = hasFertilityBoostingFertilizer ? `Ch·ªçn ph√¢n b√≥n tƒÉng ph√¨ (T·ªïng: ${totalFertilizerCount})` : `H·∫øt ph√¢n b√≥n tƒÉng ph√¨ (T·ªïng: ${totalFertilizerCount})`;
                 emptyPlotActionButtonsContainer.appendChild(fertilizeBtn);
             } else {
                  const infoText = document.createElement('p'); infoText.textContent = "(ƒê·∫•t ƒë√£ max ph√¨ nhi√™u)"; infoText.style.cssText = 'text-align: center; font-size: 0.8em; color: #3b7554; margin-top: 5px;';
                  emptyPlotActionButtonsContainer.appendChild(infoText);
             }

             // N√∫t 3: ƒê·∫∑t C·ªôt Thu L√¥i (Ch·ªâ hi·ªÉn th·ªã n·∫øu c√≥ v·∫≠t ph·∫©m)
             if (hasLightningRodItem) {
                 const placeRodBtn = document.createElement('button');
                 placeRodBtn.classList.add('action-button', 'place-rod'); placeRodBtn.dataset.action = 'place_rod'; placeRodBtn.dataset.plotId = plotId;
                 placeRodBtn.innerHTML = `‚ö° ƒê·∫∑t C·ªôt Thu L√¥i (${gameState.inventory[LIGHTNING_ROD_ITEM_ID] || 0})`;
                 placeRodBtn.disabled = false;
                 placeRodBtn.title = "ƒê·∫∑t c·ªôt thu l√¥i v√†o √¥ n√†y";
                 placeRodBtn.style.backgroundColor = '#607d8b';
                 emptyPlotActionButtonsContainer.appendChild(placeRodBtn);
             }

             // N√∫t 4: T∆∞·ªõi N∆∞·ªõc
             const waterButton = document.createElement('button');
             waterButton.id = 'modal-content-Tuoinuoc'; waterButton.classList.add('action-button');
             waterButton.textContent = 'üíß T∆∞·ªõi N∆∞·ªõc'; waterButton.disabled = !plotData.isDry;
             waterButton.title = plotData.isDry ? 'T∆∞·ªõi n∆∞·ªõc √¥ ƒë·∫•t kh√¥ n√†y' : '√î ƒë·∫•t kh√¥ng c·∫ßn t∆∞·ªõi.';
             waterButton.dataset.action = 'water_empty'; waterButton.dataset.plotId = plotId;
             emptyPlotActionButtonsContainer.appendChild(waterButton);

             // === [START] C·∫¨P NH·∫¨T LOGIC H√ÄNG R√ÄO ===
             // N√∫t 5: Th√™m R√†o (Ch·ªâ hi·ªÉn th·ªã n·∫øu CH∆ØA C√ì R√ÄO v√† C√ì ITEM trong kho)
             if (!fenceData && hasFenceItem) {
                 const addFenceBtn = document.createElement('button');
                 addFenceBtn.classList.add('action-button');
                 addFenceBtn.style.backgroundColor = '#009688'; // M√†u Teal
                 addFenceBtn.dataset.action = 'add_fence_empty';
                 addFenceBtn.dataset.plotId = plotId;
                 addFenceBtn.textContent = `üöß Th√™m R√†o (${fenceCount})`;
                 addFenceBtn.title = `D√πng 1 R√†o b·∫£o v·ªá cho √¥ n√†y (C√≤n: ${fenceCount})`;
                 addFenceBtn.disabled = false;
                 emptyPlotActionButtonsContainer.appendChild(addFenceBtn);
             }
             // N√∫t 6: G·ª° R√†o L√†nh L·∫∑n (Ch·ªâ hi·ªÉn th·ªã n·∫øu C√ì R√ÄO v√† KH√îNG B·ªä H·ªéNG)
             else if (fenceData && fenceData.health > 0) { // ƒêi·ªÅu ki·ªán l√† c√≥ r√†o v√† m√°u > 0
                 const removeHealthyFenceBtn = document.createElement('button');
                 removeHealthyFenceBtn.classList.add('action-button');
                 removeHealthyFenceBtn.style.backgroundColor = '#7f8c8d'; // M√†u x√°m trung t√≠nh
                 removeHealthyFenceBtn.dataset.action = 'remove_healthy_fence'; // Action m·ªõi ƒë·ªÉ ph√¢n bi·ªát
                 removeHealthyFenceBtn.dataset.plotId = plotId;
                 removeHealthyFenceBtn.dataset.cost = 0; // G·ª° r√†o l√†nh m·∫°nh l√† mi·ªÖn ph√≠
                 removeHealthyFenceBtn.textContent = 'üóëÔ∏è G·ª° R√†o (Mi·ªÖn ph√≠)';
                 removeHealthyFenceBtn.title = 'G·ª° b·ªè h√†ng r√†o b·∫£o v·ªá kh·ªèi √¥ n√†y (Mi·ªÖn ph√≠)';
                 removeHealthyFenceBtn.disabled = false;
                 emptyPlotActionButtonsContainer.appendChild(removeHealthyFenceBtn);
             }
             // === [END] C·∫¨P NH·∫¨T LOGIC H√ÄNG R√ÄO ===

         } // --- K·∫øt th√∫c h√†m updateEmptyPlotActionModal ---


        // --- C√°c H√†m H√†nh ƒê·ªông Ng∆∞·ªùi Ch∆°i ---
        // ==================================

        /** X·ª≠ l√Ω click trong danh s√°ch v·∫≠t ph·∫©m c·ª≠a h√†ng (·ªßy quy·ªÅn). */
        function handleShopItemClick(event) {
        console.log("[V10 Buy Fix handleShopItemClick] Click detected inside shop list. Target:", event.target);
        const target = event.target;

        // T√¨m n√∫t buy g·∫ßn nh·∫•t (d√πng class chung 'buy-button' r·ªìi ki·ªÉm tra data-item-id)
        const buyButton = target.closest('.buy-button[data-item-id]');

        // N·∫øu kh√¥ng click v√†o n√∫t buy ho·∫∑c n√∫t b·ªã disabled, b·ªè qua
        if (!buyButton) {
            console.log("[V10 Buy Fix handleShopItemClick] Click was not on a buy button with data-item-id.");
            return;
        }
        if (buyButton.disabled) {
            console.log("[V10 Buy Fix handleShopItemClick] Clicked a disabled buy button.");
            showMessage("Kh√¥ng th·ªÉ mua, n√∫t ƒëang b·ªã v√¥ hi·ªáu h√≥a (thi·∫øu ti·ªÅn, ƒëi·ªÅu ki·ªán ch∆∞a ƒë·ªß ho·∫∑c s·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá).", "warning");
            return;
        }

        const itemId = buyButton.dataset.itemId;
        console.log(`[V10 Buy Fix handleShopItemClick] Clicked Buy Button for itemId: ${itemId}`);

        // L·∫•y th√¥ng tin item
        const item = ITEM_DATA[itemId];
        if (!item) {
            console.error(`[V10 Buy Fix handleShopItemClick] Invalid item data for itemId: ${itemId}`);
            showMessage("L·ªói: V·∫≠t ph·∫©m kh√¥ng t·ªìn t·∫°i.", "error");
            return;
        }

        // T√¨m th·∫ª cha .item-card
        const itemCard = buyButton.closest('.item-card');
        if (!itemCard) {
            console.error(`[V10 Buy Fix handleShopItemClick] Could not find parent .item-card for button with itemId: ${itemId}`);
            return;
        }
         console.log(`[V10 Buy Fix handleShopItemClick] Found parent .item-card for ${itemId}.`);

        // X·ª≠ l√Ω d·ª±a tr√™n lo·∫°i n√∫t (Upgrade hay Seed/Tool)
        if (buyButton.classList.contains('buy-upgrade-button')) {
            console.log(`[V10 Buy Fix handleShopItemClick] Identified as UPGRADE button. Calling buyInventoryUpgrade...`);
            buyInventoryUpgrade(itemId); // H√†m x·ª≠ l√Ω n√¢ng c·∫•p ri√™ng
        }
        else if (buyButton.classList.contains('buy-seed-button')) { // Gi·∫£ ƒë·ªãnh seed v√† tool d√πng chung class n√†y
            console.log(`[V10 Buy Fix handleShopItemClick] Identified as SEED/TOOL button. Proceeding to get quantity...`);
            // T√¨m input s·ªë l∆∞·ª£ng b·∫±ng ID duy nh·∫•t
            const quantityInput = itemCard.querySelector(`#qty-${itemId}`);
             console.log(`[V10 Buy Fix handleShopItemClick] Found quantity input #qty-${itemId}:`, quantityInput);

            if (!quantityInput) {
                console.error(`[V10 Buy Fix handleShopItemClick] Could not find quantity input #qty-${itemId} for item type ${item.type}.`);
                // N·∫øu l√† tool/seed m√† kh√¥ng c√≥ input l√† l·ªói c·∫•u tr√∫c -> b√°o l·ªói
                showMessage("L·ªói giao di·ªán: Kh√¥ng t√¨m th·∫•y √¥ nh·∫≠p s·ªë l∆∞·ª£ng.", "error");
                return;
            }

            // L·∫•y v√† validate s·ªë l∆∞·ª£ng
            let quantity = parseInt(quantityInput.value);
            const maxQuantity = parseInt(quantityInput.max) || 99;
             console.log(`[V10 Buy Fix handleShopItemClick] Raw quantity value: '${quantityInput.value}', Parsed: ${quantity}, Max allowed: ${maxQuantity}`);

            if (isNaN(quantity) || quantity < 1) {
                console.warn(`[V10 Buy Fix handleShopItemClick] Invalid quantity (${quantityInput.value}), defaulting to 1.`);
                quantity = 1;
                quantityInput.value = 1; // S·ª≠a l·∫°i tr√™n UI
            } else if (quantity > maxQuantity) {
                console.warn(`[V10 Buy Fix handleShopItemClick] Quantity (${quantity}) exceeds max (${maxQuantity}), setting to max.`);
                quantity = maxQuantity;
                quantityInput.value = maxQuantity; // S·ª≠a l·∫°i tr√™n UI
            }

            console.log(`[V10 Buy Fix handleShopItemClick] Calling buyItem with itemId: ${itemId}, quantity: ${quantity}`);
            buyItem(itemId, quantity); // G·ªçi h√†m mua chung

        } else {
            console.warn(`[V10 Buy Fix handleShopItemClick] Buy button for ${itemId} doesn't have a recognized type class (buy-upgrade-button or buy-seed-button).`);
        }
    }

         /** X·ª≠ l√Ω thay ƒë·ªïi tr∆∞·ªùng input s·ªë l∆∞·ª£ng h·∫°t gi·ªëng (·ªßy quy·ªÅn) */
        function handleShopQuantityChange(event) {
        const target = event.target;
        // Ch·ªâ x·ª≠ l√Ω n·∫øu target l√† input s·ªë l∆∞·ª£ng ch√∫ng ta quan t√¢m
        if (target.classList.contains('seed-quantity-input') && target.id && target.id.startsWith('qty-')) {
            console.log(`[V10 Buy Fix handleShopQuantityChange] Quantity input changed for: ${target.id}`);
            const itemCard = target.closest('.item-card');
            const itemId = target.dataset.itemId; // L·∫•y itemId t·ª´ data attribute c·ªßa input
            if (itemCard && itemId) {
                 console.log(`[V10 Buy Fix handleShopQuantityChange] Calling updateSeedTotalCost for itemId: ${itemId}`);
                try {
                    updateSeedTotalCost(itemId, itemCard);
                } catch (e) {
                    console.error(`[V10 Buy Fix handleShopQuantityChange] Error calling updateSeedTotalCost:`, e);
                }
            } else {
                 console.warn(`[V10 Buy Fix handleShopQuantityChange] Could not find itemCard or itemId for input:`, target);
            }
        }
    }


         /** C·∫≠p nh·∫≠t t·ªïng chi ph√≠ hi·ªÉn th·ªã v√† tr·∫°ng th√°i n√∫t mua cho m·ªôt th·∫ª h·∫°t gi·ªëng */
         function updateSeedTotalCost(itemId, itemCardElement) {
        // console.log(`[V10 Buy Fix updateSeedTotalCost] Updating cost for itemId: ${itemId}`); // Gi·∫£m log ·ªü ƒë√¢y v√¨ g·ªçi nhi·ªÅu
        const item = ITEM_DATA[itemId];

        // Ki·ªÉm tra d·ªØ li·ªáu c∆° b·∫£n
        if (!item || !itemCardElement) {
            console.error(`[V10 Buy Fix updateSeedTotalCost] Error: Missing item data or itemCardElement for itemId: ${itemId}`);
            return;
        }
        // Ch·ªâ th·ª±c hi·ªán cho seed v√† tool c√≥ input s·ªë l∆∞·ª£ng
        if (item.type !== 'seed' && item.type !== 'tool') {
            // console.log(`[V10 Buy Fix updateSeedTotalCost] Skipping cost update for non-seed/tool item: ${itemId}`);
            return;
        }

        // T√¨m c√°c ph·∫ßn t·ª≠ con quan tr·ªçng
        const quantityInput = itemCardElement.querySelector(`#qty-${itemId}`);
        const totalCostElement = itemCardElement.querySelector(`#total-${itemId}`);
        const buyButton = itemCardElement.querySelector(`.buy-seed-button[data-item-id="${itemId}"]`); // D√πng class chung cho seed/tool

        // Ki·ªÉm tra s·ª± t·ªìn t·∫°i c·ªßa c√°c ph·∫ßn t·ª≠
        if (!quantityInput || !totalCostElement || !buyButton) {
            console.error(`[V10 Buy Fix updateSeedTotalCost] Error: Could not find required elements (input, total, button) for itemId: ${itemId} inside card.`);
            // L√†m n√∫t b·ªã disabled n·∫øu thi·∫øu th√†nh ph·∫ßn
            const anyButton = itemCardElement.querySelector('.buy-button');
            if(anyButton) anyButton.disabled = true;
            return;
        }

        // L·∫•y v√† x·ª≠ l√Ω s·ªë l∆∞·ª£ng
        let quantity = parseInt(quantityInput.value);
        const rawValue = quantityInput.value;
        const maxQuantity = parseInt(quantityInput.max) || 99;

        // Ch·ªâ t√≠nh to√°n n·∫øu quantity h·ª£p l·ªá, n·∫øu kh√¥ng th√¨ coi nh∆∞ quantity l√† 0 ho·∫∑c 1 ƒë·ªÉ disable n√∫t
        let validQuantityForCalc = 0; // M·∫∑c ƒë·ªãnh l√† 0 n·∫øu input kh√¥ng h·ª£p l·ªá
        let isInputInvalidOrEmpty = true; // M·∫∑c ƒë·ªãnh l√† kh√¥ng h·ª£p l·ªá

        if (!isNaN(quantity) && quantity >= 1 && quantity <= maxQuantity) {
             validQuantityForCalc = quantity;
             isInputInvalidOrEmpty = false; // H·ª£p l·ªá
        } else if (!isNaN(quantity) && quantity > maxQuantity) {
             validQuantityForCalc = maxQuantity; // D√πng max ƒë·ªÉ t√≠nh gi√° n·∫øu ng∆∞·ªùi d√πng nh·∫≠p qu√° cao
             isInputInvalidOrEmpty = false; // V·∫´n coi l√† h·ª£p l·ªá v·ªÅ m·∫∑t ƒë·ªãnh d·∫°ng s·ªë
        }
        // N·∫øu quantity < 1 ho·∫∑c NaN, validQuantityForCalc v·∫´n l√† 0, isInputInvalidOrEmpty l√† true

        // T√≠nh to√°n t·ªïng chi ph√≠ (d·ª±a tr√™n s·ªë l∆∞·ª£ng h·ª£p l·ªá)
        const totalCost = (item.price || 0) * validQuantityForCalc;
        // console.log(`[V10 Buy Fix updateSeedTotalCost] itemId: ${itemId}, validQuantity: ${validQuantityForCalc}, totalCost: ${totalCost}`);

        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng ti·ªÅn
        totalCostElement.textContent = `Gi√° b√°n: ${totalCost}üí∞`;

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t Mua
        const cannotAfford = gameState.currency < totalCost;
        buyButton.disabled = cannotAfford || isInputInvalidOrEmpty; // Disable n·∫øu kh√¥ng ƒë·ªß ti·ªÅn HO·∫∂C s·ªë l∆∞·ª£ng nh·∫≠p kh√¥ng h·ª£p l·ªá
        // console.log(`[V10 Buy Fix updateSeedTotalCost] itemId: ${itemId}, isInvalid: ${isInputInvalidOrEmpty}, cannotAfford: ${cannotAfford} -> disabled: ${buyButton.disabled}`);
    }


        /** X·ª≠ l√Ω click trong khu v·ª±c v∆∞·ªùn (·ª¶y quy·ªÅn s·ª± ki·ªán) */
       function handleGardenClick(event) {
         const clickedPlotElement = event.target.closest('.plot');
         if (!clickedPlotElement) return;
         const plotId = parseInt(clickedPlotElement.dataset.plotId);
         if (isNaN(plotId) || plotId < 0) { console.error("ID √¥ ƒë·∫•t click kh√¥ng h·ª£p l·ªá:", clickedPlotElement.dataset.plotId); return; }
         const isLocked = clickedPlotElement.classList.contains('locked');

         if (isLocked) {
             handleLockedPlotClick(plotId);
         } else if (isPlotWithRod(plotId)) { // <<< KI·ªÇM TRA N·∫æU L√Ä √î C√ì ROD
             handleLightningRodClick(plotId); // <<< G·ªåI H√ÄM X·ª¨ L√ù RI√äNG CHO ROD
         } else {
              // --- Ph·∫ßn x·ª≠ l√Ω √¥ kh√¥ng kh√≥a v√† kh√¥ng c√≥ rod (Gi·ªØ nguy√™n logic c≈©) ---
              const plotData = gameState.plots[plotId];
              if (!plotData) { console.error("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho √¥ ƒë·∫•t ID:", plotId); return; }
              // ∆Øu ti√™n x·ª≠ l√Ω click d·ªçn c√¢y ch·∫øt do s√¢u tr∆∞·ªõc
              if (plotData.seedId && plotData.health <= 0 && plotData.causeOfDeath === 'pest') {
                  handleDeadPlotClick(plotId, clickedPlotElement);
              }
              // N·∫øu kh√¥ng ph·∫£i ch·∫øt do s√¢u, ho·∫∑c tr·ªëng, ho·∫∑c ƒëang s·ªëng -> M·ªü modal
              else if (!plotData.seedId) { // √î tr·ªëng (v√† kh√¥ng c√≥ rod)
                  handleEmptyPlotClick(plotId);
              }
              else if (plotData.seedId) { // C√≥ c√¢y (s·ªëng ho·∫∑c ch·∫øt t·ª± nhi√™n/kh√¥/s√©t/l·ªëc - kh√¥ng ph·∫£i s√¢u) (v√† kh√¥ng c√≥ rod)
                   currentActionPlotId = plotId;
                   updatePlantActionModalButtons(plotId); // C·∫≠p nh·∫≠t modal tr∆∞·ªõc khi m·ªü
                   openModal('plant-action-modal');
              } else {
                  console.warn("Tr·∫°ng th√°i click √¥ ƒë·∫•t kh√¥ng ƒë∆∞·ª£c x·ª≠ l√Ω cho √¥:", plotId, plotData);
              }
         }
     
     }

        /** X·ª≠ l√Ω click v√†o √¥ ƒë·∫•t tr·ªëng ƒë√£ m·ªü kh√≥a -> M·ªü modal h√†nh ƒë·ªông √¥ tr·ªëng */
        function handleEmptyPlotClick(plotId) {
             const plot = gameState.plots[plotId];
             if (!plot || plotId >= gameState.maxUnlockedPlots || plot.seedId) { console.warn(`handleEmptyPlotClick ƒë∆∞·ª£c g·ªçi cho √¥ ${plotId} kh√¥ng tr·ªëng/b·ªã kh√≥a/kh√¥ng h·ª£p l·ªá.`); return; }
            currentActionPlotId = plotId;
            updateEmptyPlotActionModal(plotId);
            openModal('empty-plot-action-modal');

             if(plot.fertility <= 0) {
                 let barrenMsg = `√î ${plotId+1} ƒë·∫•t ƒë√£ C·∫∞N KI·ªÜT (0%)! C√¢y tr·ªìng s·∫Ω m·ªçc R·∫§T ch·∫≠m.`;
                 if (plot.barrenHarvestPenaltyFactor > 1.0) {
                     barrenMsg += ` (L·∫ßn t·ªõi x${plot.barrenHarvestPenaltyFactor.toFixed(2)})`;
                 }
                  barrenMsg += " H√£y b√≥n ph√¢n!";
                 setTimeout(() => showMessage(barrenMsg, "error", MESSAGE_DISPLAY_TIME * 1.5), 200);
             } else if(plot.fertility < LOW_FERTILITY_THRESHOLD) {
                 setTimeout(() => showMessage(`ƒê·∫•t √¥ ${plotId+1} kh√° c·∫±n (${Math.round(plot.fertility)}%), c√¢n nh·∫Øc b√≥n ph√¢n!`, "warning", MESSAGE_DISPLAY_TIME * 1.2), 200);
             }
        }

        /** X·ª≠ l√Ω click v√†o n√∫t trong modal h√†nh ƒë·ªông √¥ tr·ªëng (·ª¶y quy·ªÅn s·ª± ki·ªán) */
        function handleEmptyPlotActionClick(event) {
          const actionButton = event.target.closest('.action-button');
          if (!actionButton || actionButton.disabled) return;
          const action = actionButton.dataset.action;
          const plotId = parseInt(actionButton.dataset.plotId);

          if (isNaN(plotId)) {
              console.error("Kh√¥ng l·∫•y ƒë∆∞·ª£c plotId t·ª´ n√∫t h√†nh ƒë·ªông √¥ tr·ªëng.");
              closeModal('empty-plot-action-modal'); currentActionPlotId = null; return;
          }
          currentActionPlotId = plotId; // L∆∞u plotId ƒëang thao t√°c

          switch (action) {
              case 'plant':
                 selectPlotForPlanting(plotId); break;
              case 'fertilize':
                 openFertilizerSelectionModal(plotId); closeModal('empty-plot-action-modal'); break;
              case 'shop_seed':
                 switchShopTab('seeds'); openModal('shop-modal'); closeModal('empty-plot-action-modal'); currentActionPlotId = null; break;
              case 'place_rod':
                  placeLightningRod(plotId); closeModal('empty-plot-action-modal'); currentActionPlotId = null; break;
              case 'shop_tool':
                  switchShopTab('tools'); openModal('shop-modal'); closeModal('empty-plot-action-modal'); currentActionPlotId = null; break;
              case 'water_empty':
                 const plotToWater = gameState.plots[plotId];
                 if (plotToWater && !plotToWater.seedId && plotToWater.isDry) {
                     plotToWater.isDry = false; renderGarden(); saveGame();
                     showMessage(`ƒê√£ t∆∞·ªõi n∆∞·ªõc cho √¥ ƒë·∫•t tr·ªëng ${plotId + 1}.`, "success");
                     logAction('water_empty', plotId, `T∆∞·ªõi n∆∞·ªõc √¥ ƒë·∫•t tr·ªëng ${plotId + 1}.`, 'üíß', null);
                     closeModal('empty-plot-action-modal'); currentActionPlotId = null;
                 } else {
                     console.warn(`N√∫t t∆∞·ªõi √¥ tr·ªëng click cho √¥ ${plotId} kh√¥ng kh√¥ ho·∫∑c kh√¥ng tr·ªëng.`);
                     showMessage("√î ƒë·∫•t n√†y kh√¥ng c·∫ßn t∆∞·ªõi n∆∞·ªõc.", "info");
                     updateEmptyPlotActionModal(plotId); // C·∫≠p nh·∫≠t l·∫°i modal
                 }
                 break;
              case 'remove_broken_fence':
                 const costStr = actionButton.dataset.cost;
                 const costBroken = parseInt(costStr); // ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ tr√°nh tr√πng l·∫∑p
                 if (isNaN(costBroken) || costBroken < 0) {
                     console.error("Chi ph√≠ g·ª° r√†o h·ªèng kh√¥ng h·ª£p l·ªá:", costStr);
                     showMessage("L·ªói: Kh√¥ng th·ªÉ x√°c ƒë·ªãnh chi ph√≠ g·ª° r√†o.", "error");
                 } else {
                     removeFence(plotId, costBroken); // G·ªçi h√†m removeFence v·ªõi chi ph√≠
                 }
                 closeModal('empty-plot-action-modal');
                 currentActionPlotId = null;
                 break;
              case 'add_fence_empty':
                 addFence(plotId);
                 closeModal('empty-plot-action-modal');
                 currentActionPlotId = null;
                 break;

              // === [START] CASE M·ªöI CHO N√öT G·ª† R√ÄO L√ÄNH L·∫∂N ===
              case 'remove_healthy_fence':
                 const costHealthyStr = actionButton.dataset.cost; // L·∫•y chi ph√≠ t·ª´ n√∫t (s·∫Ω l√† 0)
                 let costHealthy = parseInt(costHealthyStr);
                 // Ki·ªÉm tra l·∫°i chi ph√≠, n·∫øu l·ªói th√¨ m·∫∑c ƒë·ªãnh l√† 0
                 if (isNaN(costHealthy) || costHealthy < 0) {
                     console.warn(`Chi ph√≠ g·ª° r√†o l√†nh l·∫∑n kh√¥ng h·ª£p l·ªá (${costHealthyStr}), ƒë·∫∑t v·ªÅ 0.`);
                     costHealthy = 0;
                 }
                 removeFence(plotId, costHealthy); // G·ªçi h√†m removeFence v·ªõi chi ph√≠ l√† 0
                 closeModal('empty-plot-action-modal'); // ƒê√≥ng modal
                 currentActionPlotId = null; // Reset ID
                 break;
              // === [END] CASE M·ªöI ===

              default:
                 console.warn("H√†nh ƒë·ªông √¥ tr·ªëng kh√¥ng x√°c ƒë·ªãnh:", action);
                 closeModal('empty-plot-action-modal'); currentActionPlotId = null;
          }
     } // --- K·∫øt th√∫c h√†m handleEmptyPlotActionClick ---


        /** M·ªü modal ch·ªçn ph√¢n b√≥n cho m·ªôt √¥ ƒë·∫•t c·ª• th·ªÉ */
         function openFertilizerSelectionModal(plotId) {
    // --- Ki·ªÉm tra ƒë·∫ßu v√†o c∆° b·∫£n (gi·ªØ nguy√™n) ---
    if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
        console.warn(`openFertilizerSelectionModal g·ªçi cho √¥ ${plotId} kh√¥ng h·ª£p l·ªá.`);
        currentActionPlotId = null;
        return;
    }
    const plot = gameState.plots[plotId];

    // --- Ki·ªÉm tra n·∫øu ƒë·∫•t ƒë√£ max ph√¨ nhi√™u (gi·ªØ nguy√™n) ---
    // L∆∞u √Ω: C√≥ th·ªÉ b·ªè qua ki·ªÉm tra n√†y n·∫øu Ph√¢n B√≥n TƒÉng Tr∆∞·ªüng kh√¥ng c·∫ßn ki·ªÉm tra max ph√¨
    // Tuy nhi√™n, gi·ªØ l·∫°i v·∫´n ·ªïn v√¨ n√≥ s·∫Ω ch·∫∑n c√°c lo·∫°i ph√¢n b√≥n tƒÉng ph√¨ kh√°c
    if (plot.fertility >= BASE_FERTILITY && !Object.keys(gameState.inventory).some(id => id === 'fertilizer_growth' && gameState.inventory[id] > 0)) {
         showMessage(`√î ƒë·∫•t ${plotId+1} ƒë√£ c√≥ ƒë·ªô ph√¨ nhi√™u t·ªëi ƒëa v√† b·∫°n kh√¥ng c√≥ Ph√¢n B√≥n TƒÉng Tr∆∞·ªüng!`, "info");
         if (plantActionModal.style.display === 'block') updatePlantActionModalButtons(plotId);
         if (emptyPlotActionModal.style.display === 'block') updateEmptyPlotActionModal(plotId);
         currentActionPlotId = null;
         return;
    }


    // --- S·ª¨A L·ªñI: Ki·ªÉm tra xem c√≥ b·∫•t k·ª≥ lo·∫°i ph√¢n b√≥n n√†o (tƒÉng ph√¨ HO·∫∂C tƒÉng tr∆∞·ªüng) ---
    const hasAnyFertilizer = Object.keys(gameState.inventory).some(itemId => {
        const item = ITEM_DATA[itemId];
        // ƒêi·ªÅu ki·ªán m·ªõi: l√† tool, V√Ä (c√≥ fertilityBoost HO·∫∂C l√† fertilizer_growth), V√Ä s·ªë l∆∞·ª£ng > 0
        return item && item.type === 'tool' &&
               (typeof item.fertilityBoost === 'number' || itemId === 'fertilizer_growth') && // <<< S·ª¨A L·ªñI ·ªû ƒê√ÇY
               gameState.inventory[itemId] > 0;
    });
    // --- K·∫æT TH√öC S·ª¨A L·ªñI ---

    // --- X·ª≠ l√Ω n·∫øu kh√¥ng c√≥ ph√¢n b√≥n n√†o (gi·ªØ nguy√™n) ---
    if (!hasAnyFertilizer) {
        showMessage("B·∫°n kh√¥ng c√≥ lo·∫°i ph√¢n b√≥n n√†o (trong kho ƒë√£ mua)! H√£y mua th√™m ·ªü c·ª≠a h√†ng.", "error");
        if (plantActionModal.style.display === 'block') closeModal('plant-action-modal');
        if (emptyPlotActionModal.style.display === 'block') closeModal('empty-plot-action-modal');
        switchShopTab('tools');
        openModal('shop-modal');
        currentActionPlotId = null;
        return;
    }

    // --- M·ªü modal ch·ªçn ph√¢n b√≥n (gi·ªØ nguy√™n) ---
    currentActionPlotId = plotId; // L∆∞u plotId ƒëang thao t√°c
    populateFertilizerSelection(); // ƒêi·ªÅn c√°c lo·∫°i ph√¢n b√≥n c√≥ s·∫µn
    openModal('fertilizer-selection-modal'); // M·ªü modal l·ª±a ch·ªçn
    // Kh√¥ng ƒë√≥ng modal g·ªëc ·ªü ƒë√¢y
}


        /** X·ª≠ l√Ω click trong Modal H√†nh ƒê·ªông C√¢y Tr·ªìng (·ª¶y quy·ªÅn s·ª± ki·ªán) */
       function handlePlantActionClick(event) {
    const actionButton = event.target.closest('.action-button');
    // Ph·∫£i c√≥ plotId ƒë√£ l∆∞u t·ª´ tr∆∞·ªõc (currentActionPlotId) v√† n√∫t ph·∫£i ƒë∆∞·ª£c enable
    if (!actionButton || currentActionPlotId === null || actionButton.disabled) {
        // console.log("[DEBUG handlePlantActionClick] Ignored click (no button, no plotId, or button disabled)."); // B·ªè comment n·∫øu c·∫ßn debug chi ti·∫øt
        return;
    }

    const plotId = currentActionPlotId; // L·∫•y plotId ƒë√£ l∆∞u t·ª´ khi m·ªü modal
    const actionId = actionButton.id; // L·∫•y ID c·ªßa n√∫t ƒë∆∞·ª£c click

    console.log(`[DEBUG handlePlantActionClick] Action button clicked! PlotId: ${plotId}, ActionId: ${actionId}`);

    const plotData = gameState.plots[plotId];
    // Ki·ªÉm tra plotData c∆° b·∫£n cho h·∫ßu h·∫øt c√°c h√†nh ƒë·ªông
    if (actionId !== 'action-open-shop' && (!plotData || plotId >= gameState.maxUnlockedPlots)) { // Ki·ªÉm tra c·∫£ plotId h·ª£p l·ªá
        console.warn(`[handlePlantActionClick] D·ªØ li·ªáu √¥ ƒë·∫•t ${plotId} cho h√†nh ƒë·ªông "${actionId}" kh√¥ng h·ª£p l·ªá ho·∫∑c √¥ ƒë·∫•t kh√¥ng t·ªìn t·∫°i.`);
        closeModal('plant-action-modal'); currentActionPlotId = null;
        return;
    }
    // Ki·ªÉm tra c√¢y tr·ªìng n·∫øu h√†nh ƒë·ªông y√™u c·∫ßu (Tr·ª´ Shop, Clear, Water, Add/Remove Fence)
    const actionsRequiringPlant = ['action-harvest-plant', 'action-sell-now', 'action-treat-pest', 'action-select-fertilizer'];
    if (actionsRequiringPlant.includes(actionId) && (!plotData || !plotData.seedId)) { // Th√™m ki·ªÉm tra plotData t·ªìn t·∫°i
        console.warn(`[handlePlantActionClick] √î ƒë·∫•t ${plotId} kh√¥ng c√≥ c√¢y tr·ªìng h·ª£p l·ªá cho h√†nh ƒë·ªông "${actionId}".`);
        closeModal('plant-action-modal'); currentActionPlotId = null;
        return;
    }

    // X·ª≠ l√Ω c√°c h√†nh ƒë·ªông
    switch (actionId) {
        case 'action-harvest-plant':
            console.log(`[DEBUG handlePlantActionClick] Harvest button clicked for plotId: ${plotId}. Calling harvestPlant...`); // Log tr∆∞·ªõc khi g·ªçi
            harvestPlant(plotId); // <<< G·ªåI H√ÄM THU HO·∫†CH >>>
            // ƒê√≥ng modal v√† reset plotId SAU KHI h√†m harvestPlant ƒë∆∞·ª£c g·ªçi (gi·∫£ ƒë·ªãnh n√≥ kh√¥ng b·ªã l·ªói ch·∫∑n)
            closeModal('plant-action-modal');
            currentActionPlotId = null;
            break; // <<< ƒê·∫£m b·∫£o c√≥ break >>>

        case 'action-sell-now':
            console.log(`[DEBUG handlePlantActionClick] Sell Now button clicked for plotId: ${plotId}. Calling sellPlantDirectly...`);
            sellPlantDirectly(plotId);
            closeModal('plant-action-modal'); currentActionPlotId = null;
            break;

        case 'action-treat-pest':
            console.log(`[DEBUG handlePlantActionClick] Treat Pest button clicked for plotId: ${plotId}. Calling treatPest...`);
            treatPest(plotId);
            // treatPest s·∫Ω t·ª± ƒë√≥ng modal v√† reset n·∫øu c·∫ßn m·ªü shop
            // N·∫øu kh√¥ng m·ªü shop, c·∫ßn ƒë√≥ng ·ªü ƒë√¢y
            if (plantActionModal.style.display === 'block') { // Ch·ªâ ƒë√≥ng n·∫øu treatPest kh√¥ng ƒë√≥ng n√≥
                 closeModal('plant-action-modal');
                 currentActionPlotId = null;
            }
            break;

        case 'action-select-fertilizer':
            console.log(`[DEBUG handlePlantActionClick] Select Fertilizer button clicked for plotId: ${plotId}. Opening selection modal...`);
            openFertilizerSelectionModal(plotId); // H√†m n√†y s·∫Ω l∆∞u plotId v√† m·ªü modal ch·ªçn
            closeModal('plant-action-modal'); // ƒê√≥ng modal h√†nh ƒë·ªông hi·ªán t·∫°i
            // currentActionPlotId kh√¥ng reset ·ªü ƒë√¢y, s·∫Ω reset sau khi ch·ªçn ph√¢n b√≥n ho·∫∑c ƒë√≥ng modal ch·ªçn
            break;

        case 'modal-content-Tuoinuoc':
            console.log(`[DEBUG handlePlantActionClick] Water Plant button clicked for plotId: ${plotId}.`);
            if (plotData && plotData.isDry && plotData.health > 0) {
                plotData.isDry = false;
                renderGarden();
                showMessage(`ƒê√£ t∆∞·ªõi n∆∞·ªõc cho ${ITEM_DATA[plotData.seedId]?.name || 'c√¢y'} ·ªü √¥ ${plotId + 1}!`, "success");
                saveGame();
                logAction('water', plotId, `ƒê√£ t∆∞·ªõi n∆∞·ªõc cho ${ITEM_DATA[plotData.seedId]?.name || 'c√¢y'}.`, 'üíß', plotData.seedId); // Th√™m seedId v√†o log
                closeModal('plant-action-modal'); currentActionPlotId = null;
            } else {
                console.warn(`[handlePlantActionClick] Water button clicked but plot ${plotId} not dry or plant dead.`);
                showMessage("C√¢y n√†y kh√¥ng c·∫ßn t∆∞·ªõi n∆∞·ªõc ho·∫∑c ƒë√£ ch·∫øt.", "info");
                if (plantActionModal.style.display === 'block') updatePlantActionModalButtons(plotId); // C·∫≠p nh·∫≠t l·∫°i n√∫t
            }
            break;

        case 'action-clear-plant':
            console.log(`[DEBUG handlePlantActionClick] Clear Plant button clicked for plotId: ${plotId}. Calling handleClearPlantAction...`);
            handleClearPlantAction(plotId); // H√†m n√†y s·∫Ω x·ª≠ l√Ω logic d·ªçn v√† ƒë√≥ng modal n·∫øu c·∫ßn
            break;

        case 'action-open-shop':
            console.log(`[DEBUG handlePlantActionClick] Open Shop button clicked.`);
            switchShopTab('seeds'); // M·∫∑c ƒë·ªãnh m·ªü tab h·∫°t gi·ªëng
            openModal('shop-modal');
            closeModal('plant-action-modal'); currentActionPlotId = null;
            break;

        case 'action-add-fence':
             console.log(`[DEBUG handlePlantActionClick] Add Fence button clicked for plotId: ${plotId}.`);
             addFence(plotId);
             closeModal('plant-action-modal'); currentActionPlotId = null;
             break;

        case 'action-remove-fence':
             console.log(`[DEBUG handlePlantActionClick] Remove Fence button clicked for plotId: ${plotId}.`);
             const costToRemove = parseInt(actionButton.dataset.removeCost || '0');
             removeFence(plotId, costToRemove);
             closeModal('plant-action-modal'); currentActionPlotId = null;
             break;

        default:
            console.warn("[handlePlantActionClick] Unknown action button clicked:", actionId);
            closeModal('plant-action-modal'); currentActionPlotId = null; // ƒê√≥ng modal n·∫øu kh√¥ng r√µ h√†nh ƒë·ªông
    }
}

		function addFence(plotId) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) return;
            const plot = gameState.plots[plotId];
            const fenceItem = ITEM_DATA.raobaove;

            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán
           // if (!plot.seedId || plot.health <= 0) {
           //     showMessage("Ch·ªâ c√≥ th·ªÉ th√™m r√†o cho c√¢y ƒëang s·ªëng.", "warning"); return;
           // }
            if (plot.fenceData) {
                showMessage("√î n√†y ƒë√£ c√≥ r√†o b·∫£o v·ªá r·ªìi.", "info"); return;
            }
            if (!fenceItem) {
                showMessage("L·ªói: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu v·∫≠t ph·∫©m R√†o b·∫£o v·ªá.", "error"); return;
            }
            const fenceCount = gameState.inventory.raobaove || 0;
            if (fenceCount <= 0) {
                showMessage("B·∫°n ƒë√£ h·∫øt R√†o b·∫£o v·ªá trong kho!", "error");
                return;
            }

            // --- Th·ª±c hi·ªán th√™m r√†o ---
            gameState.inventory.raobaove--; // Tr·ª´ kh·ªèi kho
            plot.fenceData = {
                id: 'raobaove',
                health: fenceItem.health // ƒê·∫∑t m√°u t·ªëi ƒëa ban ƒë·∫ßu
            };

            // C·∫≠p nh·∫≠t UI v√† L∆∞u game
            renderGarden(); // V·∫Ω l·∫°i v∆∞·ªùn ƒë·ªÉ hi·ªán r√†o
            if (inventoryModal.style.display === 'block') renderInventory(); // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng trong kho
            saveGame();

            showMessage(`ƒê√£ th√™m R√†o b·∫£o v·ªá cho √¥ ${plotId + 1}!`, "success");
            logAction('add_fence', plotId, `Th√™m R√†o b·∫£o v·ªá v√†o √¥ ${plotId + 1}.`, 'üöß', 'raobaove');
        }
		
		function removeFence(plotId, costToRemove) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) return;
            const plot = gameState.plots[plotId];

            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán c∆° b·∫£n: Ph·∫£i c√≥ h√†ng r√†o
            if (!plot.fenceData) {
                showMessage("√î n√†y kh√¥ng c√≥ h√†ng r√†o ƒë·ªÉ g·ª°.", "warning"); return;
            }
            const isBroken = plot.fenceData.health <= 0;
            const fenceItem = ITEM_DATA.raobaove; // L·∫•y th√¥ng tin c·∫•u h√¨nh r√†o (kh√¥ng b·∫Øt bu·ªôc nh∆∞ng t·ªët ƒë·ªÉ log)

            // Ki·ªÉm tra xem chi ph√≠ truy·ªÅn v√†o c√≥ h·ª£p l·ªá kh√¥ng
            const actualCost = parseInt(costToRemove);
            if (isNaN(actualCost) || actualCost < 0) {
                 console.error(`Chi ph√≠ g·ª° r√†o kh√¥ng h·ª£p l·ªá: ${costToRemove}`);
                 showMessage("L·ªói: Kh√¥ng th·ªÉ x√°c ƒë·ªãnh chi ph√≠ g·ª° r√†o.", "error");
                 return;
            }

            // Ki·ªÉm tra ti·ªÅn n·∫øu c√≥ chi ph√≠
            if (actualCost > 0 && gameState.currency < actualCost) {
                showMessage(`Kh√¥ng ƒë·ªß ti·ªÅn g·ª° r√†o! C·∫ßn ${actualCost}üí∞.`, "error"); return;
            }

            // --- Th·ª±c hi·ªán g·ª° b·ªè ---
            if (actualCost > 0) {
                gameState.currency -= actualCost; // Tr·ª´ ph√≠ n·∫øu c√≥
            }
            plot.fenceData = null; // X√≥a d·ªØ li·ªáu h√†ng r√†o

            // C·∫≠p nh·∫≠t UI v√† L∆∞u game
            renderUI(); // C·∫≠p nh·∫≠t ti·ªÅn
            renderGarden(); // V·∫Ω l·∫°i v∆∞·ªùn
            saveGame();

            // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
            let successMessage = `ƒê√£ g·ª° b·ªè h√†ng r√†o ${isBroken ? 'h·ªèng ' : ''}·ªü √¥ ${plotId + 1}`;
            if (actualCost > 0) {
                 successMessage += ` (-${actualCost}üí∞).`;
            } else {
                 successMessage += ` (Mi·ªÖn ph√≠).`;
            }
            showMessage(successMessage, "success");

            // Log h√†nh ƒë·ªông
            const logIcon = isBroken ? 'üóëÔ∏èüöß' : 'üöß‚ûñ'; // Icon kh√°c nhau cho g·ª° h·ªèng v√† g·ª° l√†nh
            let logDetails = `G·ª° b·ªè R√†o b·∫£o v·ªá ${isBroken ? 'h·ªèng ' : ''}·ªü √¥ ${plotId + 1}`;
            if (actualCost > 0) logDetails += ` (-${actualCost}üí∞).`;
            else logDetails += ` (Mi·ªÖn ph√≠).`;
            logAction('remove_fence', plotId, logDetails, logIcon, 'raobaove');
        }

		

        /** [M·ªöI] H√†nh ƒë·ªông: G·ª° b·ªè h√†ng r√†o b·ªã h·ªèng (t·ªën ph√≠). */
        function removeBrokenFence(plotId) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) return;
            const plot = gameState.plots[plotId];
            const fenceItem = ITEM_DATA.raobaove;

            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán
            if (!plot.fenceData || plot.fenceData.health > 0) {
                showMessage("H√†ng r√†o n√†y kh√¥ng b·ªã h·ªèng ho·∫∑c kh√¥ng t·ªìn t·∫°i.", "warning"); return;
            }
            if (!fenceItem) {
                showMessage("L·ªói: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu v·∫≠t ph·∫©m R√†o b·∫£o v·ªá.", "error"); return;
            }
            const removeCost = fenceItem.removeCost || 5;
            if (gameState.currency < removeCost) {
                showMessage(`Kh√¥ng ƒë·ªß ti·ªÅn g·ª° r√†o! C·∫ßn ${removeCost}üí∞.`, "error"); return;
            }

            // --- Th·ª±c hi·ªán g·ª° b·ªè ---
            gameState.currency -= removeCost; // Tr·ª´ ph√≠
            plot.fenceData = null; // X√≥a d·ªØ li·ªáu h√†ng r√†o

            // C·∫≠p nh·∫≠t UI v√† L∆∞u game
            renderUI(); // C·∫≠p nh·∫≠t ti·ªÅn
            renderGarden(); // V·∫Ω l·∫°i v∆∞·ªùn
            updatePlantActionModalButtons(plotId); // C·∫≠p nh·∫≠t l·∫°i modal n·∫øu c√≤n m·ªü
            saveGame();

            showMessage(`ƒê√£ g·ª° b·ªè h√†ng r√†o h·ªèng ·ªü √¥ ${plotId + 1} (-${removeCost}üí∞).`, "success");
            logAction('remove_fence', plotId, `G·ª° b·ªè R√†o b·∫£o v·ªá h·ªèng ·ªü √¥ ${plotId + 1} (-${removeCost}üí∞).`, 'üóëÔ∏èüöß', 'raobaove');
        }





        /** X·ª≠ l√Ω h√†nh ƒë·ªông 'D·ªçn C√¢y', bao g·ªìm x√°c nh·∫≠n v√† ki·ªÉm tra chi ph√≠ ho·∫∑c click mi·ªÖn ph√≠ */
         function handleClearPlantAction(plotId) {
            // 1. Ki·ªÉm tra ƒë·∫ßu v√†o c∆° b·∫£n
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                console.error(`handleClearPlantAction: plotId kh√¥ng h·ª£p l·ªá: ${plotId}`);
                // ƒê√≥ng modal n·∫øu ƒëang m·ªü v√† c√≥ l·ªói
                if (plantActionModal.style.display === 'block') {
                    closeModal('plant-action-modal');
                    currentActionPlotId = null;
                }
                return;
            }
            const plotData = gameState.plots[plotId];

            // 2. Ki·ªÉm tra xem c√≥ th·ª±c s·ª± c√≥ c√¢y ƒë·ªÉ d·ªçn kh√¥ng (ph√≤ng tr∆∞·ªùng h·ª£p logic l·ªói)
            if (!plotData.seedId) {
                console.warn(`handleClearPlantAction ƒë∆∞·ª£c g·ªçi cho √¥ ${plotId} nh∆∞ng kh√¥ng c√≥ c√¢y ƒë·ªÉ d·ªçn.`);
                // C√≥ th·ªÉ ƒë√≥ng modal ho·∫∑c c·∫≠p nh·∫≠t l·∫°i
                closeModal('plant-action-modal');
                currentActionPlotId = null;
                return;
            }

            // 3. L·∫•y th√¥ng tin c·∫ßn thi·∫øt
            const plantName = ITEM_DATA[plotData.seedId]?.name || 'c√¢y'; // L·∫•y t√™n c√¢y, fallback 'c√¢y'
            const isDead = plotData.health <= 0;
            const needsCost = isDead && plotData.causeOfDeath === 'pest'; // Ch·ªâ t·ªën ph√≠ khi ch·∫øt do s√¢u
            const canPay = gameState.currency >= DEAD_PEST_CLEANUP_COST;
            let confirmMsg = '';

            // 4. X√¢y d·ª±ng th√¥ng b√°o x√°c nh·∫≠n
            if (needsCost) { // Tr∆∞·ªùng h·ª£p ch·∫øt do s√¢u
                if (canPay) { // C√≥ ƒë·ªß ti·ªÅn tr·∫£ ph√≠
                    confirmMsg = `D·ªçn ${plantName} ch·∫øt do s√¢u ·ªü √¥ ${plotId + 1} t·ªën ${DEAD_PEST_CLEANUP_COST}üí∞. B·∫°n c√≥ ch·∫Øc?`;
                } else { // Kh√¥ng ƒë·ªß ti·ªÅn, h∆∞·ªõng d·∫´n click
                    const clicksRemaining = DEAD_PEST_FREE_CLEANUP_CLICKS - (plotData.pestDeathClickCount || 0);
                    // S·ª≠ d·ª•ng \n ƒë·ªÉ xu·ªëng d√≤ng trong alert/confirm
                    confirmMsg = `B·∫°n kh√¥ng ƒë·ªß ti·ªÅn (${gameState.currency}/${DEAD_PEST_CLEANUP_COST}üí∞) ƒë·ªÉ d·ªçn √¥ n√†y!\nH√£y ƒë√≥ng c·ª≠a s·ªï n√†y v√† click tr·ª±c ti·∫øp v√†o √¥ ƒë·∫•t ${clicksRemaining} l·∫ßn ƒë·ªÉ d·ªçn mi·ªÖn ph√≠.`;
                    // Hi·ªÉn th·ªã th√¥ng b√°o n√†y b·∫±ng showMessage v√¨ confirm() kh√¥ng hi·ªÉn th·ªã ƒë·∫πp \n
                    showMessage(confirmMsg, "warning", MESSAGE_DISPLAY_TIME * 2.5); // K√©o d√†i th·ªùi gian hi·ªÉn th·ªã
                    // ƒê√≥ng modal h√†nh ƒë·ªông ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ click tr·ª±c ti·∫øp v√†o √¥ ƒë·∫•t
                    closeModal('plant-action-modal');
                    currentActionPlotId = null;
                    return; // D·ª´ng l·∫°i, kh√¥ng hi·ªÉn th·ªã confirm()
                }
            } else if (isDead) { // Ch·∫øt do nguy√™n nh√¢n kh√°c (kh√¥ng ph·∫£i s√¢u)
                confirmMsg = `D·ªçn ${plantName} ƒë√£ ch·∫øt (t·ª± nhi√™n/kh√°c) ·ªü √¥ ${plotId + 1}? (Mi·ªÖn ph√≠)`;
            } else { // C√¢y ƒëang s·ªëng
                confirmMsg = `B·∫°n c√≥ ch·∫Øc mu·ªën x·ªõi b·ªè ${plantName} ƒëang s·ªëng ·ªü √¥ ${plotId + 1} kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c v√† s·∫Ω kh√¥ng thu ho·∫°ch ƒë∆∞·ª£c g√¨.`;
            }

            // 5. Hi·ªÉn th·ªã h·ªôp tho·∫°i x√°c nh·∫≠n v√† x·ª≠ l√Ω k·∫øt qu·∫£
            // Ch·ªâ hi·ªÉn th·ªã confirm n·∫øu kh√¥ng ph·∫£i tr∆∞·ªùng h·ª£p kh√¥ng ƒë·ªß ti·ªÅn d·ªçn s√¢u ch·∫øt
            if (confirm(confirmMsg)) {
                // Ng∆∞·ªùi d√πng nh·∫•n OK
                if (needsCost && canPay) { // Tr∆∞·ªùng h·ª£p t·ªën ph√≠ d·ªçn s√¢u v√† ƒë·ªß ti·ªÅn
                    gameState.currency -= DEAD_PEST_CLEANUP_COST; // Tr·ª´ ti·ªÅn
                    renderUI(); // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ti·ªÅn
                    showMessage(`ƒê√£ chi ${DEAD_PEST_CLEANUP_COST}üí∞ ƒë·ªÉ d·ªçn √¥ ƒë·∫•t ${plotId+1} b·ªã s√¢u ph√° ho·∫°i.`, "info");
                    // --- G·ªåI H√ÄM M·ªöI ---
                    clearPlantOnly(plotId); // Ch·ªâ x√≥a c√¢y, gi·ªØ h√†ng r√†o
                    // --------------------
                } else if (!needsCost) { // Tr∆∞·ªùng h·ª£p d·ªçn c√¢y ch·∫øt t·ª± nhi√™n ho·∫∑c c√¢y ƒëang s·ªëng (ƒë√£ x√°c nh·∫≠n)
                    // --- G·ªåI H√ÄM M·ªöI ---
                    clearPlantOnly(plotId); // Ch·ªâ x√≥a c√¢y, gi·ªØ h√†ng r√†o
                    // --------------------
                }
                 // ƒê√≥ng modal sau khi th·ª±c hi·ªán h√†nh ƒë·ªông th√†nh c√¥ng (ho·∫∑c ƒë√£ x√°c nh·∫≠n)
                 // Kh√¥ng c·∫ßn ƒë√≥ng l·∫°i ·ªü ƒë√¢y v√¨ clearPlantOnly ƒë√£ l√†m ƒëi·ªÅu ƒë√≥
                 // closeModal('plant-action-modal'); // D√≤ng n√†y c√≥ th·ªÉ b·ªè n·∫øu clearPlantOnly lu√¥n ƒë√≥ng
                 // currentActionPlotId = null; // clearPlantOnly c≈©ng ƒë√£ reset
            } else {
                // Ng∆∞·ªùi d√πng nh·∫•n Cancel
                console.log(`Ng∆∞·ªùi d√πng ƒë√£ h·ªßy h√†nh ƒë·ªông d·ªçn c√¢y √¥ ${plotId + 1}.`);
                // Kh√¥ng c·∫ßn ƒë√≥ng modal ·ªü ƒë√¢y, ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ ch·ªçn h√†nh ƒë·ªông kh√°c
            }
         } // --- K·∫øt th√∫c h√†m handleClearPlantAction ---

         /** H√†nh ƒë·ªông: D·ªçn s·∫°ch m·ªôt √¥ ƒë·∫•t, reset tr·∫°ng th√°i c√¢y tr·ªìng v√† c√°c thu·ªôc t√≠nh li√™n quan. */
        function clearPlot(plotId) {
             // 1. Ki·ªÉm tra ƒë·∫ßu v√†o
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                 console.warn(`C·ªë g·∫Øng d·ªçn √¥ kh√¥ng h·ª£p l·ªá/b·ªã kh√≥a ${plotId}.`);
                 return;
             }
             const plot = gameState.plots[plotId];

             // 2. L∆∞u tr·ªØ th√¥ng tin *tr∆∞·ªõc* khi reset ƒë·ªÉ log v√† hi·ªÉn th·ªã th√¥ng b√°o
             const wasPlanted = !!plot.seedId;
             const originalSeedId = plot.seedId; // L∆∞u l·∫°i ID h·∫°t gi·ªëng g·ªëc n·∫øu c√≥
             const plantName = wasPlanted ? (ITEM_DATA[originalSeedId]?.name || 'c√¢y') : '√¥ ƒë·∫•t';
             const wasDead = wasPlanted && plot.health <= 0;
             const causeOfDeath = plot.causeOfDeath; // L·∫•y nguy√™n nh√¢n ch·∫øt *tr∆∞·ªõc khi reset*
             const wasPestDeath = wasDead && causeOfDeath === 'pest';
             // Ki·ªÉm tra xem c√≥ ph·∫£i l√† tr∆∞·ªùng h·ª£p d·ªçn s√¢u mi·ªÖn ph√≠ kh√¥ng
             const wasFreePestCleanup = wasPestDeath && (plot.pestDeathClickCount || 0) >= DEAD_PEST_FREE_CLEANUP_CLICKS;

             // 3. --- Reset Tr·∫°ng Th√°i √î ƒê·∫•t ---
             plot.seedId = null;               // X√≥a th√¥ng tin c√¢y tr·ªìng
             plot.plantTime = null;            // X√≥a th·ªùi gian tr·ªìng
             plot.hasPest = false;             // X√≥a tr·∫°ng th√°i s√¢u b·ªánh
             plot.health = INITIAL_PLANT_HEALTH; // Ph·ª•c h·ªìi m√°u v·ªÅ ƒë·∫ßy (cho l·∫ßn tr·ªìng sau)
             plot.causeOfDeath = null;        // X√≥a nguy√™n nh√¢n ch·∫øt
             plot.pestDeathClickCount = 0;     // Reset b·ªô ƒë·∫øm click d·ªçn s√¢u
             plot.barrenHarvestPenaltyFactor = 1.0; // Reset h·ªá s·ªë ph·∫°t ƒë·∫•t c·∫±n
             plot.isDry = false; // <<< *** Quan tr·ªçng: Reset tr·∫°ng th√°i kh√¥ h·∫°n *** >>>
             // --- Reset Buff khi D·ªçn ---
             plot.fertilizerGrowthUsageCount = 0; // Reset b·ªô ƒë·∫øm khi d·ªçn
             plot.fertilizerProtectUsageCount = 0; // Reset b·ªô ƒë·∫øm khi d·ªçn
             plot.hasFertilizerProtectBuff = false; // Reset buff khi d·ªçn
             // --- K·∫øt Th√∫c Reset Buff ---
			 plot.fenceData = null; // <<<  X√≥a d·ªØ li·ªáu h√†ng r√†o khi d·ªçn √¥ >>>
             // *** L∆ØU √ù: KH√îNG reset plot.fertility (ƒë·ªô ph√¨ nhi√™u) ***

             // 4. C·∫≠p nh·∫≠t giao di·ªán v√† L∆∞u game (n√™n l√†m tr∆∞·ªõc khi hi·ªÉn th·ªã th√¥ng b√°o/log)
             renderGarden(); // V·∫Ω l·∫°i khu v∆∞·ªùn v·ªõi √¥ ƒë·∫•t ƒë√£ ƒë∆∞·ª£c d·ªçn
             saveGame();     // L∆∞u tr·∫°ng th√°i game m·ªõi

             // 5. <<< C·∫¨P NH·∫¨T LOG ACTION >>>
             let logDetails = '';
             let logIcon = '‚õèÔ∏è'; // Icon m·∫∑c ƒë·ªãnh l√† x·ªõi/d·ªçn
             if (wasPlanted) { // Ch·ªâ log chi ti·∫øt n·∫øu tr∆∞·ªõc ƒë√≥ c√≥ c√¢y
                 if (wasPestDeath) {
                     logIcon = 'üíÄ'; // Icon ch·∫øt
                     logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt do s√¢u, ${wasFreePestCleanup ? 'mi·ªÖn ph√≠' : 't·ªën ph√≠'}).`;
                 } else if (wasDead && causeOfDeath === 'dryness') { // <<< X·ª¨ L√ù NGUY√äN NH√ÇN KH√î H·∫†N >>>
                     logIcon = 'üíÄ'; // Icon ch·∫øt
                     logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt do kh√¥ h·∫°n).`;
                 } else if (wasDead && causeOfDeath === 'lightning') { // <<< TH√äM KI·ªÇM TRA S√âT >>>
                     logIcon = 'üíÄ‚ö°'; // Icon ch·∫øt + s√©t
                     logDetails = `ƒê√£ d·ªçn ${plantName} (ch·∫øt do s√©t ƒë√°nh) ·ªü √¥ ${plotId + 1}.`;
                 } else if (wasDead && causeOfDeath === 'tornado') { // Th√™m case gi√≥ l·ªëc
                    logIcon = 'üíÄüå™Ô∏è';
                    logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt do gi√≥ l·ªëc).`;
                 } else if (wasDead) { // C√°c tr∆∞·ªùng h·ª£p ch·∫øt kh√°c (t·ª± nhi√™n/kh√¥ng r√µ)
                     logIcon = 'üíÄ';
                     logDetails = `√î ${plotId + 1}: D·ªçn ${plantName} (ch·∫øt t·ª± nhi√™n/kh√¥ng r√µ).`;
                 } else { // C√¢y ƒëang s·ªëng b·ªã x·ªõi b·ªè
                     // Icon v·∫´n l√† ‚õèÔ∏è
                     logDetails = `√î ${plotId + 1}: X·ªõi b·ªè ${plantName} (ƒëang s·ªëng).`;
                 }
             } else {
                 // Tr∆∞·ªùng h·ª£p hi·∫øm: D·ªçn m·ªôt √¥ ƒë·∫•t ƒë√£ tr·ªëng s·∫µn
                 logDetails = `ƒê√£ d·ªçn/x·ªõi √¥ ƒë·∫•t tr·ªëng ${plotId + 1}.`;
             }
             // Ghi log h√†nh ƒë·ªông v·ªõi th√¥ng tin chi ti·∫øt
             logAction('clear', plotId, logDetails, logIcon, originalSeedId);
             // <<< K·∫æT TH√öC LOG ACTION >>>

             // 6. --- Hi·ªÉn th·ªã Th√¥ng b√°o cho ng∆∞·ªùi ch∆°i (t√πy ch·ªânh) ---
             // Kh√¥ng hi·ªÉn th·ªã l·∫°i message n·∫øu l√† tr∆∞·ªùng h·ª£p tr·∫£ ph√≠ d·ªçn s√¢u (ƒë√£ c√≥ msg tr∆∞·ªõc ƒë√≥)
             if (!(wasPestDeath && !wasFreePestCleanup)) {
                 if (wasFreePestCleanup) {
                     // Message cho d·ªçn s√¢u mi·ªÖn ph√≠ ƒë√£ hi·ªÉn th·ªã khi ƒë·ªß click, kh√¥ng c·∫ßn th√™m ·ªü ƒë√¢y
                 } else if (wasDead && causeOfDeath === 'dryness') { // <<< TH√îNG B√ÅO CH·∫æT KH√î >>>
                     showMessage(`ƒê√£ d·ªçn ${plantName} ch·∫øt kh√¥ kh·ªèi √¥ ${plotId + 1}.`, "info");
                 } else if (wasDead && causeOfDeath === 'lightning') { // <<< TH√îNG B√ÅO CH·∫æT S√âT >>>
                     showMessage(`ƒê√£ d·ªçn ${plantName} ch·∫øt do s√©t ƒë√°nh kh·ªèi √¥ ${plotId + 1}.`, "info");
                 } else if (wasDead && causeOfDeath === 'tornado') { showMessage(`ƒê√£ d·ªçn ${plantName} ch·∫øt do gi√≥ l·ªëc kh·ªèi √¥ ${plotId + 1}.`, "info"); }
                 else if (wasPlanted && !wasDead) { // X·ªõi c√¢y s·ªëng
                     showMessage(`ƒê√£ x·ªõi b·ªè ${plantName} ƒëang s·ªëng ·ªü √¥ ${plotId + 1}.`, "warning");
                 } else if (wasDead) { // D·ªçn c√¢y ch·∫øt t·ª± nhi√™n/kh√¥ng r√µ
                     showMessage(`ƒê√£ d·ªçn ${plantName} ch·∫øt kh·ªèi √¥ ${plotId + 1}.`, "info");
                 }
                 // Kh√¥ng c·∫ßn th√¥ng b√°o ƒë·∫∑c bi·ªát khi d·ªçn √¥ ƒë√£ tr·ªëng.
             }

             // 7. ƒê√≥ng modal h√†nh ƒë·ªông n·∫øu n√≥ ƒëang m·ªü cho √¥ n√†y
             if (plantActionModal.style.display === 'block' && currentActionPlotId === plotId) {
                 closeModal('plant-action-modal');
                 currentActionPlotId = null; // Reset ID ƒëang h√†nh ƒë·ªông
             }
         } // --- K·∫øt th√∫c h√†m clearPlot ---

        /** H√†nh ƒë·ªông: X·ª≠ l√Ω khi click tr·ª±c ti·∫øp v√†o c√¢y ch·∫øt (ki·ªÉm tra ph√≠ ho·∫∑c click mi·ªÖn ph√≠) */
         function handleDeadPlotClick(plotId, plotElement) {
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || !gameState.plots[plotId].seedId || gameState.plots[plotId].health > 0) return;
             const plot = gameState.plots[plotId];
             const plotInfoElement = plotElement ? plotElement.querySelector('.plot-info') : null;

             if (plot.causeOfDeath === 'pest') {
                 const hasEnoughMoney = gameState.currency >= DEAD_PEST_CLEANUP_COST;
                 if (hasEnoughMoney) {
                      // M·ªü modal ƒë·ªÉ x√°c nh·∫≠n tr·∫£ ph√≠
                      currentActionPlotId = plotId;
                      updatePlantActionModalButtons(plotId);
                      openModal('plant-action-modal');
                      // Th√¥ng b√°o ph·ª• tr·ª£
                      setTimeout(() => showMessage(`C√¢y ch·∫øt do s√¢u. Click "D·ªçn S·∫°ch" trong c·ª≠a s·ªï v·ª´a m·ªü (t·ªën ${DEAD_PEST_CLEANUP_COST}üí∞) ho·∫∑c click tr·ª±c ti·∫øp v√†o √¥ ƒë·∫•t n√†y ${DEAD_PEST_FREE_CLEANUP_CLICKS} l·∫ßn n·∫øu b·∫°n ƒë·ªïi √Ω/h·∫øt ti·ªÅn.`, "warning", MESSAGE_DISPLAY_TIME * 1.8), 100);
                 } else {
                     // Ti·∫øn h√†nh click mi·ªÖn ph√≠
                     plot.pestDeathClickCount++;
                     const clicksRemaining = DEAD_PEST_FREE_CLEANUP_CLICKS - plot.pestDeathClickCount;
                     if (clicksRemaining <= 0) {
                         showMessage(`Yeah! ƒê√£ click ƒë·ªß ${DEAD_PEST_FREE_CLEANUP_CLICKS} l·∫ßn! D·ªçn √¥ ƒë·∫•t ${plotId+1} mi·ªÖn ph√≠!`, "success");
                         clearPlot(plotId); // D·ªçn ngay khi ƒë·ªß click
                     }
                     else {
                         showMessage(`C√≤n ${clicksRemaining} l·∫ßn click n·ªØa ƒë·ªÉ d·ªçn √¥ ${plotId+1} mi·ªÖn ph√≠!`, "info");
                          // C·∫≠p nh·∫≠t text tr√™n √¥ ƒë·∫•t ngay l·∫≠p t·ª©c
                          if (plotInfoElement) {
                              plotInfoElement.textContent = `üíÄ Ch·∫øt (S√¢u)! Click ${clicksRemaining} l·∫ßn...`;
                              plotInfoElement.classList.add('free-cleanup-progress');
                              plotInfoElement.classList.remove('needs-cleanup-fee');
                          }
                         // Kh√¥ng c·∫ßn saveGame() m·ªói l·∫ßn click, s·∫Ω save khi d·ªçn xong ho·∫∑c auto save
                     }
                 }
             } else { // Ch·∫øt t·ª± nhi√™n -> M·ªü modal ƒë·ªÉ d·ªçn mi·ªÖn ph√≠
                 currentActionPlotId = plotId;
                 updatePlantActionModalButtons(plotId);
                 openModal('plant-action-modal');
                 setTimeout(() => showMessage(`C√¢y ƒë√£ ch·∫øt t·ª± nhi√™n. Click "X·ªõi ƒê·∫•t" trong c·ª≠a s·ªï v·ª´a m·ªü ƒë·ªÉ d·ªçn mi·ªÖn ph√≠.`, "info"), 100);
             }
         }


        /** H√†nh ƒë·ªông: S·ª≠ d·ª•ng thu·ªëc tr·ª´ s√¢u t·ª´ kho ƒê√É MUA. */
        function treatPest(plotId) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
                console.warn(`treatPest ƒë∆∞·ª£c g·ªçi cho √¥ ${plotId} kh√¥ng h·ª£p l·ªá.`);
                return;
            }
            const plot = gameState.plots[plotId];
            const plantName = plot.seedId ? (ITEM_DATA[plot.seedId]?.name || 'c√¢y') : '√¥ ƒë·∫•t'; // L·∫•y t√™n c√¢y n·∫øu c√≥

            if (!plot.hasPest) {
                showMessage(`C√¢y ${plantName} n√†y hi·ªán kh√¥ng c√≥ s√¢u.`, "info");
                return;
            }
            if (plot.health <= 0) {
                showMessage(`C√¢y ${plantName} ƒë√£ ch·∫øt, kh√¥ng th·ªÉ tr·ªã s√¢u!`, "warning");
                return;
            }

            const currentPesticide = gameState.inventory.pesticide || 0;
            if (currentPesticide > 0) {
                // --- Th·ª±c hi·ªán tr·ªã s√¢u ---
                gameState.inventory.pesticide--; // Tr·ª´ thu·ªëc kh·ªèi kho ƒë√£ mua
                plot.hasPest = false; // Lo·∫°i b·ªè tr·∫°ng th√°i s√¢u

                // C·∫≠p nh·∫≠t UI v√† L∆∞u game
                renderUI(); // C·∫≠p nh·∫≠t ti·ªÅn (kh√¥ng ƒë·ªïi)
                renderGarden(); // V·∫Ω l·∫°i ƒë·ªÉ b·ªè icon s√¢u v√† hi·ªáu ·ª©ng vi·ªÅn ƒë·ªè
                if (inventoryModal.style.display === 'block') renderInventory(); // C·∫≠p nh·∫≠t kho n·∫øu ƒëang m·ªü
                saveGame();

                // Hi·ªÉn th·ªã th√¥ng b√°o
                showMessage(`ƒê√£ d√πng ${ITEM_DATA.pesticide.name} cho ${plantName} ·ªü √¥ ${plotId + 1}.`, "success");

                // <<< TH√äM LOG ACTION >>>
                logAction('pest', plotId, `√î ${plotId + 1}: D√πng ${ITEM_DATA.pesticide.name} cho ${plantName}.`, 'üíä', 'pesticide'); 
				// <<< K·∫æT TH√öC LOG ACTION >>>

                // C·∫≠p nh·∫≠t l·∫°i modal h√†nh ƒë·ªông n·∫øu n√≥ ƒëang m·ªü cho √¥ n√†y
                if (plantActionModal.style.display === 'block' && currentActionPlotId === plotId) {
                    updatePlantActionModalButtons(plotId);
                }

            } else { // H·∫øt thu·ªëc
                showMessage(`H·∫øt ${ITEM_DATA.pesticide.name} (trong kho ƒë√£ mua) r·ªìi! üò≠ H√£y mua th√™m ·ªü c·ª≠a h√†ng.`, "error");
                // ƒê√≥ng modal h√†nh ƒë·ªông (n·∫øu m·ªü) v√† m·ªü c·ª≠a h√†ng
                if (plantActionModal.style.display === 'block') closeModal('plant-action-modal');
                currentActionPlotId = null;
                switchShopTab('tools');
                openModal('shop-modal');
            }
        }

         /** X·ª≠ l√Ω ch·ªçn ph√¢n b√≥n t·ª´ modal (·ª¶y quy·ªÅn s·ª± ki·ªán) */
      function handleFertilizerSelection(event) {
    const useButton = event.target.closest('.use-button');
    // Ph·∫£i c√≥ plotId ƒë√£ l∆∞u t·ª´ tr∆∞·ªõc v√† n√∫t ph·∫£i ƒë∆∞·ª£c enable
    if (!useButton || currentActionPlotId === null || useButton.disabled) return;

    const fertilizerId = useButton.dataset.fertilizerId;
    if (!fertilizerId || !ITEM_DATA[fertilizerId]) {
        console.error("ID ph√¢n b√≥n kh√¥ng h·ª£p l·ªá:", fertilizerId);
        // V·∫´n ƒë√≥ng modal n·∫øu c√≥ l·ªói ID
        closeModal('fertilizer-selection-modal');
        currentActionPlotId = null;
        return;
    }

    const plotIdToFertilize = currentActionPlotId; // L·∫•y plotId ƒë√£ l∆∞u

    // G·ªçi h√†m √°p d·ª•ng ph√¢n b√≥n. H√†m n√†y s·∫Ω hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng/th·∫•t b·∫°i.
    applyFertilizer(plotIdToFertilize, fertilizerId);

    // Lu√¥n ƒë√≥ng modal ch·ªçn ph√¢n b√≥n sau khi ƒë√£ c·ªë g·∫Øng √°p d·ª•ng.
    closeModal('fertilizer-selection-modal');

    // Reset ID √¥ ƒë·∫•t ƒëang ƒë∆∞·ª£c thao t√°c. L∆∞u √Ω: applyFertilizer c≈©ng c√≥ th·ªÉ ƒë√£ reset n·∫øu th√†nh c√¥ng.
    // Vi·ªác reset ·ªü ƒë√¢y ƒë·∫£m b·∫£o n√≥ lu√¥n ƒë∆∞·ª£c reset sau khi modal l·ª±a ch·ªçn ƒë√≥ng.
    currentActionPlotId = null;
}


        /** H√†nh ƒë·ªông: √Åp d·ª•ng ph√¢n b√≥n ƒë√£ ch·ªçn v√†o √¥ ƒë·∫•t m·ª•c ti√™u. */
          function applyFertilizer(plotId, itemId) {
    if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId]) {
        console.warn(`applyFertilizer g·ªçi tr√™n √¥ ${plotId} kh√¥ng h·ª£p l·ªá/b·ªã kh√≥a.`);
        return;
    }
    const plot = gameState.plots[plotId];
    const item = ITEM_DATA[itemId];

    if (!item || item.type !== 'tool') { // Ch·ªâ c·∫ßn l√† tool
        console.warn(`applyFertilizer g·ªçi v·ªõi itemId ${itemId} kh√¥ng h·ª£p l·ªá (kh√¥ng ph·∫£i tool).`);
        return;
    }

    if ((gameState.inventory[itemId] || 0) <= 0) {
        showMessage(`B·∫°n kh√¥ng c√≥ ${item.name} (trong kho ƒë√£ mua)!`, "error");
        currentActionPlotId = null; // Reset plotId n·∫øu kh√¥ng c√≥ v·∫≠t ph·∫©m
        return;
    }

    // Ki·ªÉm tra ƒëi·ªÅu ki·ªán s·ª≠ d·ª•ng CHUNG: kh√¥ng d√πng cho c√¢y ch·∫øt
    // Ngo·∫°i tr·ª´ b√≥n cho ƒë·∫•t tr·ªëng ƒë·ªÉ tƒÉng ph√¨ (ch·ªâ √°p d·ª•ng cho lo·∫°i c√≥ fertilityBoost > 0 v√† kh√¥ng ph·∫£i fertilizer_protect)
    if (plot.seedId && plot.health <= 0) {
        showMessage(`Kh√¥ng th·ªÉ b√≥n ph√¢n cho c√¢y ƒë√£ ch·∫øt!`, "warning");
        return;
    }
    // NgƒÉn b√≥n ph√¢n b·∫£o v·ªá cho ƒë·∫•t tr·ªëng
    if (itemId === 'fertilizer_protect' && !plot.seedId) {
         showMessage(`${item.name} ch·ªâ d√πng ƒë∆∞·ª£c cho c√¢y ƒëang tr·ªìng.`, "warning"); return;
    }

    let itemApplied = false;
    let successMessage = '';

    // --- X·ª≠ l√Ω Ph√¢n B√≥n TƒÉng Tr∆∞·ªüng ---
    if (itemId === 'fertilizer_growth') {
        if (!plot.seedId) { showMessage(`${item.name} ch·ªâ d√πng ƒë∆∞·ª£c cho c√¢y ƒëang tr·ªìng.`, "warning"); return; }
        // Logic fertilizer_growth gi·ªØ nguy√™n (ki·ªÉm tra gi·ªõi h·∫°n, tƒÉng m√°u, gi·∫£m th·ªùi gian...)
        const currentGrowthUsage = plot.fertilizerGrowthUsageCount || 0;
        const growthLimit = FERTILIZER_GROWTH_MAX_USES; // Ho·∫∑c item.usageLimitPerPlant n·∫øu c√≥ trong ITEM_DATA
        if (currentGrowthUsage >= growthLimit) {
             showMessage(`ƒê√£ d√πng ${item.name} t·ªëi ƒëa ${growthLimit} l·∫ßn cho c√¢y n√†y.`, "warning"); return;
        }
        // Th·ª±c hi·ªán hi·ªáu ·ª©ng...
        gameState.inventory[itemId]--;
        itemApplied = true;
        let messagesGrowth = [];
        const now = Date.now();
        const stageInfoBeforeGrowth = getPlantStageInfo(plot, now);
        if (stageInfoBeforeGrowth && !stageInfoBeforeGrowth.isMature && stageInfoBeforeGrowth.effectiveGrowthTimeSec > 0 && typeof item.growthTimeReductionPercent === 'number') {
             const effectiveGrowthTimeMsGrowth = stageInfoBeforeGrowth.effectiveGrowthTimeSec * 1000;
             const elapsedTimeSoFarGrowth = now - plot.plantTime;
             const remainingTimeMsGrowth = Math.max(0, effectiveGrowthTimeMsGrowth - elapsedTimeSoFarGrowth);
             const timeToSubtractGrowth = remainingTimeMsGrowth * item.growthTimeReductionPercent;
             const oldPlantTimeGrowth = plot.plantTime;
             plot.plantTime = Math.min(now, plot.plantTime + timeToSubtractGrowth);
             const actualReductionMsGrowth = plot.plantTime - oldPlantTimeGrowth;
             if (actualReductionMsGrowth > 0) messagesGrowth.push(`th·ªùi gian l·ªõn gi·∫£m ~${formatTime(actualReductionMsGrowth, true)}`);
             const stageInfoAfterGrowth = getPlantStageInfo(plot, now);
             if (stageInfoAfterGrowth && stageInfoAfterGrowth.isMature && !stageInfoBeforeGrowth.isMature) messagesGrowth.push("c√¢y ƒë√£ TR∆Ø·ªûNG TH√ÄNH!");
        } else if (stageInfoBeforeGrowth && stageInfoBeforeGrowth.isMature) { messagesGrowth.push("kh√¥ng ·∫£nh h∆∞·ªüng th·ªùi gian (ƒë√£ l·ªõn)"); }
        else { messagesGrowth.push("kh√¥ng ·∫£nh h∆∞·ªüng th·ªùi gian (l·ªói/kh√¥ng √°p d·ª•ng)"); }
        const healthBoostAmountGrowth = INITIAL_PLANT_HEALTH * (item.healthBoostPercent || 0);
        const oldHealthGrowth = plot.health;
        plot.health = Math.min(INITIAL_PLANT_HEALTH, plot.health + healthBoostAmountGrowth);
        const actualHealthBoostGrowth = plot.health - oldHealthGrowth;
        if (actualHealthBoostGrowth > 0) messagesGrowth.push(`m√°u tƒÉng +${actualHealthBoostGrowth.toFixed(0)}`);
        plot.fertilizerGrowthUsageCount = currentGrowthUsage + 1;
        messagesGrowth.push(`(ƒë√£ d√πng ${plot.fertilizerGrowthUsageCount}/${growthLimit} l·∫ßn)`);
        successMessage = `ƒê√£ d√πng ${item.name}: ${messagesGrowth.join(', ')}.`;
    }
    // --- X·ª≠ l√Ω Ph√¢n B√≥n B·∫£o V·ªá ---
    else if (itemId === 'fertilizer_protect') {
        // ƒêi·ªÅu ki·ªán ƒë√£ ki·ªÉm tra ·ªü ƒë·∫ßu (ph·∫£i c√≥ c√¢y s·ªëng)
        const currentProtectUsage = plot.fertilizerProtectUsageCount || 0;
        const protectLimit = item.usageLimitPerPlant || 3;
        if (currentProtectUsage >= protectLimit) {
            showMessage(`ƒê√£ d√πng ${item.name} t·ªëi ƒëa ${protectLimit} l·∫ßn cho c√¢y n√†y.`, "warning"); return;
        }

        // Th·ª±c hi·ªán hi·ªáu ·ª©ng
        gameState.inventory[itemId]--;
        itemApplied = true;
        let messagesProtect = [];

        // 1. TƒÉng ƒë·ªô ph√¨ nhi√™u
        const boostAmountProtect = (item.fertilityBoost || 0) * BASE_FERTILITY;
        if (plot.fertility < BASE_FERTILITY && boostAmountProtect > 0) {
             const oldFertilityProtect = plot.fertility;
             plot.fertility = Math.min(BASE_FERTILITY, plot.fertility + boostAmountProtect);
             const actualBoostProtect = plot.fertility - oldFertilityProtect;
             messagesProtect.push(`ƒë·ªô ph√¨ +${actualBoostProtect.toFixed(0)}%`);
             if (oldFertilityProtect <= 0 && plot.fertility > 0) {
                 plot.barrenHarvestPenaltyFactor = 1.0;
                 messagesProtect.push("(ƒë·∫•t h·∫øt c·∫±n)");
             }
        } else {
            messagesProtect.push("ƒë·ªô ph√¨ ƒë√£ t·ªëi ƒëa");
        }

        // 2. K√≠ch ho·∫°t buff b·∫£o v·ªá & tƒÉng b·ªô ƒë·∫øm
        plot.hasFertilizerProtectBuff = true;
        plot.fertilizerProtectUsageCount = currentProtectUsage + 1;
        messagesProtect.push(`üõ°Ô∏è ƒë∆∞·ª£c b·∫£o v·ªá kh·ªèi s√¢u`);
        messagesProtect.push(`(ƒë√£ d√πng ${plot.fertilizerProtectUsageCount}/${protectLimit} l·∫ßn)`);

        successMessage = `ƒê√£ d√πng ${item.name}: ${messagesProtect.join(', ')}.`;
    }
    // --- X·ª≠ l√Ω Ph√¢n B√≥n TƒÉng Ph√¨ Nhi√™u C≈® ---
    else if (typeof item.fertilityBoost === 'number') {
        if (plot.fertility >= BASE_FERTILITY) {
            showMessage(`√î ƒë·∫•t ${plotId + 1} ƒë√£ c√≥ ƒë·ªô ph√¨ nhi√™u t·ªëi ƒëa!`, "info");
            return;
        }
        gameState.inventory[itemId]--;
        itemApplied = true;
        const boostAmountOld = (item.fertilityBoost || 0) * BASE_FERTILITY;
        const oldFertilityOld = plot.fertility;
        plot.fertility = Math.min(BASE_FERTILITY, plot.fertility + boostAmountOld);
        const actualBoostOld = plot.fertility - oldFertilityOld;
        let barrenRecoveryMsgOld = '';
        if (oldFertilityOld <= 0 && plot.fertility > 0) {
            plot.barrenHarvestPenaltyFactor = 1.0;
            barrenRecoveryMsgOld = `\nƒê·∫•t ƒë√£ ph·ª•c h·ªìi t·ª´ c·∫±n!`;
        }
        successMessage = `ƒê√£ b√≥n ${item.name} cho √¥ ${plotId + 1}. ƒê·ªô ph√¨ tƒÉng +${actualBoostOld.toFixed(0)}% (${Math.round(plot.fertility)}%).${barrenRecoveryMsgOld}`;
    } else {
        showMessage(`V·∫≠t ph·∫©m ${item.name} kh√¥ng c√≥ hi·ªáu ·ª©ng b√≥n ph√¢n.`, "warning");
        return;
    }

    // --- C·∫≠p nh·∫≠t chung n·∫øu v·∫≠t ph·∫©m ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng ---
    if (itemApplied) {
	
	
	
		updateDailyQuestProgress('fertilize', 1, itemId); // C·∫≠p nh·∫≠t NV s·ª≠ d·ª•ng ph√¢n b√≥n
        renderUI();
        renderGarden();
        if (inventoryModal.style.display === 'block') renderInventory();
        saveGame();
        showMessage(successMessage, "success", successMessage.includes('\n') ? MESSAGE_DISPLAY_TIME + 1000 : MESSAGE_DISPLAY_TIME);

        // C·∫≠p nh·∫≠t Log Action
        let logIcon = 'üí©'; // M·∫∑c ƒë·ªãnh
        let logDetails = `√î ${plotId + 1}: D√πng ${item.name}.`;
        if (itemId === 'fertilizer_growth') {
             logIcon = '‚ú®';
             logDetails += ` HP: ${plot.health.toFixed(0)}%, L·∫ßn d√πng: ${plot.fertilizerGrowthUsageCount}.`;
        } else if (itemId === 'fertilizer_protect') {
            logIcon = 'üõ°Ô∏è';
            logDetails += ` Ph√¨ -> ${plot.fertility.toFixed(0)}%. B·∫£o v·ªá s√¢u b·ªánh k√≠ch ho·∫°t. L·∫ßn d√πng: ${plot.fertilizerProtectUsageCount}.`;
        } else if (typeof item.fertilityBoost === 'number') {
             const actualBoostLog = Math.max(0, plot.fertility - (plot.fertility / (1 + item.fertilityBoost))); // ∆Ø·ªõc t√≠nh boost
             logDetails += ` Ph√¨: +${actualBoostLog.toFixed(0)}% -> ${plot.fertility.toFixed(0)}%.`;
        }
        logAction('fertilize', plotId, logDetails, logIcon, itemId);

        // C·∫≠p nh·∫≠t l·∫°i modal h√†nh ƒë·ªông g·ªëc (n·∫øu c√≥ v√† plotId kh·ªõp)
        if (currentActionPlotId === plotId) {
            if (plantActionModal.style.display === 'block') { updatePlantActionModalButtons(plotId); }
            else if (emptyPlotActionModal.style.display === 'block') { updateEmptyPlotActionModal(plotId); }
        }
    }
 }
// --- K·∫øt th√∫c h√†m applyFertilizer ---


         /** H√†nh ƒë·ªông: Thu ho·∫°ch c√¢y, th√™m v√†o kho "ƒê√£ Thu Ho·∫°ch", v√† c·∫≠p nh·∫≠t h·ªá s·ªë ph·∫°t n·∫øu c·∫ßn. */
          function harvestPlant(plotId) {
            console.log(`[HARVEST] Function called for plotId: ${plotId}`); // Log khi h√†m b·∫Øt ƒë·∫ßu

            // --- B∆∞·ªõc 1: Ki·ªÉm tra ƒë·∫ßu v√†o ---
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || !gameState.plots[plotId].seedId || !gameState.plots[plotId].plantTime) {
                console.warn(`[HARVEST] Invalid input check failed. plotId: ${plotId}, maxPlots: ${gameState.maxUnlockedPlots}, plotData exists: ${!!gameState.plots[plotId]}, seedId: ${gameState.plots[plotId]?.seedId}, plantTime: ${gameState.plots[plotId]?.plantTime}`);
                showMessage("L·ªói: D·ªØ li·ªáu √¥ ƒë·∫•t kh√¥ng h·ª£p l·ªá ƒë·ªÉ thu ho·∫°ch.", "error");
                return; // Tho√°t n·∫øu ƒë·∫ßu v√†o kh√¥ng h·ª£p l·ªá
            }
            const plot = gameState.plots[plotId];
            const seedInfo = ITEM_DATA[plot.seedId];
            if (!seedInfo || seedInfo.type !== 'seed') {
                console.error(`[HARVEST] Invalid seed data for seedId: ${plot.seedId}. Clearing plot.`);
                showMessage("L·ªói: D·ªØ li·ªáu h·∫°t gi·ªëng kh√¥ng h·ª£p l·ªá. ƒêang d·ªçn √¥ ƒë·∫•t.", "error");
                clearPlot(plotId); // D·ªçn √¥ n·∫øu d·ªØ li·ªáu h·∫°t gi·ªëng l·ªói
                return;
            }
            console.log(`[HARVEST] Input and seed data validated for plot ${plotId} (${seedInfo.name}).`);

            // --- B∆∞·ªõc 2: Ki·ªÉm tra ƒëi·ªÅu ki·ªán thu ho·∫°ch (ƒë·ªô ch√≠n, s√¢u b·ªánh, m√°u) ---
            const now = Date.now();
            const stageInfo = getPlantStageInfo(plot, now);
            console.log(`[HARVEST] Plot ${plotId} - Stage Info: isMature=${stageInfo?.isMature}, hasPest=${plot.hasPest}, health=${plot.health}, isError=${stageInfo?.isError}`); // Log th√¥ng tin giai ƒëo·∫°n

            if (!stageInfo || stageInfo.isError || !stageInfo.isMature || plot.hasPest || plot.health <= 0) {
                let reason = "kh√¥ng r√µ";
                if (!stageInfo || stageInfo.isError) reason = "l·ªói d·ªØ li·ªáu c√¢y";
                else if (!stageInfo.isMature) reason = "c√¢y ch∆∞a ch√≠n";
                else if (plot.hasPest) reason = "c√¢y ƒëang b·ªã s√¢u";
                else if (plot.health <= 0) reason = "c√¢y ƒë√£ ch·∫øt";
                console.warn(`[HARVEST] Cannot harvest plot ${plotId}. Reason: ${reason}`);
                showMessage(`Kh√¥ng th·ªÉ thu ho·∫°ch ${seedInfo.name} v√¨ ${reason === "c√¢y ch∆∞a ch√≠n" ? "c√¢y ch∆∞a ch√≠n" : reason === "c√¢y ƒëang b·ªã s√¢u" ? "c√¢y ƒëang b·ªã s√¢u" : reason === "c√¢y ƒë√£ ch·∫øt" ? "c√¢y ƒë√£ ch·∫øt" : "l·ªói d·ªØ li·ªáu c√¢y"}!`, "warning");
                return; // <<< Tho√°t n·∫øu kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán
            }
            console.log(`[HARVEST] Plot ${plotId} conditions met (Mature, No Pest, Alive).`);

            // --- B∆∞·ªõc 3: T√≠nh to√°n ch·∫•t l∆∞·ª£ng d·ª±a tr√™n m√°u ---
            const currentHealthPercent = plot.health;
            const qualityTier = getQualityTier(currentHealthPercent);
            if (!qualityTier) {
                console.error(`[HARVEST] Cannot determine quality tier for plot ${plotId} with HP: ${currentHealthPercent}`);
                showMessage("L·ªói: Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ch·∫•t l∆∞·ª£ng thu ho·∫°ch.", "error");
                return;
            }
            const qualityDisplayName = QUALITY_DISPLAY_NAMES[qualityTier] || 'Kh√¥ng r√µ';
            console.log(`[HARVEST] Plot ${plotId} - Determined Quality: ${qualityTier} (${qualityDisplayName}) based on HP ${currentHealthPercent.toFixed(1)}%`);

            // --- B∆∞·ªõc 4: Ki·ªÉm tra gi·ªõi h·∫°n kho ƒë·ªì ---
            const currentTotalCount = getTotalInventoryCount(); // H√†m n√†y c·∫ßn t√≠nh c·∫£ kho mua v√† kho thu ho·∫°ch
            const harvestQuantity = 1;
            console.log(`[HARVEST] Inventory check: Current Total=${currentTotalCount}, Max Capacity=${gameState.maxInventoryCapacity}, Harvesting=${harvestQuantity}`);
            if (currentTotalCount + harvestQuantity > gameState.maxInventoryCapacity) {
                console.warn(`[HARVEST] Inventory full. Current: ${currentTotalCount}, Max: ${gameState.maxInventoryCapacity}. Cannot harvest plot ${plotId}.`);
                showMessage(`Kho ƒë·ªì ƒë√£ ƒë·∫ßy (${currentTotalCount}/${gameState.maxInventoryCapacity})! Kh√¥ng th·ªÉ thu ho·∫°ch ${seedInfo.name}.`, "error");
                return; // <<< Tho√°t n·∫øu kho ƒë·∫ßy
            }
            console.log(`[HARVEST] Inventory has space. Proceeding with harvest.`);

            // --- B∆∞·ªõc 5: Th·ª±c hi·ªán thu ho·∫°ch v√† l∆∞u tr·ªØ ch·∫•t l∆∞·ª£ng ---
            const harvestedItemId = plot.seedId; // L∆∞u ID tr∆∞·ªõc khi reset plot
            const harvestedPlantName = seedInfo.name; // L∆∞u t√™n tr∆∞·ªõc khi reset plot
            const fertilityBeforeHarvest = plot.fertility; // L∆∞u ƒë·ªô ph√¨ tr∆∞·ªõc khi reset
            let penaltyFactorBeforeHarvest = plot.barrenHarvestPenaltyFactor || 1.0; // L∆∞u penalty tr∆∞·ªõc khi reset

            // ƒê·∫£m b·∫£o harvestedItems[id] l√† object tr∆∞·ªõc khi truy c·∫≠p
            if (!gameState.harvestedItems[harvestedItemId] || typeof gameState.harvestedItems[harvestedItemId] !== 'object') {
                console.log(`[HARVEST] Initializing quality data for ${harvestedItemId}.`);
                gameState.harvestedItems[harvestedItemId] = {
                    [QUALITY_TIERS.PERFECT]: 0, [QUALITY_TIERS.GOOD]: 0,
                    [QUALITY_TIERS.FAIR]: 0, [QUALITY_TIERS.POOR]: 0
                };
            }
            // ƒê·∫£m b·∫£o tier t·ªìn t·∫°i tr∆∞·ªõc khi tƒÉng
            if (gameState.harvestedItems[harvestedItemId].hasOwnProperty(qualityTier)) {
                 gameState.harvestedItems[harvestedItemId][qualityTier]++;
            } else {
                 console.warn(`[HARVEST] Quality tier ${qualityTier} not found in harvested data for ${harvestedItemId}. Setting to 1.`);
                 gameState.harvestedItems[harvestedItemId][qualityTier] = 1; // Kh·ªüi t·∫°o n·∫øu ch∆∞a c√≥ (ph√≤ng l·ªói)
            }
            console.log(`[HARVEST] Added 1 unit of ${qualityTier} ${harvestedPlantName} (ID: ${harvestedItemId}) to harvestedItems. New count for tier: ${gameState.harvestedItems[harvestedItemId][qualityTier]}`);

            // --- B∆∞·ªõc 6: Reset tr·∫°ng th√°i √¥ ƒë·∫•t (Gi·ªØ ƒë·ªô ph√¨ v√† h√†ng r√†o) ---
            const fenceDataBeforeReset = plot.fenceData; // L∆∞u l·∫°i fenceData n·∫øu c√≥
            plot.seedId = null;
            plot.plantTime = null;
            plot.hasPest = false;
            plot.health = INITIAL_PLANT_HEALTH; // Reset m√°u cho l·∫ßn tr·ªìng sau
            plot.causeOfDeath = null;
            plot.pestDeathClickCount = 0;
            plot.isDry = false; // H·∫øt kh√¥ sau khi thu ho·∫°ch
            // --- Reset Buff khi Thu Ho·∫°ch ---
            plot.fertilizerGrowthUsageCount = 0; // Reset b·ªô ƒë·∫øm khi thu ho·∫°ch
            plot.fertilizerProtectUsageCount = 0; // Reset b·ªô ƒë·∫øm khi thu ho·∫°ch
            plot.hasFertilizerProtectBuff = false; // Reset buff khi thu ho·∫°ch
            // --- K·∫øt Th√∫c Reset Buff ---
            // plot.fertility KH√îNG ƒë·ªïi
            plot.fenceData = fenceDataBeforeReset; // <<< G√ÅN L·∫†I FENCEDATA >>>
            console.log(`[HARVEST] Plot ${plotId} state reset. Fertility: ${plot.fertility.toFixed(1)}%, FenceData kept: ${!!plot.fenceData}`);

            // X·ª≠ l√Ω penalty ƒë·∫•t c·∫±n
            let penaltyApplied = false;
            if (fertilityBeforeHarvest <= 0) {
                plot.barrenHarvestPenaltyFactor = penaltyFactorBeforeHarvest * BARREN_HARVEST_PENALTY_MULTIPLIER;
                penaltyApplied = true;
                console.log(`[HARVEST] Harvested on barren soil. Barren penalty factor increased to ${plot.barrenHarvestPenaltyFactor.toFixed(2)}`);
            } else {
                // Ch·ªâ reset n·∫øu n√≥ ƒëang kh√°c 1.0
                if (plot.barrenHarvestPenaltyFactor !== 1.0) {
                     plot.barrenHarvestPenaltyFactor = 1.0;
                     console.log(`[HARVEST] Harvested on non-barren soil. Barren penalty factor reset to 1.0`);
                }
            }



			updateDailyQuestProgress('harvest', 1, harvestedItemId); // C·∫≠p nh·∫≠t NV thu ho·∫°ch c·ª• th·ªÉ v√† b·∫•t k·ª≥
            // --- B∆∞·ªõc 7: C·∫≠p nh·∫≠t UI v√† L∆∞u game ---
            console.log("[HARVEST] Updating UI (renderUI, renderGarden, renderInventory if open) and Saving Game...");
            renderUI(); // C·∫≠p nh·∫≠t ti·ªÅn (kh√¥ng ƒë·ªïi) v√† s·ªë √¥
            renderGarden(); // V·∫Ω l·∫°i v∆∞·ªùn v·ªõi √¥ ƒë·∫•t tr·ªëng (v√† h√†ng r√†o n·∫øu c√≥)
            if (inventoryModal.style.display === 'block') {
                renderInventory(); // C·∫≠p nh·∫≠t kho n·∫øu ƒëang m·ªü
            }
            saveGame(); // L∆∞u tr·∫°ng th√°i m·ªõi

            // --- B∆∞·ªõc 8: Hi·ªÉn th·ªã th√¥ng b√°o thu ho·∫°ch ---
            let harvestMessage = `ƒê√£ thu ho·∫°ch ${harvestedPlantName} (Ch·∫•t l∆∞·ª£ng: ${qualityDisplayName})! Th√™m v√†o kho.`;
            const fertilityAfterHarvest = plot.fertility; // L·∫•y ƒë·ªô ph√¨ sau khi ƒë√£ reset plot (v·∫´n gi·ªØ nguy√™n)
            harvestMessage += `\nƒê·ªô ph√¨ c√≤n l·∫°i: ${fertilityAfterHarvest.toFixed(0)}%.`;
            if (fertilityAfterHarvest <= 0) {
                harvestMessage += `\nC·∫¢NH B√ÅO: ƒê·∫•t ƒë√£ C·∫∞N KI·ªÜT!`;
                if (penaltyApplied) { // Ch·ªâ th√™m th√¥ng b√°o penalty n·∫øu n√≥ th·ª±c s·ª± ƒë∆∞·ª£c √°p d·ª•ng
                    harvestMessage += ` L·∫ßn tr·ªìng t·ªõi s·∫Ω m·ªçc ch·∫≠m x${plot.barrenHarvestPenaltyFactor.toFixed(2)}!`;
                }
            } else if (fertilityAfterHarvest < LOW_FERTILITY_THRESHOLD) {
                harvestMessage += `\nC·∫¢NH B√ÅO: ƒê·∫•t kh√° c·∫±n!`;
            }
            showMessage(harvestMessage, "success", harvestMessage.includes('\n') ? MESSAGE_DISPLAY_TIME + 1500 : MESSAGE_DISPLAY_TIME);

            // --- B∆∞·ªõc 9: Log Action ---
            logAction('harvest', plotId, `√î ${plotId + 1}: Thu ho·∫°ch ${harvestedPlantName} (Ch·∫•t l∆∞·ª£ng: ${qualityDisplayName}).`, 'üß∫', harvestedItemId);
            console.log(`[HARVEST] Harvest successful for plot ${plotId}. Message shown, action logged.`);

            // Kh√¥ng c·∫ßn ƒë√≥ng modal hay reset currentActionPlotId ·ªü ƒë√¢y v√¨ n√≥ ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong handlePlantActionClick
        }
         /** H√†nh ƒë·ªông: B√°n c√¢y tr·ª±c ti·∫øp t·ª´ √¥ ƒë·∫•t, v√† c·∫≠p nh·∫≠t h·ªá s·ªë ph·∫°t n·∫øu c·∫ßn. */
         function sellPlantDirectly(plotId) {
             // --- Ph·∫ßn ki·ªÉm tra ƒë·∫ßu v√†o (gi·ªØ nguy√™n) ---
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || !gameState.plots[plotId].seedId || !gameState.plots[plotId].plantTime) {
                 console.warn(`sellPlantDirectly ƒë∆∞·ª£c g·ªçi cho √¥ ${plotId} kh√¥ng h·ª£p l·ªá.`);
                 return;
             }
             const plot = gameState.plots[plotId];
             const seedInfo = ITEM_DATA[plot.seedId];
             if (!seedInfo || seedInfo.type !== 'seed') {
                 console.error(`D·ªØ li·ªáu h·∫°t gi·ªëng ${plot.seedId} kh√¥ng h·ª£p l·ªá khi b√°n tr·ª±c ti·∫øp.`);
                 clearPlot(plotId); // D·ªçn √¥ n·∫øu d·ªØ li·ªáu c√¢y b·ªã l·ªói
                 return;
             }

             const now = Date.now();
             const stageInfo = getPlantStageInfo(plot, now);

             if (!stageInfo || stageInfo.isError || !stageInfo.isMature || plot.hasPest || plot.health <= 0) {
                 let reason = "kh√¥ng r√µ";
                 if (!stageInfo || stageInfo.isError) reason = "l·ªói d·ªØ li·ªáu c√¢y";
                 else if (!stageInfo.isMature) reason = "c√¢y ch∆∞a ch√≠n";
                 else if (plot.hasPest) reason = "c√¢y ƒëang b·ªã s√¢u";
                 else if (plot.health <= 0) reason = "c√¢y ƒë√£ ch·∫øt";
                 showMessage(`Kh√¥ng th·ªÉ b√°n ngay ${seedInfo.name} v√¨ ${reason}!`, "warning");
                 return;
             }

             // --- Th·ª±c hi·ªán b√°n tr·ª±c ti·∫øp ---
             const quantitySold = 1;
             // Gi√° tr·ªã b√°n = S·ªë l∆∞·ª£ng * (T·ªâ l·ªá m√°u/100 * Gi√° tr·ªã g·ªëc) - l√†m tr√≤n
             const healthMultiplier = plot.health / 100;
             const baseYield = seedInfo.harvestYield || 0;
             const earnings = Math.round(quantitySold * healthMultiplier * baseYield);
             const fertilityBeforeSell = plot.fertility;
             let penaltyFactorBeforeSell = plot.barrenHarvestPenaltyFactor || 1.0;
             const fenceDataBeforeResetSell = plot.fenceData; // <<<< L∆∞u fenceData

             // C·ªông ti·ªÅn
             gameState.currency += earnings;

             // --- [C·∫¨P NH·∫¨T] Reset √¥ ƒë·∫•t gi·ªëng h·ªát thu ho·∫°ch, GI·ªÆ L·∫†I fenceData ---
             const soldItemId = plot.seedId;
             plot.seedId = null;
             plot.plantTime = null;
             plot.hasPest = false;
             plot.health = INITIAL_PLANT_HEALTH;
             plot.causeOfDeath = null;
             plot.pestDeathClickCount = 0;
             plot.isDry = false; // <<<< Th√™m reset kh√¥ h·∫°n
             // --- Reset Buff khi B√°n Ngay ---
             plot.fertilizerGrowthUsageCount = 0; // Reset b·ªô ƒë·∫øm khi b√°n ngay
             plot.fertilizerProtectUsageCount = 0; // Reset b·ªô ƒë·∫øm khi b√°n ngay
             plot.hasFertilizerProtectBuff = false; // Reset buff khi b√°n ngay
             // --- K·∫øt Th√∫c Reset Buff ---
             // plot.fertility kh√¥ng ƒë·ªïi
             plot.fenceData = fenceDataBeforeResetSell; // <<<< G√ÅN L·∫†I FENCEDATA

             // X·ª≠ l√Ω penalty ƒë·∫•t c·∫±n
             let penaltyAppliedSell = false;
             if (fertilityBeforeSell <= 0) {
                 plot.barrenHarvestPenaltyFactor = penaltyFactorBeforeSell * BARREN_HARVEST_PENALTY_MULTIPLIER;
                 penaltyAppliedSell = true;
                 console.log(`√î ${plotId} b√°n tr√™n ƒë·∫•t c·∫±n. Penalty factor tƒÉng l√™n ${plot.barrenHarvestPenaltyFactor.toFixed(2)}`);
             } else {
                 // Ch·ªâ reset n·∫øu ƒëang kh√°c 1.0
                 if(plot.barrenHarvestPenaltyFactor !== 1.0) {
                     plot.barrenHarvestPenaltyFactor = 1.0; // Reset n·∫øu ƒë·∫•t kh√¥ng c·∫±n
                 }
             }
             // --- K·∫øt th√∫c Reset ---

			 updateDailyQuestProgress('sell_direct', 1, soldItemId, earnings); // C·∫≠p nh·∫≠t NV b√°n tr·ª±c ti·∫øp v√† ki·∫øm ti·ªÅn
             // C·∫≠p nh·∫≠t UI v√† L∆∞u game
             renderUI();
             updateShopButtons();
             renderGarden(); // V·∫Ω l·∫°i v∆∞·ªùn, h√†ng r√†o (n·∫øu c√≥) s·∫Ω v·∫´n hi·ªÉn th·ªã tr√™n √¥ tr·ªëng
             saveGame();

             // Hi·ªÉn th·ªã th√¥ng b√°o b√°n
             let sellMessage = `ƒê√£ b√°n tr·ª±c ti·∫øp ${quantitySold} ${seedInfo.name}! +${earnings}üí∞.`;
             const fertilityAfterSell = plot.fertility;
             sellMessage += `\nƒê·ªô ph√¨ nhi√™u c√≤n l·∫°i: ${fertilityAfterSell.toFixed(0)}%.`;
              if (fertilityAfterSell <= 0) {
                   sellMessage += `\nC·∫¢NH B√ÅO: ƒê·∫•t ƒë√£ C·∫∞N KI·ªÜT!`;
                   if(penaltyAppliedSell) {
                        sellMessage += ` L·∫ßn tr·ªìng t·ªõi s·∫Ω m·ªçc ch·∫≠m x${plot.barrenHarvestPenaltyFactor.toFixed(2)}!`;
                   }
              }
              else if (fertilityAfterSell < LOW_FERTILITY_THRESHOLD) sellMessage += `\nC·∫¢NH B√ÅO: ƒê·∫•t kh√° c·∫±n!`;

             showMessage(sellMessage, "success", sellMessage.includes('\n') ? MESSAGE_DISPLAY_TIME + 1500 : MESSAGE_DISPLAY_TIME);

             // Log Action
             logAction('sell_direct', plotId, `√î ${plotId + 1}: B√°n tr·ª±c ti·∫øp ${quantitySold} ${seedInfo.name} (+${earnings}üí∞).`, 'üí∞', soldItemId);
        }

        /** H√†nh ƒë·ªông: B·∫Øt ƒë·∫ßu qu√° tr√¨nh tr·ªìng c√¢y cho √¥ ƒë·∫•t tr·ªëng -> M·ªü modal ch·ªçn h·∫°t gi·ªëng. */
        function selectPlotForPlanting(plotId) {
             if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || gameState.plots[plotId].seedId) {
                  showMessage("√î ƒë·∫•t n√†y kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ c√≥ c√¢y tr·ªìng r·ªìi.", "error");
                  console.warn(`C·ªë g·∫Øng tr·ªìng tr√™n √¥ ${plotId} kh√¥ng tr·ªëng/b·ªã kh√≥a/kh√¥ng h·ª£p l·ªá.`);
                  closeModal('empty-plot-action-modal');
                  currentActionPlotId = null; return;
             }
             if (!checkHasSeeds(true)) {
                 closeModal('empty-plot-action-modal');
                 currentActionPlotId = null; return;
             }
             currentPlantingPlotId = plotId; // L∆∞u ID √¥ ƒë·ªÉ tr·ªìng
             populateSeedSelection();
             openModal('seed-selection-modal');
             closeModal('empty-plot-action-modal'); // ƒê√≥ng modal h√†nh ƒë·ªông √¥ tr·ªëng
             currentActionPlotId = null; // Reset ID h√†nh ƒë·ªông
        }

        /** Ki·ªÉm tra xem ng∆∞·ªùi ch∆°i c√≥ h·∫°t gi·ªëng trong kho ƒê√É MUA kh√¥ng. */
        function checkHasSeeds(showMsgIfEmpty = true) {
            let hasSeeds = Object.keys(gameState.inventory).some(itemId => {
                const item = ITEM_DATA[itemId];
                return item && item.type === 'seed' && gameState.inventory[itemId] > 0;
            });
             if (!hasSeeds && showMsgIfEmpty) {
                 showMessage("B·∫°n ch∆∞a c√≥ h·∫°t gi·ªëng n√†o (trong kho ƒë√£ mua)! H√£y gh√© qua c·ª≠a h√†ng.", "error");
                 switchShopTab('seeds');
                 openModal('shop-modal');
                 return false;
             }
             return hasSeeds;
        }


         /** H√†m chung ƒë·ªÉ mua v·∫≠t ph·∫©m, th√™m v√†o kho ƒê√É MUA (gameState.inventory). */
          function buyItem(itemId, quantity) {
        console.log(`[V10 Buy Fix buyItem] Attempting to buy itemId: ${itemId}, quantity: ${quantity}`);
        const item = ITEM_DATA[itemId];

        // 1. Validate Item
        if (!item) {
            showMessage("L·ªói: V·∫≠t ph·∫©m kh√¥ng t·ªìn t·∫°i!", "error");
            console.error(`[V10 Buy Fix buyItem] ERROR: Item data not found for ID: ${itemId}`);
            return;
        }
         console.log(`[V10 Buy Fix buyItem] Item found: ${item.name}, Price: ${item.price}, Type: ${item.type}`);

        // 2. Validate Quantity (l√†m l·∫°i ƒë·ªÉ ch·∫Øc ch·∫Øn)
        let validQuantity = parseInt(quantity);
        if (isNaN(validQuantity) || validQuantity < 1) {
            console.warn(`[V10 Buy Fix buyItem] Invalid quantity (${quantity}) received, defaulting to 1.`);
            validQuantity = 1;
        }
        const maxBuyQuantity = 99; // Ho·∫∑c l·∫•y t·ª´ c·∫•u h√¨nh n·∫øu c√≥
        if (validQuantity > maxBuyQuantity) {
            showMessage(`Ch·ªâ c√≥ th·ªÉ mua t·ªëi ƒëa ${maxBuyQuantity} "${item.name}" m·ªói l·∫ßn.`, "warning");
            console.warn(`[V10 Buy Fix buyItem] Quantity (${validQuantity}) clamped to max (${maxBuyQuantity}).`);
            validQuantity = maxBuyQuantity;
            // C·∫≠p nh·∫≠t l·∫°i input trong shop n·∫øu ƒëang m·ªü
             if (shopModal.style.display === 'block') {
                const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
                const inputEl = listContainer?.querySelector(`#qty-${itemId}`);
                if(inputEl) inputEl.value = maxBuyQuantity;
             }
        }
         console.log(`[V10 Buy Fix buyItem] Validated quantity: ${validQuantity}`);

        // 3. Calculate Cost and Check Currency
        const totalCost = (item.price || 0) * validQuantity;
         console.log(`[V10 Buy Fix buyItem] Calculated totalCost: ${totalCost}, Current currency: ${gameState.currency}`);
        if (gameState.currency < totalCost) {
            showMessage(`Kh√¥ng ƒë·ªß ti·ªÅn! C·∫ßn ${totalCost}üí∞, b·∫°n ch·ªâ c√≥ ${gameState.currency}üí∞.`, "error");
            console.warn(`[V10 Buy Fix buyItem] Insufficient funds.`);
            // C·∫≠p nh·∫≠t l·∫°i n√∫t trong shop ƒë·ªÉ ƒë·∫£m b·∫£o n√≥ disabled
            if (shopModal.style.display === 'block') {
                const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
                const cardEl = listContainer?.querySelector(`.item-card[data-item-id="${itemId}"]`);
                if(cardEl) updateSeedTotalCost(itemId, cardEl);
            }
            return;
        }

        // 4. Check Inventory Capacity
        const currentTotalCount = getTotalInventoryCount();
        const quantityToBuy = validQuantity; // S·ªë l∆∞·ª£ng th·ª±c t·∫ø s·∫Ω mua
         console.log(`[V10 Buy Fix buyItem] Current inventory count: ${currentTotalCount}, Max capacity: ${gameState.maxInventoryCapacity}, Buying: ${quantityToBuy}`);
        if (currentTotalCount + quantityToBuy > gameState.maxInventoryCapacity) {
            const spaceAvailable = Math.max(0, gameState.maxInventoryCapacity - currentTotalCount); // ƒê·∫£m b·∫£o kh√¥ng √¢m
            let buyErrorMsg = `Kho ƒë·ªì ƒë√£ ƒë·∫ßy (${currentTotalCount}/${gameState.maxInventoryCapacity})!`;
            if (spaceAvailable > 0) {
                buyErrorMsg += ` Ch·ªâ c√≥ th·ªÉ mua th√™m t·ªëi ƒëa ${spaceAvailable} v·∫≠t ph·∫©m.`;
                // C·∫≠p nh·∫≠t input v·ªÅ s·ªë l∆∞·ª£ng t·ªëi ƒëa c√≥ th·ªÉ mua
                if (shopModal.style.display === 'block') {
                    const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
                    const inputEl = listContainer?.querySelector(`#qty-${itemId}`);
                    if(inputEl && parseInt(inputEl.value) > spaceAvailable) {
                        inputEl.value = spaceAvailable;
                        // G·ªçi l·∫°i update cost ƒë·ªÉ c·∫≠p nh·∫≠t gi√° v√† n√∫t
                         const cardEl = listContainer?.querySelector(`.item-card[data-item-id="${itemId}"]`);
                         if(cardEl) updateSeedTotalCost(itemId, cardEl);
                         console.log(`[V10 Buy Fix buyItem] Updated shop input to available space: ${spaceAvailable}`);
                    }
                }
            } else {
                buyErrorMsg += ` Kh√¥ng th·ªÉ mua th√™m v·∫≠t ph·∫©m.`;
                // Disable n√∫t mua n·∫øu ƒëang ·ªü shop
                 if (shopModal.style.display === 'block') {
                    const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
                    const cardEl = listContainer?.querySelector(`.item-card[data-item-id="${itemId}"]`);
                    if(cardEl) {
                        const buyBtn = cardEl.querySelector('.buy-seed-button');
                        if(buyBtn) buyBtn.disabled = true;
                        console.log(`[V10 Buy Fix buyItem] Disabled buy button due to full inventory.`);
                    }
                 }
            }
            showMessage(buyErrorMsg, "error");
            console.warn(`[V10 Buy Fix buyItem] Inventory full. Available space: ${spaceAvailable}`);
            return; // D·ª´ng vi·ªác mua h√†ng
        }

        // --- 5. Perform Purchase ---
         console.log(`[V10 Buy Fix buyItem] Proceeding with purchase... Deducing ${totalCost} currency.`);
        gameState.currency -= totalCost;
        // ƒê·∫£m b·∫£o inventory l√† object
        if (typeof gameState.inventory !== 'object' || gameState.inventory === null) {
            gameState.inventory = {};
        }
        gameState.inventory[itemId] = (gameState.inventory[itemId] || 0) + quantityToBuy;
         console.log(`[V10 Buy Fix buyItem] Added ${quantityToBuy} to inventory for ${itemId}. New count: ${gameState.inventory[itemId]}`);
		updateDailyQuestProgress('buy_item', quantityToBuy, itemId); // C·∫≠p nh·∫≠t NV mua h·∫°t gi·ªëng/ph√¢n b√≥n


        // --- 6. Update UI & Save ---
        try {
             console.log(`[V10 Buy Fix buyItem] Updating UI elements...`);
            renderUI(); // C·∫≠p nh·∫≠t ti·ªÅn
            updateShopButtons(); // C·∫≠p nh·∫≠t c√°c n√∫t trong shop (quan tr·ªçng sau khi ti·ªÅn thay ƒë·ªïi)
            if (inventoryModal.style.display === 'block') renderInventory();
            if (seedSelectionModal.style.display === 'block' && item.type === 'seed') populateSeedSelection();
            if (fertilizerSelectionModal.style.display === 'block' && item.type === 'tool' && typeof item.fertilityBoost === 'number') populateFertilizerSelection();
            // C·∫≠p nh·∫≠t c√°c modal h√†nh ƒë·ªông n·∫øu ch√∫ng ƒëang m·ªü
            if (currentActionPlotId !== null && gameState.plots[currentActionPlotId]) {
                 if (plantActionModal.style.display === 'block') updatePlantActionModalButtons(currentActionPlotId);
                 if (emptyPlotActionModal.style.display === 'block') updateEmptyPlotActionModal(currentActionPlotId);
                 if (lightningRodActionModal.style.display === 'block' && isPlotWithRod(currentActionPlotId)) updateLightningRodActionModal(currentActionPlotId);
            }
        } catch(e) {
             console.error("[V10 Buy Fix buyItem] Error during UI updates after purchase:", e);
        }

         console.log(`[V10 Buy Fix buyItem] Showing success message and saving game...`);
        showMessage(`ƒê√£ mua th√†nh c√¥ng ${quantityToBuy} ${item.name}! Th√™m v√†o kho "ƒê√£ Mua".`, "success");
        saveGame(); // L∆∞u tr·∫°ng th√°i m·ªõi
        logAction('buy_item', null, `Mua c·ª≠a h√†ng: ${quantityToBuy} ${item.name} (-${totalCost}üí∞).`, 'üõí', itemId);

        // --- 7. Reset Input in Shop ---
        if (shopModal.style.display === 'block') {
            console.log(`[V10 Buy Fix buyItem] Resetting quantity input in shop for ${itemId}...`);
            const listContainer = (item.type === 'seed') ? shopSeedList : shopToolList;
            const itemCard = listContainer?.querySelector(`.item-card[data-item-id="${itemId}"]`);
            if (itemCard) {
                const quantityInput = itemCard.querySelector(`#qty-${itemId}`);
                if (quantityInput) quantityInput.value = 1; // Reset v·ªÅ 1
                try {
                    updateSeedTotalCost(itemId, itemCard); // C·∫≠p nh·∫≠t l·∫°i gi√° v√† n√∫t cho s·ªë l∆∞·ª£ng 1
                     console.log(`[V10 Buy Fix buyItem] Shop input reset and cost updated for ${itemId}.`);
                } catch (e) {
                     console.error(`[V10 Buy Fix buyItem] Error calling updateSeedTotalCost after shop input reset:`, e);
                }
            } else {
                 console.warn(`[V10 Buy Fix buyItem] Could not find item card in shop to reset input for ${itemId}.`);
            }
        }
         console.log(`[V10 Buy Fix buyItem] Purchase process completed for ${itemId}.`);
    }

        /** Tr·ªìng m·ªôt h·∫°t gi·ªëng c·ª• th·ªÉ t·ª´ kho ƒê√É MUA. */
                /** Tr·ªìng m·ªôt h·∫°t gi·ªëng c·ª• th·ªÉ t·ª´ kho ƒê√É MUA. */
        function plantSeed(plotId, seedId) {
            if (plotId === null || plotId >= gameState.maxUnlockedPlots || !gameState.plots[plotId] || gameState.plots[plotId].seedId) {
                showMessage("√î ƒë·∫•t kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ c√≥ c√¢y.", "error");
                console.warn(`C·ªë g·∫Øng tr·ªìng tr√™n √¥ ${plotId} kh√¥ng tr·ªëng/b·ªã kh√≥a/kh√¥ng h·ª£p l·ªá.`);
                // ƒê√≥ng modal ch·ªçn h·∫°t gi·ªëng n·∫øu ƒëang m·ªü v√† c√≥ l·ªói
                if (seedSelectionModal.style.display === 'block') closeModal('seed-selection-modal');
                currentPlantingPlotId = null; // Reset ID ƒëang tr·ªìng
                return;
            }
            const plot = gameState.plots[plotId];
            const seed = ITEM_DATA[seedId];

            if (!seed || seed.type !== 'seed' || (gameState.inventory[seedId] || 0) <= 0) {
                 showMessage("H·∫°t gi·ªëng kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt (trong kho ƒë√£ mua).", "error");
                 if (seedSelectionModal.style.display === 'block') populateSeedSelection(); // C·∫≠p nh·∫≠t l·∫°i modal n·∫øu c√≤n m·ªü
                 currentPlantingPlotId = null; // Reset ID ƒëang tr·ªìng
                 return;
            }

            // --- Th·ª±c hi·ªán tr·ªìng ---
            gameState.inventory[seedId]--; // Tr·ª´ h·∫°t gi·ªëng kh·ªèi kho ƒë√£ mua
            plot.seedId = seedId;
            plot.plantTime = Date.now();
            plot.hasPest = false;
            plot.health = INITIAL_PLANT_HEALTH;
            plot.causeOfDeath = null;
            plot.pestDeathClickCount = 0;
            // plot.fertility v√† plot.barrenHarvestPenaltyFactor gi·ªØ nguy√™n t·ª´ tr·∫°ng th√°i √¥ ƒë·∫•t tr·ªëng tr∆∞·ªõc ƒë√≥

            // --- Reset Buff khi Tr·ªìng M·ªõi ---
            plot.fertilizerProtectUsageCount = 0; // Reset b·ªô ƒë·∫øm khi tr·ªìng m·ªõi
            plot.hasFertilizerProtectBuff = false; // Reset buff khi tr·ªìng m·ªõi
            // --- K·∫øt Th√∫c Reset Buff ---

			

		    updateDailyQuestProgress('plant', 1, seedId); // C·∫≠p nh·∫≠t NV tr·ªìng c√¢y c·ª• th·ªÉ v√† b·∫•t k·ª≥
            renderGarden(); // V·∫Ω l·∫°i ƒë·ªÉ hi·ªán c√¢y v√† thanh m√°u
            saveGame(); // L∆∞u tr·∫°ng th√°i game
            if (inventoryModal.style.display === 'block') renderInventory(); // C·∫≠p nh·∫≠t kho ƒë·ªì n·∫øu ƒëang m·ªü

            let plantMessage = `ƒê√£ gieo h·∫°t ${seed.name} v√†o √¥ ${plotId + 1}!`;
            const currentFertility = plot.fertility;
            const isBarren = currentFertility <= 0;
            const currentPenalty = plot.barrenHarvestPenaltyFactor || 1.0;

            // C·∫£nh b√°o n·∫øu tr·ªìng tr√™n ƒë·∫•t c·∫±n
            if (isBarren && currentPenalty > 1.0) {
                 plantMessage += `\nC·∫¢NH B√ÅO: ƒê·∫•t C·∫∞N KI·ªÜT! Th·ªùi gian m·ªçc s·∫Ω b·ªã NH√ÇN L√äN x${currentPenalty.toFixed(2)}!`;
            } else if (isBarren) {
                 plantMessage += `\nC·∫¢NH B√ÅO: ƒê·∫•t C·∫∞N KI·ªÜT! Th·ªùi gian m·ªçc c√≥ th·ªÉ b·ªã ·∫£nh h∆∞·ªüng.`;
            } else if (currentFertility < LOW_FERTILITY_THRESHOLD) {
                 plantMessage += ` (Ch√∫ √Ω: ƒê·∫•t kh√° c·∫±n [${Math.round(currentFertility)}%], c√¢n nh·∫Øc b√≥n ph√¢n!)`;
            }

            showMessage(plantMessage, isBarren ? "error" : (currentFertility < LOW_FERTILITY_THRESHOLD ? "warning" : "success"), plantMessage.includes('\n') ? MESSAGE_DISPLAY_TIME + 1500 : MESSAGE_DISPLAY_TIME);

            // <<< TH√äM LOG ACTION >>>
            logAction('plant', plotId, `√î ${plotId + 1}: ƒê√£ gieo h·∫°t ${seed.name}.`, 'üå±', seedId);
            // <<< K·∫æT TH√öC LOG ACTION >>>

            currentPlantingPlotId = null; // Reset ID ƒëang tr·ªìng sau khi ho√†n t·∫•t
        }


        /** T√≠nh to√°n chi ph√≠ ƒë·ªÉ m·ªü kh√≥a √¥ ƒë·∫•t ti·∫øp theo */
        function calculatePlotCost(targetPlotIndex) {
            // N·∫øu √¥ ƒë·∫•t thu·ªôc nh√≥m mi·ªÖn ph√≠ ban ƒë·∫ßu, kh√¥ng t·ªën chi ph√≠
            if (targetPlotIndex < INITIAL_PLOT_COUNT) {
                console.warn(`calculatePlotCost ƒë∆∞·ª£c g·ªçi cho √¥ mi·ªÖn ph√≠: ${targetPlotIndex}`);
                return 0; // Ho·∫∑c gi√° tr·ªã r·∫•t l·ªõn ƒë·ªÉ kh√¥ng mua ƒë∆∞·ª£c
            }

            let currentCost = BASE_PLOT_COST_FOR_7TH; // B·∫Øt ƒë·∫ßu v·ªõi gi√° √¥ th·ª© 7

            // N·∫øu m·ª•c ti√™u l√† √¥ th·ª© 7, tr·∫£ v·ªÅ gi√° g·ªëc
            if (targetPlotIndex === INITIAL_PLOT_COUNT) {
                return Math.floor(currentCost);
            }

            // L·∫∑p t·ª´ √¥ th·ª© 8 (index INITIAL_PLOT_COUNT + 1) ƒë·∫øn √¥ m·ª•c ti√™u
            // Bi·∫øn i ƒë·∫°i di·ªán cho *index* c·ªßa √¥ ƒëang ƒë∆∞·ª£c t√≠nh gi√° trong v√≤ng l·∫∑p
            for (let i = INITIAL_PLOT_COUNT + 1; i <= targetPlotIndex; i++) {
                let multiplier = 1.0; // H·ªá s·ªë nh√¢n m·∫∑c ƒë·ªãnh (kh√¥ng n√™n x·∫£y ra)

                // X√°c ƒë·ªãnh h·ªá s·ªë nh√¢n d·ª±a tr√™n *index* c·ªßa √¥ hi·ªán t·∫°i (i)
                if (i === INITIAL_PLOT_COUNT + 1) { // √î th·ª© 8 (index = 7)
                    multiplier = 1.3;
                } else if (i === INITIAL_PLOT_COUNT + 2) { // √î th·ª© 9 (index = 8)
                    multiplier = 1.6;
                } else { // √î th·ª© 10 (index = 9) tr·ªü ƒëi
                    multiplier = 1.8;
                }

                // Nh√¢n chi ph√≠ hi·ªán t·∫°i v·ªõi h·ªá s·ªë v√† l√†m tr√≤n xu·ªëng *·ªü m·ªói b∆∞·ªõc*
                // ƒë·ªÉ kh·ªõp v·ªõi v√≠ d·ª• (300 -> 390 -> 624 -> 1123)
                currentCost = Math.floor(currentCost * multiplier);
            }

            return currentCost; // Tr·∫£ v·ªÅ chi ph√≠ cu·ªëi c√πng ƒë√£ t√≠nh cho √¥ targetPlotIndex
        }

        /** X·ª≠ l√Ω click v√†o √¥ ƒë·∫•t b·ªã kh√≥a -> Th·ª≠ mua √¥ ƒë·∫•t m·ªõi */
        function handleLockedPlotClick(plotId) {
        // Ch·ªâ cho ph√©p mua √¥ ti·∫øp theo li·ªÅn k·ªÅ
        if (plotId !== gameState.maxUnlockedPlots) {
            showMessage(`M·ªü kh√≥a √¥ ${gameState.maxUnlockedPlots + 1} tr∆∞·ªõc!`, "warning");
            return;
        }
        const cost = calculatePlotCost(plotId);
        const hasEnoughMoney = gameState.currency >= cost;

        // C·∫≠p nh·∫≠t n·ªôi dung v√† tr·∫°ng th√°i popup
        lockedPlotMessage.innerHTML = `M·ªü kh√≥a √¥ ƒë·∫•t s·ªë ${plotId + 1} v·ªõi gi√° <strong>${cost}üí∞</strong>? <br>(B·∫°n ƒëang c√≥: ${gameState.currency}üí∞)`; // D√πng innerHTML ƒë·ªÉ nh·∫≠n th·∫ª strong
        confirmBuyPlotBtn.disabled = !hasEnoughMoney;
        confirmBuyPlotBtn.title = hasEnoughMoney ? `Chi ${cost}üí∞ ƒë·ªÉ m·ªü kh√≥a` : `Kh√¥ng ƒë·ªß ti·ªÅn (C·∫ßn ${cost}üí∞)`;

        // L∆∞u th√¥ng tin c·∫ßn thi·∫øt v√†o n√∫t Mua ƒë·ªÉ x·ª≠ l√Ω sau
        confirmBuyPlotBtn.dataset.plotId = plotId;
        confirmBuyPlotBtn.dataset.cost = cost;

        // Hi·ªÉn th·ªã popup
        openLockedPlotPopup(); // S·ª≠ d·ª•ng h√†m tr·ª£ gi√∫p m·ªõi (s·∫Ω ƒë·ªãnh nghƒ©a ·ªü d∆∞·ªõi)
    }

        /** X·ª≠ l√Ω click v√†o n√∫t B√°n ho·∫∑c input s·ªë l∆∞·ª£ng trong tab ƒê√£ Thu Ho·∫°ch */
        function handleSellHarvestedClick(event) {
    const sellButton = event.target.closest('.sell-selected-button');
    const sellAllButton = event.target.closest('.sell-all-button');
    const quantityInput = event.target;

    if (sellButton) { // X·ª≠ l√Ω n√∫t "B√°n" (s·ªë l∆∞·ª£ng ƒë√£ ch·ªçn)
        const itemCard = sellButton.closest('.item-card');
        if (!itemCard) return;
        const itemId = itemCard.dataset.itemId;
        const inputElement = itemCard.querySelector(`#sell-qty-${itemId}`);
        if (!inputElement || !itemId) return;

        // Ki·ªÉm tra d·ªØ li·ªáu ch·∫•t l∆∞·ª£ng t·ªìn t·∫°i tr∆∞·ªõc khi l·∫•y max
        const qualityDataForMax = gameState.harvestedItems[itemId];
        if (!qualityDataForMax || typeof qualityDataForMax !== 'object') {
            console.warn(`handleSellHarvestedClick (sellButton): Missing or invalid quality data for ${itemId}`);
            // C√≥ th·ªÉ render l·∫°i inventory ƒë·ªÉ x√≥a item l·ªói
            if (inventoryModal.style.display === 'block') renderInventory();
            return;
        }
        // T√≠nh l·∫°i max d·ª±a tr√™n qualityData hi·ªán t·∫°i
        const currentMax = Object.values(qualityDataForMax).reduce((sum, count) => sum + (count || 0), 0);
        inputElement.max = currentMax; // C·∫≠p nh·∫≠t max attribute tr√™n input

        let quantityToSell = parseInt(inputElement.value);

        if (isNaN(quantityToSell) || quantityToSell < 1) {
            showMessage("S·ªë l∆∞·ª£ng b√°n kh√¥ng h·ª£p l·ªá.", "warning");
            inputElement.value = 1;
            return;
        }
        // Ki·ªÉm tra l·∫°i v·ªõi max v·ª´a c·∫≠p nh·∫≠t
        if (quantityToSell > currentMax) {
            showMessage(`B·∫°n ch·ªâ c√≥ ${currentMax} ${ITEM_DATA[itemId]?.name || 'v·∫≠t ph·∫©m'} ƒë·ªÉ b√°n.`, "warning");
            inputElement.value = currentMax;
            quantityToSell = currentMax;
        }
        // G·ªçi h√†m b√°n v·ªõi s·ªë l∆∞·ª£ng ƒë√£ ƒë∆∞·ª£c ki·ªÉm tra
        sellHarvestedItem(itemId, quantityToSell);

    } else if (sellAllButton) { // [ƒê√É S·ª¨A L·ªñI] X·ª≠ l√Ω n√∫t "B√°n H·∫øt" -> M·ªü x√°c nh·∫≠n
        const itemCard = sellAllButton.closest('.item-card');
        if (!itemCard) return;
        const itemId = itemCard.dataset.itemId;
        const item = ITEM_DATA[itemId];
        // Th√™m ki·ªÉm tra item h·ª£p l·ªá v√† l√† h·∫°t gi·ªëng
        if (!item || !itemId || item.type !== 'seed') {
            console.error(`Sell All Error: Invalid item, itemId, or not a seed: ${itemId}`);
            return;
        }

        const qualityData = gameState.harvestedItems[itemId]; // L·∫•y object ch·∫•t l∆∞·ª£ng

        // --- [S·ª¨A L·ªñI] ---
        // Ki·ªÉm tra xem qualityData c√≥ t·ªìn t·∫°i v√† l√† object kh√¥ng
        if (!qualityData || typeof qualityData !== 'object') {
            showMessage(`Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ch·∫•t l∆∞·ª£ng cho ${item.name} ƒë·ªÉ b√°n h·∫øt.`, "warning");
            // D·ªçn d·∫πp d·ªØ li·ªáu l·ªói n·∫øu c√≥
            if (gameState.harvestedItems[itemId]) delete gameState.harvestedItems[itemId];
            if (inventoryModal.style.display === 'block') renderInventory(); // Render l·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t UI
            return;
        }

        // 1. T√≠nh l·∫°i T·ªîNG S·ªê L∆Ø·ª¢NG ch√≠nh x√°c t·ª´ object ch·∫•t l∆∞·ª£ng
        let totalQuantityToSellAll = 0;
        for (const tier in qualityData) {
            // ƒê·∫£m b·∫£o ch·ªâ duy·ªát qua c√°c tier h·ª£p l·ªá ƒë√£ ƒë·ªãnh nghƒ©a
            if (QUALITY_TIERS[tier.toUpperCase()]) {
                totalQuantityToSellAll += (qualityData[tier] || 0);
            }
        }

        // 2. T√≠nh l·∫°i T·ªîNG GI√Å TR·ªä B√ÅN ch√≠nh x√°c
        let correctTotalEarnings = 0;
        const baseValue = item.harvestYield || 0;
        for (const tier in qualityData) {
             // ƒê·∫£m b·∫£o ch·ªâ duy·ªát qua c√°c tier h·ª£p l·ªá ƒë√£ ƒë·ªãnh nghƒ©a
            if (QUALITY_TIERS[tier.toUpperCase()]) {
                const count = qualityData[tier] || 0;
                if (count > 0) {
                    const multiplier = QUALITY_VALUE_MULTIPLIERS[tier] || 0; // L·∫•y h·ªá s·ªë nh√¢n
                    // Gi√° tr·ªã c·ªßa tier = s·ªë l∆∞·ª£ng * (gi√° g·ªëc * h·ªá s·ªë) - L√†m tr√≤n ·ªü ƒë√¢y
                    correctTotalEarnings += count * Math.round(baseValue * multiplier);
                }
            }
        }
        // --- [K·∫æT TH√öC S·ª¨A L·ªñI] ---

        // Ki·ªÉm tra l·∫°i t·ªïng s·ªë l∆∞·ª£ng sau khi t√≠nh to√°n
        if (totalQuantityToSellAll <= 0) {
            showMessage(`Kh√¥ng c√≥ ${item.name} ƒë·ªÉ b√°n h·∫øt.`, "warning");
            // D·ªçn d·∫πp n·∫øu total l√† 0 nh∆∞ng entry v·∫´n c√≤n
            if (gameState.harvestedItems[itemId]) delete gameState.harvestedItems[itemId];
            if (inventoryModal.style.display === 'block') renderInventory();
            return;
        }

        const itemName = item.name;

        // M·ªü h·ªôp tho·∫°i x√°c nh·∫≠n v·ªõi c√°c gi√° tr·ªã ƒê√É T√çNH TO√ÅN L·∫†I
        openConfirmSellAllModal(itemId, itemName, totalQuantityToSellAll, correctTotalEarnings);

    } else if (quantityInput && quantityInput.classList.contains('sell-quantity-input')) {
        // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng thay ƒë·ªïi input (logic c≈© gi·ªØ nguy√™n, nh∆∞ng ki·ªÉm tra max)
        const itemCard = quantityInput.closest('.item-card');
        const itemId = itemCard?.dataset.itemId;
        if (!itemId) return; // C·∫ßn itemId ƒë·ªÉ l·∫•y d·ªØ li·ªáu ch·∫•t l∆∞·ª£ng

        const qualityDataForMaxUpdate = gameState.harvestedItems[itemId];
        if (!qualityDataForMaxUpdate || typeof qualityDataForMaxUpdate !== 'object') {
             console.warn(`handleSellHarvestedClick (input change): Missing or invalid quality data for ${itemId}`);
             return;
        }
        // T√≠nh l·∫°i max d·ª±a tr√™n qualityData hi·ªán t·∫°i
        const currentMaxUpdate = Object.values(qualityDataForMaxUpdate).reduce((sum, count) => sum + (count || 0), 0);
        quantityInput.max = currentMaxUpdate; // C·∫≠p nh·∫≠t max attribute

        let currentValue = parseInt(quantityInput.value);
        const rawValue = quantityInput.value;

        if (rawValue === '' || isNaN(currentValue) || currentValue < 1) {
            // Kh√¥ng ƒë·∫∑t l·∫°i value = 1 ngay, ch·ªâ c·∫£nh b√°o n·∫øu c·∫ßn
            // quantityInput.value = 1;
        }
        else if (currentValue > currentMaxUpdate) {
            quantityInput.value = currentMaxUpdate; // ƒê·∫∑t l·∫°i gi√° tr·ªã n·∫øu v∆∞·ª£t qu√° max
            showMessage(`B·∫°n ch·ªâ c√≥ ${currentMaxUpdate} ƒë·ªÉ b√°n.`, "warning");
        }
    }
}

        /** B√°n s·ªë l∆∞·ª£ng c·ª• th·ªÉ v·∫≠t ph·∫©m t·ª´ kho ƒê√£ Thu Ho·∫°ch */
         function sellHarvestedItem(itemId, quantityToSell) {
    const item = ITEM_DATA[itemId];
    const qualityData = gameState.harvestedItems[itemId];

    // --- Ki·ªÉm tra c∆° b·∫£n ---
    if (!item || item.type !== 'seed') {
        showMessage("L·ªói: Kh√¥ng th·ªÉ b√°n v·∫≠t ph·∫©m kh√¥ng h·ª£p l·ªá.", "error"); return;
    }
    if (!qualityData) {
        showMessage(`B·∫°n kh√¥ng c√≥ ${item.name} ƒë·ªÉ b√°n.`, "error");
        // D·ªçn d·∫πp n·∫øu qualityData kh√¥ng t·ªìn t·∫°i nh∆∞ng key c√≥ trong harvestedItems
        if (gameState.harvestedItems[itemId]) delete gameState.harvestedItems[itemId];
        if (inventoryModal.style.display === 'block') renderInventory();
        return;
    }

    // T√≠nh t·ªïng s·ªë l∆∞·ª£ng hi·ªán c√≥
    const currentTotalQuantity = (qualityData[QUALITY_TIERS.PERFECT] || 0) +
                                 (qualityData[QUALITY_TIERS.GOOD] || 0) +
                                 (qualityData[QUALITY_TIERS.FAIR] || 0) +
                                 (qualityData[QUALITY_TIERS.POOR] || 0);

    if (currentTotalQuantity <= 0) {
        showMessage(`B·∫°n kh√¥ng c√≤n ${item.name} ƒë·ªÉ b√°n.`, "error");
        delete gameState.harvestedItems[itemId]; // D·ªçn d·∫πp n·∫øu c·∫ßn
        if (inventoryModal.style.display === 'block') renderInventory();
        return;
    }

    // --- Validate s·ªë l∆∞·ª£ng b√°n ---
    let actualSellQuantity = parseInt(quantityToSell);
    if (isNaN(actualSellQuantity) || actualSellQuantity <= 0) {
        showMessage("S·ªë l∆∞·ª£ng b√°n kh√¥ng h·ª£p l·ªá.", "error");
        // Reset input n·∫øu ƒëang m·ªü kho
        if (inventoryModal.style.display === 'block') {
            const inputElement = inventoryHarvestedList.querySelector(`#sell-qty-${itemId}`);
            if(inputElement) inputElement.value = 1;
        }
        return;
    }
    if (actualSellQuantity > currentTotalQuantity) {
        showMessage(`S·ªë l∆∞·ª£ng b√°n (${actualSellQuantity}) v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng b·∫°n c√≥ (${currentTotalQuantity}).`, "error");
        actualSellQuantity = currentTotalQuantity; // T·ª± ƒë·ªông gi·∫£m v·ªÅ t·ªëi ƒëa
        // C·∫≠p nh·∫≠t input n·∫øu ƒëang m·ªü kho
        if (inventoryModal.style.display === 'block') {
             const inputElement = inventoryHarvestedList.querySelector(`#sell-qty-${itemId}`);
             if(inputElement) inputElement.value = currentTotalQuantity;
        }
    }

    // --- Th·ª±c hi·ªán b√°n, ∆∞u ti√™n ch·∫•t l∆∞·ª£ng th·∫•p ---
    let remainingToSell = actualSellQuantity;
    let totalEarnings = 0;
    const tierOrderToSell = [QUALITY_TIERS.POOR, QUALITY_TIERS.FAIR, QUALITY_TIERS.GOOD, QUALITY_TIERS.PERFECT]; // Th·ª© t·ª± ∆∞u ti√™n b√°n
    const baseValue = item.harvestYield || 0;
    let soldCounts = { poor: 0, fair: 0, good: 0, perfect: 0 }; // ƒê·ªÉ log chi ti·∫øt

    for (const tier of tierOrderToSell) {
        if (remainingToSell <= 0) break; // ƒê√£ b√°n ƒë·ªß s·ªë l∆∞·ª£ng

        const availableInTier = qualityData[tier] || 0;
        if (availableInTier > 0) {
            const sellFromThisTier = Math.min(remainingToSell, availableInTier);
            const valueMultiplier = QUALITY_VALUE_MULTIPLIERS[tier] || 0;
            const earningsFromTier = sellFromThisTier * Math.round(baseValue * valueMultiplier);

            totalEarnings += earningsFromTier;
            qualityData[tier] -= sellFromThisTier; // Gi·∫£m s·ªë l∆∞·ª£ng trong b·∫≠c n√†y
            remainingToSell -= sellFromThisTier;
            soldCounts[tier] += sellFromThisTier; // Ghi l·∫°i s·ªë l∆∞·ª£ng ƒë√£ b√°n t·ª´ b·∫≠c n√†y

            // console.log(`B√°n ${sellFromThisTier} x ${item.name} (Ch·∫•t l∆∞·ª£ng: ${tier}) v·ªõi gi√° ${earningsFromTier}üí∞`);
        }
    }

    // --- C·∫≠p nh·∫≠t tr·∫°ng th√°i game ---
    gameState.currency += totalEarnings;

    // Ki·ªÉm tra xem c√≥ c·∫ßn x√≥a item kh·ªèi kho kh√¥ng (n·∫øu t·∫•t c·∫£ ch·∫•t l∆∞·ª£ng = 0)
    const newTotalQuantity = (qualityData[QUALITY_TIERS.PERFECT] || 0) +
                             (qualityData[QUALITY_TIERS.GOOD] || 0) +
                             (qualityData[QUALITY_TIERS.FAIR] || 0) +
                             (qualityData[QUALITY_TIERS.POOR] || 0);
    if (newTotalQuantity <= 0) {
        delete gameState.harvestedItems[itemId];
        console.log(`ƒê√£ b√°n h·∫øt ${item.name} (ID: ${itemId}).`);
    }
	    // L∆∞u √Ω: actualSellQuantity l√† t·ªïng s·ªë b√°n, c·∫ßn ƒëi·ªÅu ch·ªânh n·∫øu mu·ªën ch√≠nh x√°c h∆°n
    updateDailyQuestProgress('sell_harvested', actualSellQuantity, itemId, totalEarnings); // C·∫≠p nh·∫≠t NV b√°n t·ª´ kho v√† ki·∫øm ti·ªÅn
    // C·∫≠p nh·∫≠t UI v√† L∆∞u game
    renderUI();
    updateShopButtons();
    renderInventory(); // Quan tr·ªçng: C·∫≠p nh·∫≠t l·∫°i kho ƒë·ªì
    saveGame();

    // Hi·ªÉn th·ªã th√¥ng b√°o
    let soldSummary = [];
    if(soldCounts.perfect > 0) soldSummary.push(`${soldCounts.perfect} Ho√†n h·∫£o`);
    if(soldCounts.good > 0) soldSummary.push(`${soldCounts.good} T·ªët`);
    if(soldCounts.fair > 0) soldSummary.push(`${soldCounts.fair} Th∆∞·ªùng`);
    if(soldCounts.poor > 0) soldSummary.push(`${soldCounts.poor} K√©m`);
    const summaryText = soldSummary.length > 0 ? ` (${soldSummary.join(', ')})` : '';

    showMessage(`ƒê√£ b√°n ${actualSellQuantity} ${item.name}${summaryText}! +${totalEarnings}üí∞`, "success");

    // Log Action
    logAction('sell_harvested', null, `B√°n t·ª´ kho: ${actualSellQuantity} ${item.name}${summaryText} (+${totalEarnings}üí∞).`, 'üí∞', itemId);
}


        // --- C√°c H√†m Ti·ªán √çch & Tr·ª£ Gi√∫p ---
		
		
		/** H√†m c·∫≠p nh·∫≠t ti·∫øn tr√¨nh nhi·ªám v·ª• h·∫±ng ng√†y */
     function updateDailyQuestProgress(actionType, quantity = 1, itemId = null, earnedAmount = 0) {
        if (!gameState.dailyQuests || gameState.dailyQuests.length === 0) return; // Kh√¥ng c√≥ nhi·ªám v·ª• ƒë·ªÉ c·∫≠p nh·∫≠t

        let questUpdated = false; // C·ªù theo d√µi xem c√≥ nhi·ªám v·ª• n√†o ƒë∆∞·ª£c c·∫≠p nh·∫≠t kh√¥ng

        gameState.dailyQuests.forEach((quest, index) => {
            // B·ªè qua n·∫øu nhi·ªám v·ª• ƒë√£ ho√†n th√†nh ho·∫∑c ƒë√£ nh·∫≠n th∆∞·ªüng
            if (quest.isCompleted || quest.isClaimed) return;

            let progressMade = false; // C·ªù theo d√µi xem quest *n√†y* c√≥ ti·∫øn tri·ªÉn kh√¥ng

            switch (quest.type) {
                case QUEST_TYPES.PLANT_SPECIFIC:
                    if (actionType === 'plant' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.PLANT_ANY:
                    if (actionType === 'plant') {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.HARVEST_SPECIFIC:
                    if (actionType === 'harvest' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.HARVEST_ANY:
                     if (actionType === 'harvest') {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.SELL_DIRECT_SPECIFIC:
                     if (actionType === 'sell_direct' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.SELL_HARVESTED_SPECIFIC:
                    // Gi·∫£ ƒë·ªãnh 'quantity' l√† s·ªë l∆∞·ª£ng c·ªßa 'itemId' ƒë∆∞·ª£c b√°n t·ª´ kho
                    if (actionType === 'sell_harvested' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.USE_FERTILIZER_TYPE:
                     if (actionType === 'fertilize' && quest.targetItemId === itemId) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.BUY_FERTILIZER:
                     // Ki·ªÉm tra xem c√≥ ph·∫£i l√† ph√¢n b√≥n kh√¥ng
                     if (actionType === 'buy_item' && ITEM_DATA[itemId]?.type === 'tool' && (typeof ITEM_DATA[itemId].fertilityBoost === 'number' || itemId === 'fertilizer_growth' || itemId === 'fertilizer_protect')) {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.BUY_SEED:
                     if (actionType === 'buy_item' && ITEM_DATA[itemId]?.type === 'seed') {
                        quest.currentProgress += quantity; progressMade = true;
                    }
                    break;
                case QUEST_TYPES.EARN_CURRENCY:
                     if ((actionType === 'sell_direct' || actionType === 'sell_harvested') && earnedAmount > 0) {
                        quest.currentProgress = Math.min(quest.targetQuantity, quest.currentProgress + earnedAmount);
                        progressMade = true;
                     }
                    break;
            }

            // N·∫øu c√≥ ti·∫øn tri·ªÉn cho nhi·ªám v·ª• n√†y
            if (progressMade) {
                quest.currentProgress = Math.min(quest.currentProgress, quest.targetQuantity); // ƒê·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° m·ª•c ti√™u

                // Ki·ªÉm tra xem nhi·ªám v·ª• ƒë√£ ho√†n th√†nh ch∆∞a
                if (quest.currentProgress >= quest.targetQuantity) {
                    quest.isCompleted = true;
                    // Hi·ªÉn th·ªã th√¥ng b√°o HO√ÄN TH√ÄNH ·ªû TR√äN C√ôNG (ch·ªâ 1 l·∫ßn)
                    if (!quest.notifiedCompletion) { // Th√™m c·ªù t·∫°m ƒë·ªÉ tr√°nh spam th√¥ng b√°o
                        // ===>>> G·ªåI showMessage V·ªöI THAM S·ªê 'top' <<<===
                        showMessage(`üéâ Ho√†n th√†nh nhi·ªám v·ª•: ${quest.description}`, "success", 4000, 'top');
                        quest.notifiedCompletion = true; // ƒê√°nh d·∫•u ƒë√£ th√¥ng b√°o
                    }
                }
                questUpdated = true; // ƒê√°nh d·∫•u c√≥ √≠t nh·∫•t m·ªôt nhi·ªám v·ª• ƒë∆∞·ª£c c·∫≠p nh·∫≠t
                console.log(`Quest Update: [${index}] ${quest.type} - Progress: ${quest.currentProgress}/${quest.targetQuantity}, Completed: ${quest.isCompleted}`);
            }
        });

        // N·∫øu c√≥ nhi·ªám v·ª• ƒë∆∞·ª£c c·∫≠p nh·∫≠t, render l·∫°i modal (n·∫øu ƒëang m·ªü) v√† l∆∞u game
        if (questUpdated) {
            if (dailyQuestPopup.style.display === 'block') {
                renderDailyQuests(); // C·∫≠p nh·∫≠t hi·ªÉn th·ªã n·∫øu modal ƒëang m·ªü
            }
            saveGame(); // L∆∞u tr·∫°ng th√°i game sau khi c·∫≠p nh·∫≠t nhi·ªám v·ª•
        }
    }
		
		 /** X·ª≠ l√Ω click n√∫t nh·∫≠n th∆∞·ªüng (·ª¶y quy·ªÅn s·ª± ki·ªán) */
    function handleClaimQuestReward(event) {
        const claimButton = event.target.closest('.claim-button[data-quest-index]');
        if (!claimButton || claimButton.disabled) return;

        const questIndex = parseInt(claimButton.dataset.questIndex);
        if (isNaN(questIndex) || !gameState.dailyQuests || !gameState.dailyQuests[questIndex]) {
            console.error("L·ªói khi nh·∫≠n th∆∞·ªüng: Index nhi·ªám v·ª• kh√¥ng h·ª£p l·ªá.");
            return;
        }

        const quest = gameState.dailyQuests[questIndex];

        if (!quest.isCompleted) { showMessage("Nhi·ªám v·ª• ch∆∞a ho√†n th√†nh!", "warning"); return; }
        if (quest.isClaimed) { showMessage("Ph·∫ßn th∆∞·ªüng nhi·ªám v·ª• n√†y ƒë√£ ƒë∆∞·ª£c nh·∫≠n r·ªìi.", "info"); return; }

        // --- Th·ª±c hi·ªán nh·∫≠n th∆∞·ªüng ---
        gameState.currency += quest.rewardCurrency;
        quest.isClaimed = true; // ƒê√°nh d·∫•u ƒë√£ nh·∫≠n

        // C·∫≠p nh·∫≠t UI
        renderUI(); // C·∫≠p nh·∫≠t ti·ªÅn
        renderDailyQuests(); // C·∫≠p nh·∫≠t l·∫°i danh s√°ch nhi·ªám v·ª• (ƒë·ªÉ ƒë·ªïi tr·∫°ng th√°i n√∫t)
        updateShopButtons(); // C·∫≠p nh·∫≠t n√∫t shop v√¨ ti·ªÅn thay ƒë·ªïi
        saveGame(); // L∆∞u game

        showMessage(`Nh·∫≠n th∆∞·ªüng ${quest.rewardCurrency}üí∞ t·ª´ nhi·ªám v·ª• th√†nh c√¥ng!`, "success");
        logAction('claim_quest', null, `Nh·∫≠n th∆∞·ªüng NVHN: +${quest.rewardCurrency}üí∞ (${quest.description})`, 'üèÜ');
    }

    // --- G·∫Øn Listener cho n√∫t nh·∫≠n th∆∞·ªüng (th√™m v√†o attachEventListeners) ---
    const dailyQuestListElement = document.getElementById('daily-quest-list');
    if (dailyQuestListElement) {
        dailyQuestListElement.addEventListener('click', handleClaimQuestReward);
        // listenerCount++; // TƒÉng bi·∫øn ƒë·∫øm n·∫øu b·∫°n d√πng n√≥
    } else { console.warn("[V10 AttachListeners] Daily Quest List Element not found for claim button listener."); }

		
		/**  Render danh s√°ch nhi·ªám v·ª• h·∫±ng ng√†y v√†o modal */
    function renderDailyQuests() {
    const questListElement = document.getElementById('daily-quest-list');
    const emptyMessageParagraph = questListElement.querySelector('p');

    if (!questListElement) return;

    questListElement.querySelectorAll('.quest-item').forEach(item => item.remove());

    // --- LOGIC S·∫ÆP X·∫æP M·ªöI ---
    // L·∫•y m·ªôt b·∫£n sao c·ªßa m·∫£ng quests ƒë·ªÉ s·∫Øp x·∫øp (tr√°nh thay ƒë·ªïi tr·ª±c ti·∫øp gameState n·∫øu kh√¥ng mu·ªën)
    const questsToRender = gameState.dailyQuests ? gameState.dailyQuests.slice() : [];

    if (!questsToRender || questsToRender.length === 0) {
        if (emptyMessageParagraph) {
            emptyMessageParagraph.style.display = 'block';
        } else {
            questListElement.innerHTML = `<p style="text-align: center; padding: 20px; color: #666;">Kh√¥ng c√≥ nhi·ªám v·ª• n√†o.</p>`;
        }
        return;
    }

    // S·∫Øp x·∫øp m·∫£ng questsToRender b·∫±ng h√†m so s√°nh
    questsToRender.sort(compareQuests);
    // --- K·∫æT TH√öC LOGIC S·∫ÆP X·∫æP ---

    if (emptyMessageParagraph) {
        emptyMessageParagraph.style.display = 'none';
    }

    // --- QUAN TR·ªåNG: L·∫∑p qua m·∫£ng ƒê√É S·∫ÆP X·∫æP ---
    questsToRender.forEach((quest) => { // Kh√¥ng c·∫ßn index n·ªØa n·∫øu handleClaimQuestReward l·∫•y index t·ª´ data-*
        // T√¨m index g·ªëc c·ªßa quest n√†y trong gameState.dailyQuests ƒë·ªÉ n√∫t b·∫•m ho·∫°t ƒë·ªông ƒë√∫ng
        const originalIndex = gameState.dailyQuests.findIndex(originalQuest =>
            // C·∫ßn m·ªôt c√°ch ƒë√°ng tin c·∫≠y ƒë·ªÉ x√°c ƒë·ªãnh quest g·ªëc.
            // S·ª≠ d·ª•ng k·∫øt h·ª£p nhi·ªÅu thu·ªôc t√≠nh. M√¥ t·∫£ th∆∞·ªùng l√† duy nh·∫•t trong m·ªôt ng√†y.
            originalQuest.description === quest.description &&
            originalQuest.targetQuantity === quest.targetQuantity &&
            originalQuest.rewardCurrency === quest.rewardCurrency &&
            originalQuest.type === quest.type &&
            originalQuest.targetItemId === quest.targetItemId
        );

        if (originalIndex === -1) {
             console.error("Kh√¥ng th·ªÉ t√¨m th·∫•y index g·ªëc cho nhi·ªám v·ª• ƒë√£ s·∫Øp x·∫øp:", quest);
             return; // B·ªè qua n·∫øu kh√¥ng t√¨m th·∫•y index g·ªëc
        }


        const questItem = document.createElement('div');
        questItem.classList.add('quest-item');
        questItem.classList.toggle('completed', quest.isCompleted && !quest.isClaimed);

        const progressPercent = quest.targetQuantity > 0
            ? Math.min(100, (quest.currentProgress / quest.targetQuantity) * 100)
            : (quest.isCompleted ? 100 : 0);

        let rewardHtml = `<strong>${quest.rewardCurrency}üí∞</strong>`;

        questItem.innerHTML = `
            <div class="quest-info">
                <div class="quest-title">${quest.description}</div>
                <div class="quest-progress">
                    <span class="quest-progress-text">Ti·∫øn ƒë·ªô: ${quest.currentProgress} / ${quest.targetQuantity} (${progressPercent.toFixed(0)}%)</span>
                    <div style="background-color: #e0e0e0; border-radius: 4px; height: 8px; overflow: hidden; margin-top: 4px;">
                       <div style="width: ${progressPercent}%; background-color: #4caf50; height: 100%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
                <div class="quest-reward" style="margin-top: 8px;">Ph·∫ßn th∆∞·ªüng: ${rewardHtml}</div>
            </div>
            <button class="claim-button" data-quest-index="${originalIndex}" ${quest.isCompleted && !quest.isClaimed ? '' : 'disabled'}>
                ${quest.isClaimed ? 'ƒê√£ nh·∫≠n' : (quest.isCompleted ? 'Nh·∫≠n th∆∞·ªüng' : 'Ch∆∞a xong')}
            </button>
        `;
        questListElement.appendChild(questItem);
    });
}
		
		/** L·∫•y ng√†y hi·ªán t·∫°i d∆∞·ªõi d·∫°ng chu·ªói 'YYYY-MM-DD' */
    function getCurrentDateString() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    /** L·∫•y ng·∫´u nhi√™n itemId c·ªßa h·∫°t gi·ªëng t·ª´ ITEM_DATA */
    function getRandomSeedItemId() {
        const seedIds = Object.keys(ITEM_DATA).filter(id => ITEM_DATA[id].type === 'seed');
        if (seedIds.length === 0) return null;
        return seedIds[Math.floor(Math.random() * seedIds.length)];
    }

    /** L·∫•y ng·∫´u nhi√™n itemId c·ªßa ph√¢n b√≥n t·ª´ ITEM_DATA */
    function getRandomFertilizerItemId() {
        // Ch·ªâ l·∫•y c√°c lo·∫°i ph√¢n b√≥n th·ª±c s·ª± (c√≥ fertilityBoost ho·∫∑c l√† growth/protect)
        const fertilizerIds = Object.keys(ITEM_DATA).filter(id => {
             const item = ITEM_DATA[id];
             return item.type === 'tool' && (typeof item.fertilityBoost === 'number' || id === 'fertilizer_growth' || id === 'fertilizer_protect');
        });
        if (fertilizerIds.length === 0) return null;
        return fertilizerIds[Math.floor(Math.random() * fertilizerIds.length)];
    }

     /** T·∫°o danh s√°ch nhi·ªám v·ª• h·∫±ng ng√†y m·ªõi */
    function generateDailyQuests() {
        console.log("Generating new daily quests...");
        const availableQuestTypes = Object.values(QUEST_TYPES);
        const selectedQuestTypes = [];
        const newQuests = [];
        const todayDate = getCurrentDateString();

        // Ch·ªçn 10 lo·∫°i nhi·ªám v·ª• kh√°c nhau ng·∫´u nhi√™n
        while (selectedQuestTypes.length < NUM_DAILY_QUESTS && availableQuestTypes.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableQuestTypes.length);
            selectedQuestTypes.push(availableQuestTypes.splice(randomIndex, 1)[0]);
        }
         // N·∫øu kh√¥ng ƒë·ªß 10 lo·∫°i kh√°c nhau, th√™m ng·∫´u nhi√™n t·ª´ pool ban ƒë·∫ßu (hi·∫øm khi x·∫£y ra)
         const originalTypes = Object.values(QUEST_TYPES);
         while (selectedQuestTypes.length < NUM_DAILY_QUESTS && originalTypes.length > 0) {
              selectedQuestTypes.push(originalTypes[Math.floor(Math.random() * originalTypes.length)]);
         }


        // T·∫°o ƒë·ªëi t∆∞·ª£ng nhi·ªám v·ª• chi ti·∫øt
        selectedQuestTypes.forEach((questType, index) => {
            const config = QUEST_CONFIG[questType];
            if (!config) { console.warn(`Missing config for quest type: ${questType}`); return; }

            const quantity = config.minQty + Math.floor(Math.random() * (config.maxQty - config.minQty + 1));
            let targetItemId = null;
            let description = '';
            let rewardMultiplier = 1; // H·ªá s·ªë nh√¢n th∆∞·ªüng d·ª±a tr√™n ƒë·ªô kh√≥/item

            switch (questType) {
                case QUEST_TYPES.PLANT_SPECIFIC:
                    targetItemId = getRandomSeedItemId();
                    if (!targetItemId) return; // B·ªè qua n·∫øu kh√¥ng c√≥ h·∫°t gi·ªëng
                    description = `Tr·ªìng ${quantity} c√¢y ${ITEM_DATA[targetItemId]?.name || 'kh√¥ng r√µ'}.`;
                    rewardMultiplier = (ITEM_DATA[targetItemId]?.price || 1) * 0.8; // Th∆∞·ªüng nhi·ªÅu h∆°n cho h·∫°t gi·ªëng ƒë·∫Øt
                    break;
                case QUEST_TYPES.PLANT_ANY:
                    description = `Tr·ªìng ${quantity} c√¢y b·∫•t k·ª≥.`;
                    break;
                case QUEST_TYPES.HARVEST_SPECIFIC:
                    targetItemId = getRandomSeedItemId();
                     if (!targetItemId) return; // B·ªè qua n·∫øu kh√¥ng c√≥ h·∫°t gi·ªëng
                    description = `Thu ho·∫°ch ${quantity} c√¢y ${ITEM_DATA[targetItemId]?.name || 'kh√¥ng r√µ'}.`;
                     rewardMultiplier = (ITEM_DATA[targetItemId]?.harvestYield || 1) * 0.5; // Th∆∞·ªüng d·ª±a tr√™n gi√° tr·ªã thu ho·∫°ch
                    break;
                case QUEST_TYPES.HARVEST_ANY:
                    description = `Thu ho·∫°ch ${quantity} c√¢y b·∫•t k·ª≥.`;
                    break;
                case QUEST_TYPES.SELL_DIRECT_SPECIFIC:
                    targetItemId = getRandomSeedItemId();
                     if (!targetItemId) return;
                    description = `B√°n tr·ª±c ti·∫øp ${quantity} c√¢y ${ITEM_DATA[targetItemId]?.name || 'kh√¥ng r√µ'}.`;
                     rewardMultiplier = (ITEM_DATA[targetItemId]?.harvestYield || 1) * 0.6;
                    break;
                case QUEST_TYPES.SELL_HARVESTED_SPECIFIC:
                    targetItemId = getRandomSeedItemId();
                     if (!targetItemId) return;
                    description = `B√°n t·ª´ kho ${quantity} ${ITEM_DATA[targetItemId]?.name || 'kh√¥ng r√µ'}.`;
                     rewardMultiplier = (ITEM_DATA[targetItemId]?.harvestYield || 1) * 0.4;
                    break;
                case QUEST_TYPES.USE_FERTILIZER_TYPE:
                    targetItemId = getRandomFertilizerItemId();
                     if (!targetItemId) return;
                    description = `S·ª≠ d·ª•ng ${quantity} ${ITEM_DATA[targetItemId]?.name || 'Ph√¢n b√≥n'}.`;
                     rewardMultiplier = (ITEM_DATA[targetItemId]?.price || 5) * 0.7; // Th∆∞·ªüng d·ª±a tr√™n gi√° ph√¢n b√≥n
                    break;
                case QUEST_TYPES.BUY_FERTILIZER:
                    description = `Mua ${quantity} ph√¢n b√≥n b·∫•t k·ª≥ t·ª´ c·ª≠a h√†ng.`;
                    break;
                case QUEST_TYPES.BUY_SEED:
                    description = `Mua ${quantity} h·∫°t gi·ªëng b·∫•t k·ª≥ t·ª´ c·ª≠a h√†ng.`;
                    break;
                case QUEST_TYPES.EARN_CURRENCY:
                    description = `Ki·∫øm ƒë∆∞·ª£c ${quantity}üí∞ t·ª´ vi·ªác b√°n c√¢y tr·ªìng.`;
                    rewardMultiplier = quantity * 0.1; // Th∆∞·ªüng t·ªâ l·ªá v·ªõi s·ªë ti·ªÅn c·∫ßn ki·∫øm
                    break;
                default:
                    description = 'Nhi·ªám v·ª• kh√¥ng x√°c ƒë·ªãnh.';
            }

            const reward = Math.max(1, Math.round(config.baseReward * rewardMultiplier)); // T√≠nh th∆∞·ªüng cu·ªëi c√πng

            newQuests.push({
                // id: `${todayDate}-${index}-${questType}`, // ID duy nh·∫•t cho instance quest
                type: questType, // Lo·∫°i quest
                description: description,
                targetItemId: targetItemId,
                targetQuantity: quantity,
                rewardCurrency: reward,
                currentProgress: 0,
                isCompleted: false,
                isClaimed: false
            });
        });

        gameState.dailyQuests = newQuests;
        gameState.lastQuestResetDate = todayDate;
        console.log(`Generated ${newQuests.length} new daily quests for ${todayDate}.`);
        saveGame(); // L∆∞u l·∫°i state v·ªõi nhi·ªám v·ª• m·ªõi
    }
    // --- K·∫øt th√∫c ƒê·ªãnh nghƒ©a Nhi·ªám v·ª• ---
		/**  M·ªü Popup Nhi·ªám V·ª• H·∫±ng Ng√†y */
function openDailyQuestPopup() {
    if (dailyQuestPopup) {
        console.log("M·ªü popup Nhi·ªám v·ª• H·∫±ng ng√†y.");
        closeMenuPopup(); // ƒê√≥ng menu ch√≠nh tr∆∞·ªõc
        renderDailyQuests(); // <<< RENDER DANH S√ÅCH NHI·ªÜM V·ª§ KHI M·ªû >>>
        openModal('daily-quest-popup'); // M·ªü modal nhi·ªám v·ª•
    } else {
        console.error("Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ DOM c·ªßa popup Nhi·ªám v·ª• H·∫±ng ng√†y!");
        showMessage("L·ªói: Kh√¥ng th·ªÉ m·ªü b·∫£ng nhi·ªám v·ª•.", "error");
    }
}
		 /** Ph√°t √¢m thanh s·∫•m s√©t n·∫øu hi·ªáu ·ª©ng ƒë∆∞·ª£c b·∫≠t. */
function playLightningSound() {
    // Ki·ªÉm tra xem hi·ªáu ·ª©ng √¢m thanh c√≥ ƒë∆∞·ª£c b·∫≠t kh√¥ng
    if (!areEffectSoundsEnabled) {
        // console.log("√Çm thanh hi·ªáu ·ª©ng ƒëang t·∫Øt, b·ªè qua ti·∫øng s√©t."); // B·ªè comment n·∫øu mu·ªën debug
        return; // Kh√¥ng l√†m g√¨ n·∫øu hi·ªáu ·ª©ng t·∫Øt
    }

    // Ki·ªÉm tra xem ph·∫ßn t·ª≠ audio c√≥ t·ªìn t·∫°i kh√¥ng
    if (lightningSound) {
        lightningSound.currentTime = 0; // Tua v·ªÅ ƒë·∫ßu ƒë·ªÉ ph√°t l·∫°i n·∫øu ƒëang ch·∫°y
        lightningSound.play().catch(error => {
            // B·∫Øt l·ªói n·∫øu tr√¨nh duy·ªát ch·∫∑n ph√°t √¢m thanh (v√≠ d·ª•: ch∆∞a c√≥ t∆∞∆°ng t√°c ng∆∞·ªùi d√πng)
            console.warn("Kh√¥ng th·ªÉ ph√°t √¢m thanh s·∫•m s√©t:", error);
        });
    } else {
        // Log c·∫£nh b√°o n·∫øu kh√¥ng t√¨m th·∫•y th·∫ª audio
        console.warn("Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ √¢m thanh s·∫•m s√©t (lightning-sound).");
    }
}
		function getTotalInventoryCount() {
    let totalCount = 0;
    // T√≠nh kho ƒë√£ mua (gameState.inventory) - Logic kh√¥ng ƒë·ªïi
    for (const itemId in gameState.inventory) {
        if (gameState.inventory.hasOwnProperty(itemId)) {
            totalCount += gameState.inventory[itemId] || 0;
        }
    }
    // --- [THAY ƒê·ªîI] T√≠nh kho ƒë√£ thu ho·∫°ch (gameState.harvestedItems) ---
    for (const itemId in gameState.harvestedItems) {
        if (gameState.harvestedItems.hasOwnProperty(itemId)) {
            const qualityData = gameState.harvestedItems[itemId];
            if (qualityData && typeof qualityData === 'object') { // Ch·ªâ x·ª≠ l√Ω n·∫øu l√† object ch·∫•t l∆∞·ª£ng
                // C·ªông t·ªïng s·ªë l∆∞·ª£ng t·ª´ t·∫•t c·∫£ c√°c b·∫≠c ch·∫•t l∆∞·ª£ng
                totalCount += (qualityData[QUALITY_TIERS.PERFECT] || 0) +
                              (qualityData[QUALITY_TIERS.GOOD] || 0) +
                              (qualityData[QUALITY_TIERS.FAIR] || 0) +
                              (qualityData[QUALITY_TIERS.POOR] || 0);
            }
            // B·ªè qua n·∫øu kh√¥ng ph·∫£i object (ƒë·ªãnh d·∫°ng c≈© - kh√¥ng n√™n c√≤n s√≥t sau loadGame)
        }
    }
    return totalCount;
}
		
		/** [M·ªöI] B·∫≠t/t·∫Øt nh·∫°c n·ªÅn v√† c·∫≠p nh·∫≠t n√∫t */
function toggleBackgroundMusic() {
    // 1. Ki·ªÉm tra c√°c ph·∫ßn t·ª≠ c·∫ßn thi·∫øt
    if (!backgroundMusic || !toggleSoundBtn) {
        console.error("L·ªói: Kh√¥ng t√¨m th·∫•y audio nh·∫°c n·ªÅn ho·∫∑c n√∫t √¢m thanh.");
        return;
    }
    // Ki·ªÉm tra c√°c audio hi·ªáu ·ª©ng ƒë·ªÉ ƒë·∫£m b·∫£o t·∫Øt/b·∫≠t ƒë·ªìng b·ªô n·∫øu c·∫ßn
    if (!rainSound) console.warn("Kh√¥ng t√¨m th·∫•y audio m∆∞a (rainSound).");
    if (!rainySunnySound) console.warn("Kh√¥ng t√¨m th·∫•y audio m∆∞a n·∫Øng (rainy-sunny-sound).");

    try {
        // 2. ƒê·∫£o ng∆∞·ª£c tr·∫°ng th√°i mong mu·ªën
        isMusicEnabled = !isMusicEnabled;
        console.log(`Ng∆∞·ªùi d√πng chuy·ªÉn tr·∫°ng th√°i nh·∫°c n·ªÅn th√†nh: ${isMusicEnabled}`);

        // 3. L∆∞u tr·∫°ng th√°i M·ªöI v√†o localStorage (d∆∞·ªõi d·∫°ng chu·ªói 'true'/'false')
        localStorage.setItem(MUSIC_ENABLED_KEY, isMusicEnabled.toString());
        console.log(`ƒê√£ l∆∞u tr·∫°ng th√°i nh·∫°c n·ªÅn (${isMusicEnabled}) v√†o localStorage v·ªõi key ${MUSIC_ENABLED_KEY}.`);

        // 4. Th·ª±c hi·ªán h√†nh ƒë·ªông b·∫≠t/t·∫Øt audio
        if (isMusicEnabled) {
            // --- Ng∆∞·ªùi d√πng mu·ªën B·∫¨T nh·∫°c ---
            const playPromise = backgroundMusic.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // Th√†nh c√¥ng b·∫≠t nh·∫°c n·ªÅn
                    console.log("Nh·∫°c n·ªÅn ƒë√£ ƒë∆∞·ª£c B·∫¨T th√†nh c√¥ng.");
                    musicStarted = true; // ƒê√°nh d·∫•u nh·∫°c ƒë√£ ch·∫°y √≠t nh·∫•t 1 l·∫ßn
                    updateSoundButtonText(); // C·∫≠p nh·∫≠t n√∫t th√†nh "T·∫Øt"
                    // gameTick s·∫Ω t·ª± x·ª≠ l√Ω b·∫≠t √¢m thanh th·ªùi ti·∫øt n·∫øu c·∫ßn v√† n·∫øu hi·ªáu ·ª©ng ƒëang b·∫≠t
                }).catch(error => {
                    // L·ªói khi c·ªë g·∫Øng b·∫≠t nh·∫°c (th∆∞·ªùng do ch∆∞a c√≥ t∆∞∆°ng t√°c)
                    console.error("L·ªói khi b·∫≠t nh·∫°c n·ªÅn qua n√∫t toggle (c·∫ßn t∆∞∆°ng t√°c?):", error);
                    showMessage("Kh√¥ng th·ªÉ b·∫≠t nh·∫°c. H√£y th·ª≠ click v√†o game.", "warning");
                    // N·∫øu l·ªói, quay l·∫°i tr·∫°ng th√°i t·∫Øt v√† l∆∞u l·∫°i
                    isMusicEnabled = false;
                    localStorage.setItem(MUSIC_ENABLED_KEY, 'false');
                    musicStarted = false; // Reset c·ªù n·∫øu ch∆∞a ch·∫°y ƒë∆∞·ª£c
                    updateSoundButtonText(); // C·∫≠p nh·∫≠t n√∫t th√†nh "B·∫≠t"
                    // ƒê·∫£m b·∫£o t·∫Øt c·∫£ √¢m thanh th·ªùi ti·∫øt n·∫øu c√≥ l·ªói b·∫≠t nh·∫°c n·ªÅn
                    if (rainSound && !rainSound.paused) { rainSound.pause(); rainSound.currentTime = 0; }
                    if (rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); rainySunnySound.currentTime = 0; }
                });
            } else {
                // Tr√¨nh duy·ªát c≈© kh√¥ng tr·∫£ v·ªÅ Promise (hi·∫øm g·∫∑p)
                console.log("Nh·∫°c n·ªÅn ƒë√£ ƒë∆∞·ª£c B·∫¨T (tr√¨nh duy·ªát c≈©).");
                musicStarted = true;
                updateSoundButtonText();
            }
        } else {
            // --- Ng∆∞·ªùi d√πng mu·ªën T·∫ÆT nh·∫°c ---
            backgroundMusic.pause();
            console.log("Nh·∫°c n·ªÅn ƒë√£ ƒë∆∞·ª£c T·∫ÆT.");
            updateSoundButtonText(); // C·∫≠p nh·∫≠t n√∫t th√†nh "B·∫≠t"

            // T·∫Øt c·∫£ √¢m thanh th·ªùi ti·∫øt ƒëang ch·∫°y (n·∫øu c√≥) v√¨ nh·∫°c n·ªÅn ƒë√£ t·∫Øt
            if (rainSound && !rainSound.paused) {
                rainSound.pause(); rainSound.currentTime = 0;
                console.log("√Çm thanh m∆∞a c≈©ng ƒë√£ ƒë∆∞·ª£c T·∫ÆT.");
            }
            if (rainySunnySound && !rainySunnySound.paused) {
                rainySunnySound.pause(); rainySunnySound.currentTime = 0;
                console.log("√Çm thanh m∆∞a n·∫Øng c≈©ng ƒë√£ ƒë∆∞·ª£c T·∫ÆT.");
            }
        }
    } catch (error) {
        console.error("L·ªói kh√¥ng mong mu·ªën khi x·ª≠ l√Ω b·∫≠t/t·∫Øt nh·∫°c:", error);
        showMessage("ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω √¢m thanh.", "error");
        updateSoundButtonText(); // C·∫≠p nh·∫≠t l·∫°i n√∫t theo tr·∫°ng th√°i th·ª±c t·∫ø c·ªßa isMusicEnabled
    }
}
/**  C·∫≠p nh·∫≠t vƒÉn b·∫£n n√∫t √¢m thanh d·ª±a tr√™n tr·∫°ng th√°i th·ª±c t·∫ø */
function updateSoundButtonText() {
    if (!toggleSoundBtn || !backgroundMusic) return;
    // D·ª±a v√†o bi·∫øn tr·∫°ng th√°i isMusicEnabled
    if (isMusicEnabled) {
        // N·∫øu tr·∫°ng th√°i l√† B·∫≠t (mong mu·ªën nghe nh·∫°c)
        toggleSoundBtn.textContent = "üîá T·∫Øt √Çm Thanh";
        toggleSoundBtn.title = "T·∫Øt nh·∫°c n·ªÅn v√† √¢m thanh th·ªùi ti·∫øt";
        // C√≥ th·ªÉ th√™m ki·ªÉm tra backgroundMusic.paused ƒë·ªÉ ƒë·ªïi title n·∫øu ch∆∞a play ƒë∆∞·ª£c do policy
        // if (backgroundMusic.paused) toggleSoundBtn.title += " (Ch∆∞a ph√°t)";
    } else {
        // N·∫øu tr·∫°ng th√°i l√† T·∫Øt (kh√¥ng mu·ªën nghe nh·∫°c)
        toggleSoundBtn.textContent = "üîä B·∫≠t √Çm Thanh";
        toggleSoundBtn.title = "B·∫≠t nh·∫°c n·ªÅn v√† √¢m thanh th·ªùi ti·∫øt";
    }
    console.log(`Updated sound button text based on isMusicEnabled=${isMusicEnabled}`);
}

		
		
		
		    /** M·ªü popup x√°c nh·∫≠n mua √¥ ƒë·∫•t b·ªã kh√≥a */
    function openLockedPlotPopup() {
        if (lockedPlotPopup) {
            lockedPlotPopup.style.display = 'flex'; // D√πng flex ƒë·ªÉ cƒÉn gi·ªØa theo CSS
            // T·ª± ƒë·ªông focus n√∫t h·ªßy ho·∫∑c n√∫t mua (n·∫øu enable)
            const focusTarget = confirmBuyPlotBtn.disabled ? cancelBuyPlotBtn : confirmBuyPlotBtn;
            setTimeout(() => focusTarget?.focus(), 50); // Delay nh·ªè
        }
    }

    /** ƒê√≥ng popup x√°c nh·∫≠n mua √¥ ƒë·∫•t b·ªã kh√≥a */
    function closeLockedPlotPopup() {
        if (lockedPlotPopup) {
            lockedPlotPopup.style.display = 'none';
             // X√≥a data c≈© ph√≤ng tr∆∞·ªùng h·ª£p l·ªói
             if (confirmBuyPlotBtn) {
                 delete confirmBuyPlotBtn.dataset.plotId;
                 delete confirmBuyPlotBtn.dataset.cost;
             }
        }
    }

    /** X·ª≠ l√Ω khi nh·∫•n n√∫t Mua trong popup √¥ ƒë·∫•t b·ªã kh√≥a */
    function handleConfirmBuyPlot() {
            // L·∫•y th√¥ng tin t·ª´ dataset c·ªßa n√∫t x√°c nh·∫≠n
            const plotIdString = confirmBuyPlotBtn.dataset.plotId;
            const costString = confirmBuyPlotBtn.dataset.cost;

            // Ki·ªÉm tra xem dataset c√≥ t·ªìn t·∫°i v√† h·ª£p l·ªá kh√¥ng
            if (plotIdString === undefined || costString === undefined) {
                 console.error("L·ªói: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu plotId ho·∫∑c cost tr√™n n√∫t x√°c nh·∫≠n.");
                 showMessage("L·ªói! Kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu mua √¥ ƒë·∫•t.", "error");
                 closeLockedPlotPopup();
                 return;
            }

            const plotId = parseInt(plotIdString);
            const cost = parseInt(costString);

            // Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa plotId v√† cost
            if (isNaN(plotId) || isNaN(cost) || plotId < 0 || cost <= 0) {
                 console.error(`L·ªói d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá: plotId=${plotId}, cost=${cost}`);
                 showMessage("L·ªói! D·ªØ li·ªáu mua √¥ ƒë·∫•t kh√¥ng h·ª£p l·ªá.", "error");
                 closeLockedPlotPopup();
                 return;
            }

            // Ki·ªÉm tra xem c√≥ ƒë√∫ng l√† mua √¥ ti·∫øp theo kh√¥ng
            if (plotId !== gameState.maxUnlockedPlots) {
                console.error(`L·ªói logic: ƒêang c·ªë mua √¥ ${plotId} nh∆∞ng √¥ ti·∫øp theo ph·∫£i l√† ${gameState.maxUnlockedPlots}`);
                showMessage(`L·ªói! Ch·ªâ c√≥ th·ªÉ m·ªü kh√≥a √¥ s·ªë ${gameState.maxUnlockedPlots + 1} ti·∫øp theo.`, "error");
                closeLockedPlotPopup();
                return;
            }

            // Ki·ªÉm tra ti·ªÅn
            if (gameState.currency >= cost) {
                // --- Th·ª±c hi·ªán mua ---
                gameState.currency -= cost;
                gameState.maxUnlockedPlots++;
                initializePlotsData(); // Quan tr·ªçng: Kh·ªüi t·∫°o d·ªØ li·ªáu cho √¥ m·ªõi m·ªü kh√≥a
                renderUI();           // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ti·ªÅn v√† s·ªë √¥
                renderGarden();       // V·∫Ω l·∫°i v∆∞·ªùn v·ªõi √¥ m·ªõi
                updateShopButtons(); // C·∫≠p nh·∫≠t n√∫t shop v√¨ ti·ªÅn thay ƒë·ªïi
                showMessage(`Ch√∫c m·ª´ng! ƒê√£ m·ªü kh√≥a √¥ ƒë·∫•t s·ªë ${plotId + 1}!`, "success");
                saveGame(); // L∆∞u game sau khi mua th√†nh c√¥ng

                // <<< TH√äM LOG ACTION >>>
                logAction('buy_plot', plotId, `M·ªü kh√≥a √¥ ${plotId + 1} (-${cost}üí∞).`, 'üèûÔ∏è', null);
			   // <<< K·∫æT TH√öC LOG ACTION >>>

            } else {
                // Th√¥ng b√°o kh√¥ng ƒë·ªß ti·ªÅn (ki·ªÉm tra l·∫°i l·∫ßn n·ªØa)
                showMessage(`Kh√¥ng ƒë·ªß ti·ªÅn! C·∫ßn ${cost}üí∞, b·∫°n ch·ªâ c√≥ ${gameState.currency}üí∞.`, "error");
            }
            closeLockedPlotPopup(); // Lu√¥n ƒë√≥ng popup sau khi x·ª≠ l√Ω
        }
	function handleEscapeKey(event) {
    if (event.key === 'Escape') {
        let modalOrPopupClosed = false;
        const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
        const savegamePopupElement = document.getElementById('menu-savegame-popup');

        // ∆Øu ti√™n 1: ƒê√≥ng popup x√°c nh·∫≠n kh√¥i ph·ª•c n·∫øu ƒëang m·ªü
        if (confirmRestorePopup && confirmRestorePopup.style.display !== 'none') {
            handleCancelRestore(); // H·ªßy b·ªè v√† ƒë√≥ng popup x√°c nh·∫≠n, x√≥a underlay
            modalOrPopupClosed = true;
        }
        // ∆Øu ti√™n 2: ƒê√≥ng popup L∆∞u/Nh·∫≠p n·∫øu ƒëang m·ªü (v√† kh√¥ng b·ªã che)
        else if (savegamePopupElement && savegamePopupElement.style.display !== 'none' && !savegamePopupElement.classList.contains('popup-underlay')) {
             closeSavegamePopup();
             modalOrPopupClosed = true;
        }
        // Ti·∫øp t·ª•c v·ªõi c√°c popup x√°c nh·∫≠n kh√°c (ƒë√£ ƒë∆∞·ª£c ∆∞u ti√™n x·ª≠ l√Ω trong h√†m ƒë√≥ng t∆∞∆°ng ·ª©ng)
        else if (confirmRepairRodPopup && confirmRepairRodPopup.style.display !== 'none') { closeConfirmRepairPopup(); modalOrPopupClosed = true; }
        else if (confirmRemoveRodPopup && confirmRemoveRodPopup.style.display !== 'none') { closeConfirmRemovePopup(); modalOrPopupClosed = true; }
        else if (discardItemPopup && discardItemPopup.style.display !== 'none') { closeDiscardItemPopup(); modalOrPopupClosed = true; }
        else if (hatNgocTroiRewardPopup && hatNgocTroiRewardPopup.style.display !== 'none') { closeRewardPopup(); modalOrPopupClosed = true; }
        else if (hatNgocTroiPopup && hatNgocTroiPopup.style.display !== 'none') { closeHatNgocTroiPopup(); modalOrPopupClosed = true; }
        else if (confirmSellAllModal && confirmSellAllModal.style.display !== 'none') { closeConfirmSellAllModal(); modalOrPopupClosed = true; }
        // Popup menu v√† kh√≥a √¥ ƒë·∫•t
        else if (menuPopup && menuPopup.style.display !== 'none') { closeMenuPopup(); modalOrPopupClosed = true; }
        else if (lockedPlotPopup && lockedPlotPopup.style.display !== 'none') { closeLockedPlotPopup(); modalOrPopupClosed = true; }
        // Modal h√†nh ƒë·ªông c·ªôt thu l√¥i
        else if (lightningRodActionModal && lightningRodActionModal.style.display !== 'none') { closeModal('lightning-rod-action-modal'); currentActionPlotId = null; modalOrPopupClosed = true; }
        // C√°c modal chung kh√°c
        else {
            const openModals = document.querySelectorAll('.modal[style*="display: block"]:not(.popup-underlay), .modal[style*="display: flex"]:not(.popup-underlay)'); // Ch·ªâ t√¨m modal kh√¥ng b·ªã che
            if (openModals.length > 0) {
                 const lastModal = openModals[openModals.length - 1];
                 const modalId = lastModal.id;
                 // Danh s√°ch c√°c ID ƒë√£ x·ª≠ l√Ω ·ªü tr√™n
                 const specificPopupIds = [
                     'popup-confirm-restoregame', 'savegamePopup', 'confirmRepairRodPopup', 'confirmRemoveRodPopup',
                     'discard-item-popup', 'hat-ngoc-troi-reward-popup', 'hat-ngoc-troi-popup',
                     'confirm-sell-all-modal', 'menu-popup', 'locked-plot-popup',
                     'lightning-rod-action-modal'
                 ];
                 if (modalId && !specificPopupIds.includes(modalId)) {
                      closeModal(modalId);
                      if (modalId === 'seed-selection-modal') currentPlantingPlotId = null;
                      if (['fertilizer-selection-modal', 'plant-action-modal', 'empty-plot-action-modal'].includes(modalId)) currentActionPlotId = null;
                      modalOrPopupClosed = true;
                 } else if (!modalId) {
                      console.warn("Escape key: Found an open modal without an ID.");
                 }
            }
        }

        // Ki·ªÉm tra v√† ·∫©n l·ªõp ph·ªß (logic n√†y v·∫´n ƒë√∫ng)
        if (modalOrPopupClosed) {
             setTimeout(() => {
                 const anyModalOpen = document.querySelector('.modal[style*="display: block"], .modal[style*="display: flex"]');
                 if (!anyModalOpen && darkOverlayElement && darkOverlayElement.classList.contains('visible')) {
                     hideDarkOverlay();
                 }
             }, 50);
        }
    }
}

    // --- C·∫≠p nh·∫≠t Listener click n·ªÅn ---
     /** X·ª≠ l√Ω click b√™n ngo√†i n·ªôi dung modal/popup ƒë·ªÉ ƒë√≥ng */
    function handleModalBackgroundClick(event) {
    let modalOrPopupClosed = false;
    const target = event.target;
    const confirmRestorePopup = document.getElementById('popup-confirm-restoregame');
    const savegamePopupElement = document.getElementById('menu-savegame-popup');

    // ∆Øu ti√™n 1: Click v√†o n·ªÅn c·ªßa popup x√°c nh·∫≠n kh√¥i ph·ª•c
    if (target === confirmRestorePopup) {
        handleCancelRestore(); // ƒê√≥ng popup x√°c nh·∫≠n, x√≥a underlay
        modalOrPopupClosed = true;
    }
    // ∆Øu ti√™n 2: Click v√†o n·ªÅn c·ªßa popup l∆∞u/nh·∫≠p *ch·ªâ khi* n√≥ kh√¥ng b·ªã che
    else if (target === savegamePopupElement && !savegamePopupElement.classList.contains('popup-underlay')) {
        closeSavegamePopup();
        modalOrPopupClosed = true;
    }
    // Ti·∫øp t·ª•c v·ªõi c√°c popup/modal c·ª• th·ªÉ kh√°c
    else {
        const specificPopups = {
            'confirmRepairRodPopup': closeConfirmRepairPopup,
            'confirmRemoveRodPopup': closeConfirmRemovePopup,
            'discard-item-popup': closeDiscardItemPopup,
            'hat-ngoc-troi-reward-popup': closeRewardPopup,
            'hat-ngoc-troi-popup': closeHatNgocTroiPopup,
            'confirm-sell-all-modal': closeConfirmSellAllModal,
            'menu-popup': closeMenuPopup,
            'locked-plot-popup': closeLockedPlotPopup,
            'lightning-rod-action-modal': () => { closeModal('lightning-rod-action-modal'); currentActionPlotId = null; }
        };
        let handledSpecific = false;
        for (const popupId in specificPopups) {
            const popupElement = document.getElementById(popupId);
            // Ch·ªâ ƒë√≥ng n·∫øu click v√†o n·ªÅn c·ªßa n√≥ V√Ä n√≥ kh√¥ng b·ªã che (tr·ª´ tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát n·∫øu c·∫ßn)
            if (target === popupElement && !popupElement.classList.contains('popup-underlay')) {
                specificPopups[popupId]();
                modalOrPopupClosed = true;
                handledSpecific = true;
                break;
            }
        }

        // N·∫øu kh√¥ng ph·∫£i popup c·ª• th·ªÉ, ki·ªÉm tra modal chung
        if (!handledSpecific && target.classList.contains('modal') && !target.classList.contains('popup-underlay')) {
             const modalId = target.id;
             const specificIdsList = Object.keys(specificPopups).concat(['popup-confirm-restoregame', 'savegamePopup']); // Danh s√°ch ƒë·∫ßy ƒë·ªß
             if (!specificIdsList.includes(modalId)) {
                 closeModal(modalId);
                 if (modalId === 'seed-selection-modal') currentPlantingPlotId = null;
                 if (['fertilizer-selection-modal', 'plant-action-modal', 'empty-plot-action-modal'].includes(modalId)) currentActionPlotId = null;
                 modalOrPopupClosed = true;
             }
        }
    }

    // Ki·ªÉm tra v√† ·∫©n l·ªõp ph·ªß (logic n√†y v·∫´n ƒë√∫ng)
    if (modalOrPopupClosed) {
         setTimeout(() => {
             const anyModalOpen = document.querySelector('.modal[style*="display: block"], .modal[style*="display: flex"]');
             if (!anyModalOpen && darkOverlayElement && darkOverlayElement.classList.contains('visible')) {
                 hideDarkOverlay();
             }
         }, 50);
    }
}
	/** X·ª≠ l√Ω click n√∫t L·ªãch s·ª≠ tr·ªìng c√¢y */
function handlePlantingHistoryClick() {
    console.log("Chuy·ªÉn ƒë·∫øn trang L·ªãch s·ª≠ tr·ªìng c√¢y...");
    // L∆∞u game l·∫ßn cu·ªëi tr∆∞·ªõc khi chuy·ªÉn trang ƒë·ªÉ ƒë·∫£m b·∫£o l·ªãch s·ª≠ m·ªõi nh·∫•t ƒë∆∞·ª£c l∆∞u
    saveGame();
    // Chuy·ªÉn h∆∞·ªõng ng∆∞·ªùi d√πng ƒë·∫øn trang history-menu.html
    window.location.href = 'history-menu.html';
    // Kh√¥ng c·∫ßn ƒë√≥ng menu ·ªü ƒë√¢y v√¨ trang s·∫Ω chuy·ªÉn ƒëi
}
		
		
		
		
        // ==================================

        /** L∆∞u tr·∫°ng th√°i game hi·ªán t·∫°i v√†o localStorage. */
         function saveGame() {
    try {
        const now = Date.now();
        // T√≠nh v√† c·ªông d·ªìn th·ªùi gian ch∆°i
        if (gameState.lastUpdateTimestamp && now > gameState.lastUpdateTimestamp) {
            if (tickCounter > 0 || gameState.totalPlayTime === 0) {
                gameState.totalPlayTime += (now - gameState.lastUpdateTimestamp);
            }
        }
        // C·∫≠p nh·∫≠t timestamp cu·ªëi c√πng *tr∆∞·ªõc* khi l∆∞u
        gameState.lastUpdateTimestamp = now;

        // === T·∫°o m·ªôt b·∫£n sao s√¢u c·ªßa gameState ƒë·ªÉ validate v√† ch·ªânh s·ª≠a tr∆∞·ªõc khi l∆∞u ===
        // S·ª≠ d·ª•ng JSON.parse(JSON.stringify(...)) ƒë·ªÉ t·∫°o b·∫£n sao s√¢u an to√†n
        let stateToSave;
        try {
            stateToSave = JSON.parse(JSON.stringify(gameState));
        } catch (stringifyError) {
            console.error("L·ªói nghi√™m tr·ªçng khi t·∫°o b·∫£n sao gameState ƒë·ªÉ l∆∞u:", stringifyError);
            showMessage("L·ªói nghi√™m tr·ªçng khi chu·∫©n b·ªã l∆∞u game!", "error", MESSAGE_DISPLAY_TIME * 2);
            return; // Kh√¥ng th·ªÉ ti·∫øp t·ª•c n·∫øu kh√¥ng t·∫°o ƒë∆∞·ª£c b·∫£n sao
        }


        // === Validate v√† l√†m s·∫°ch d·ªØ li·ªáu tr∆∞·ªõc khi l∆∞u ===

        // 1. Validate c√°c thu·ªôc t√≠nh c∆° b·∫£n
        stateToSave.currency = (typeof stateToSave.currency === 'number' && stateToSave.currency >= 0) ? Math.floor(stateToSave.currency) : 0; // L√†m tr√≤n xu·ªëng v√† ƒë·∫£m b·∫£o kh√¥ng √¢m
        stateToSave.maxUnlockedPlots = (typeof stateToSave.maxUnlockedPlots === 'number' && stateToSave.maxUnlockedPlots >= INITIAL_PLOT_COUNT) ? stateToSave.maxUnlockedPlots : INITIAL_PLOT_COUNT;
        stateToSave.totalPlayTime = (typeof stateToSave.totalPlayTime === 'number' && stateToSave.totalPlayTime >= 0) ? stateToSave.totalPlayTime : 0;
        stateToSave.gameStartTime = (typeof stateToSave.gameStartTime === 'number' && stateToSave.gameStartTime > 0) ? stateToSave.gameStartTime : now; // D√πng now n·∫øu kh√¥ng h·ª£p l·ªá
        stateToSave.lastUpdateTimestamp = (typeof stateToSave.lastUpdateTimestamp === 'number' && stateToSave.lastUpdateTimestamp > 0) ? stateToSave.lastUpdateTimestamp : now;

        // 2. Validate Inventory (ƒê√£ Mua)
        if (typeof stateToSave.inventory !== 'object' || stateToSave.inventory === null) stateToSave.inventory = {};
        const validatedInventory = {};
        for (const itemId in stateToSave.inventory) {
            if (ITEM_DATA[itemId]) { // Ch·ªâ l∆∞u nh·ªØng item c√≤n t·ªìn t·∫°i trong d·ªØ li·ªáu game
                const quantity = parseInt(stateToSave.inventory[itemId]);
                if (!isNaN(quantity) && quantity > 0) {
                    validatedInventory[itemId] = quantity;
                }
            } else {
                console.warn(`saveGame: Lo·∫°i b·ªè item ID kh√¥ng t·ªìn t·∫°i '${itemId}' kh·ªèi inventory.`);
            }
        }
        stateToSave.inventory = validatedInventory;
        // ƒê·∫£m b·∫£o key 'pesticide' t·ªìn t·∫°i n·∫øu c·∫ßn thi·∫øt b·ªüi logic game kh√°c
        if (stateToSave.inventory.pesticide === undefined && ITEM_DATA['pesticide']) {
             stateToSave.inventory.pesticide = 0;
        }

        // 3. Validate Harvested Items (ƒê√£ Thu Ho·∫°ch - ƒê·ªãnh d·∫°ng Ch·∫•t l∆∞·ª£ng) v√† D·ªåN D·∫∏P
        if (typeof stateToSave.harvestedItems !== 'object' || stateToSave.harvestedItems === null) {
            stateToSave.harvestedItems = {};
        }
        const validatedHarvestedClean = {}; // T·∫°o object m·ªõi ƒë·ªÉ ch·ª©a d·ªØ li·ªáu s·∫°ch
        for (const itemId in stateToSave.harvestedItems) {
            // Ch·ªâ l∆∞u l·∫°i n·∫øu l√† h·∫°t gi·ªëng h·ª£p l·ªá v√† c√≤n t·ªìn t·∫°i trong ITEM_DATA
            if (ITEM_DATA[itemId] && ITEM_DATA[itemId].type === 'seed') {
                const qualityData = stateToSave.harvestedItems[itemId];
                // Ch·ªâ l∆∞u l·∫°i n·∫øu l√† object ch·∫•t l∆∞·ª£ng h·ª£p l·ªá
                if (qualityData && typeof qualityData === 'object') {
                    const cleanQualityData = {
                        [QUALITY_TIERS.PERFECT]: Math.max(0, parseInt(qualityData[QUALITY_TIERS.PERFECT] || 0)),
                        [QUALITY_TIERS.GOOD]:    Math.max(0, parseInt(qualityData[QUALITY_TIERS.GOOD] || 0)),
                        [QUALITY_TIERS.FAIR]:    Math.max(0, parseInt(qualityData[QUALITY_TIERS.FAIR] || 0)),
                        [QUALITY_TIERS.POOR]:    Math.max(0, parseInt(qualityData[QUALITY_TIERS.POOR] || 0))
                    };
                    // Ch·ªâ th√™m v√†o object s·∫°ch n·∫øu t·ªïng s·ªë l∆∞·ª£ng > 0
                    const totalQty = Object.values(cleanQualityData).reduce((sum, count) => sum + count, 0);
                    if (totalQty > 0) {
                        validatedHarvestedClean[itemId] = cleanQualityData;
                    } else {
                         console.log(`saveGame: Lo·∫°i b·ªè harvested item ${itemId} v√¨ t·ªïng s·ªë l∆∞·ª£ng l√† 0.`);
                    }
                } else {
                     console.warn(`saveGame: D·ªØ li·ªáu harvested item ${itemId} kh√¥ng ph·∫£i object ch·∫•t l∆∞·ª£ng h·ª£p l·ªá, lo·∫°i b·ªè.`);
                }
            } else {
                 console.warn(`saveGame: Lo·∫°i b·ªè harvested item ID kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng ph·∫£i h·∫°t gi·ªëng '${itemId}'.`);
            }
        }
        stateToSave.harvestedItems = validatedHarvestedClean; // G√°n l·∫°i object ƒë√£ ƒë∆∞·ª£c l·ªçc s·∫°ch

        // 4. Validate Plots (ch·ªâ l∆∞u c√°c √¥ ƒë√£ m·ªü kh√≥a)
        if (!Array.isArray(stateToSave.plots)) stateToSave.plots = [];
        // C·∫Øt b·ªè c√°c √¥ ch∆∞a m·ªü kh√≥a ho·∫∑c d∆∞ th·ª´a so v·ªõi maxUnlockedPlots
        stateToSave.plots = stateToSave.plots.slice(0, stateToSave.maxUnlockedPlots);
        // T·∫°o tr·∫°ng th√°i m·∫∑c ƒë·ªãnh cho plot ƒë·ªÉ s·ª≠ d·ª•ng khi validate
         const defaultPlotStateForSave = {
             seedId: null, plantTime: null, hasPest: false, health: INITIAL_PLANT_HEALTH, fertility: BASE_FERTILITY, causeOfDeath: null, pestDeathClickCount: 0, barrenHarvestPenaltyFactor: 1.0, isDry: false
         };
        stateToSave.plots = stateToSave.plots.map((plot, index) => {
            // N·∫øu plot kh√¥ng t·ªìn t·∫°i, kh√¥ng ph·∫£i object, ho·∫∑c ID kh√¥ng ƒë√∫ng -> T·∫°o plot m·∫∑c ƒë·ªãnh
            if (!plot || typeof plot !== 'object' || typeof plot.id !== 'number' || plot.id !== index) {
                console.warn(`saveGame: D·ªØ li·ªáu plot kh√¥ng h·ª£p l·ªá t·∫°i index ${index}, t·∫°o plot m·∫∑c ƒë·ªãnh.`);
                // Quan tr·ªçng: T·∫°o b·∫£n sao s√¢u c·ªßa tr·∫°ng th√°i m·∫∑c ƒë·ªãnh
                return { id: index, ...JSON.parse(JSON.stringify(defaultPlotStateForSave)) };
            }
            // T·∫°o plot s·∫°ch d·ª±a tr√™n d·ªØ li·ªáu g·ªëc
            const cleanPlot = { id: index }; // B·∫Øt ƒë·∫ßu v·ªõi ID ƒë√∫ng
            cleanPlot.seedId = (plot.seedId && ITEM_DATA[plot.seedId]) ? plot.seedId : null;
            cleanPlot.plantTime = (typeof plot.plantTime === 'number' && plot.plantTime > 0 && cleanPlot.seedId) ? plot.plantTime : null; // Ch·ªâ gi·ªØ plantTime n·∫øu seedId h·ª£p l·ªá
            cleanPlot.hasPest = typeof plot.hasPest === 'boolean' ? plot.hasPest : false;
            // ƒê·∫£m b·∫£o health v√† fertility trong kho·∫£ng h·ª£p l·ªá
            cleanPlot.health = (typeof plot.health === 'number') ? Math.max(0, Math.min(INITIAL_PLANT_HEALTH, plot.health)) : INITIAL_PLANT_HEALTH;
            cleanPlot.fertility = (typeof plot.fertility === 'number') ? Math.max(0, Math.min(BASE_FERTILITY, plot.fertility)) : BASE_FERTILITY;
            cleanPlot.causeOfDeath = (typeof plot.causeOfDeath === 'string' || plot.causeOfDeath === null) ? plot.causeOfDeath : null; // Cho ph√©p null ho·∫∑c string
            cleanPlot.pestDeathClickCount = (typeof plot.pestDeathClickCount === 'number' && plot.pestDeathClickCount >= 0) ? plot.pestDeathClickCount : 0;
            cleanPlot.barrenHarvestPenaltyFactor = (typeof plot.barrenHarvestPenaltyFactor === 'number' && plot.barrenHarvestPenaltyFactor >= 1.0) ? plot.barrenHarvestPenaltyFactor : 1.0;
            cleanPlot.isDry = typeof plot.isDry === 'boolean' ? plot.isDry : false;
			 cleanPlot.fertilizerProtectUsageCount = (typeof plot.fertilizerProtectUsageCount === 'number' && plot.fertilizerProtectUsageCount >= 0) ? plot.fertilizerProtectUsageCount : 0;
            cleanPlot.hasFertilizerProtectBuff = (typeof plot.hasFertilizerProtectBuff === 'boolean' && cleanPlot.seedId && cleanPlot.health > 0) ? plot.hasFertilizerProtectBuff : false; // Buff ch·ªâ active khi c√≥ c√¢y s·ªëng
            // ƒê·∫£m b·∫£o count v√† buff ƒë·ªìng b·ªô (n·∫øu buff on th√¨ count > 0)
            if (cleanPlot.hasFertilizerProtectBuff && cleanPlot.fertilizerProtectUsageCount <= 0) {
                cleanPlot.hasFertilizerProtectBuff = false; // T·∫Øt buff n·∫øu count = 0
            }
			
			
			cleanPlot.fertilizerGrowthUsageCount = (typeof plot.fertilizerGrowthUsageCount === 'number' && plot.fertilizerGrowthUsageCount >= 0) ? plot.fertilizerGrowthUsageCount : 0;
			// <<< TH√äM: Validate v√† l√†m s·∫°ch fenceData >>>
        if (plot.fenceData && typeof plot.fenceData === 'object' && plot.fenceData.id === 'raobaove' && ITEM_DATA.raobaove) {
            const fenceHealthSave = parseInt(plot.fenceData.health);
            // Ch·ªâ l∆∞u n·∫øu health h·ª£p l·ªá (k·ªÉ c·∫£ khi b·∫±ng 0 - t·ª©c l√† b·ªã h·ªèng)
            if (!isNaN(fenceHealthSave) && fenceHealthSave >= 0 && fenceHealthSave <= ITEM_DATA.raobaove.health) {
                cleanPlot.fenceData = { id: 'raobaove', health: fenceHealthSave };
            } else {
                cleanPlot.fenceData = null; // Kh√¥ng l∆∞u n·∫øu health kh√¥ng h·ª£p l·ªá
            }
        } else {
            cleanPlot.fenceData = null; // Kh√¥ng l∆∞u n·∫øu kh√¥ng c√≥ ho·∫∑c ID kh√¥ng ƒë√∫ng
        }
        // <<< K·∫æT TH√öC: Validate fenceData >>>
			
			
			
			
            return cleanPlot;
        });
         // ƒê·∫£m b·∫£o m·∫£ng plots c√≥ ƒë·ªß s·ªë l∆∞·ª£ng √¥ t∆∞∆°ng ·ª©ng v·ªõi maxUnlockedPlots
         while (stateToSave.plots.length < stateToSave.maxUnlockedPlots) {
             const newIndex = stateToSave.plots.length;
             console.warn(`saveGame: Th√™m plot m·∫∑c ƒë·ªãnh cho index ${newIndex} b·ªã thi·∫øu.`);
             stateToSave.plots.push({ id: newIndex, ...JSON.parse(JSON.stringify(defaultPlotStateForSave)) });
         }


        // 5. Validate Action History (ch·ªâ l∆∞u t·ªëi ƒëa MAX_HISTORY_ENTRIES)
        if (!Array.isArray(stateToSave.actionHistory)) stateToSave.actionHistory = [];
        // Gi·ªØ l·∫°i c√°c m·ª•c m·ªõi nh·∫•t n·∫øu v∆∞·ª£t qu√° gi·ªõi h·∫°n
        if (stateToSave.actionHistory.length > MAX_HISTORY_ENTRIES) {
            stateToSave.actionHistory = stateToSave.actionHistory.slice(0, MAX_HISTORY_ENTRIES);
        }
        // L·ªçc b·ªè c√°c entry kh√¥ng h·ª£p l·ªá (thi·∫øu timestamp ho·∫∑c kh√¥ng ph·∫£i object)
        stateToSave.actionHistory = stateToSave.actionHistory.filter(entry => entry && typeof entry === 'object' && typeof entry.timestamp === 'number');

        // 6. Validate Weather Data and Timestamps
        // ƒê·∫£m b·∫£o currentWeather l√† m·ªôt object h·ª£p l·ªá t·ª´ WEATHER_DATA
        if (!stateToSave.currentWeather || typeof stateToSave.currentWeather !== 'object' || !WEATHER_DATA.some(w => w.id === stateToSave.currentWeather.id)) {
            console.warn("saveGame: Th·ªùi ti·∫øt kh√¥ng h·ª£p l·ªá, ƒë·∫∑t l·∫°i v·ªÅ m·∫∑c ƒë·ªãnh.");
            // L·∫•y tr·∫°ng th√°i m·∫∑c ƒë·ªãnh t·ª´ defaultState ƒë√£ ƒë·ªãnh nghƒ©a ·ªü loadGame (ho·∫∑c ƒë·ªãnh nghƒ©a l·∫°i ·ªü ƒë√¢y)
             const defaultWeather = WEATHER_DATA[0]; // L·∫•y c√°i ƒë·∫ßu ti√™n l√†m m·∫∑c ƒë·ªãnh
             stateToSave.currentWeather = JSON.parse(JSON.stringify(defaultWeather));
        }
        // ƒê·∫£m b·∫£o c√°c timestamp l√† s·ªë d∆∞∆°ng h·ª£p l·ªá
        stateToSave.nextWeatherChangeTimestamp = (typeof stateToSave.nextWeatherChangeTimestamp === 'number' && stateToSave.nextWeatherChangeTimestamp > 0) ? stateToSave.nextWeatherChangeTimestamp : now + WEATHER_CHANGE_INTERVAL_MS;
        stateToSave.currentWeatherStartTime = (typeof stateToSave.currentWeatherStartTime === 'number' && stateToSave.currentWeatherStartTime > 0) ? stateToSave.currentWeatherStartTime : stateToSave.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS;
         // ƒê·∫£m b·∫£o currentWeatherStartTime h·ª£p l√Ω so v·ªõi nextWeatherChangeTimestamp
        if (stateToSave.currentWeatherStartTime > stateToSave.nextWeatherChangeTimestamp || stateToSave.currentWeatherStartTime <= 0) {
             stateToSave.currentWeatherStartTime = Math.max(1, stateToSave.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS);
        }
        stateToSave.nextDryCheckTimestamp = (typeof stateToSave.nextDryCheckTimestamp === 'number' && stateToSave.nextDryCheckTimestamp > 0) ? stateToSave.nextDryCheckTimestamp : now + (15 + Math.random() * 30) * 1000; // L√™n l·ªãch l·∫°i n·∫øu kh√¥ng h·ª£p l·ªá

        // 7. Validate Tornado Data (ch·ªâ l∆∞u active tornadoes ch∆∞a h·∫øt h·∫°n)
        if (!Array.isArray(stateToSave.activeTornadoes)) stateToSave.activeTornadoes = [];
        const currentMaxPlotsSave = stateToSave.maxUnlockedPlots; // D√πng max plot ƒë√£ validate
        stateToSave.activeTornadoes = stateToSave.activeTornadoes.filter(t =>
            t && typeof t === 'object' && // ƒê·∫£m b·∫£o l√† object
            typeof t.plotId === 'number' && t.plotId >= 0 && t.plotId < currentMaxPlotsSave &&
            typeof t.expireTimestamp === 'number' && t.expireTimestamp > now && // Ch·ªâ l∆∞u nh·ªØng c√°i ch∆∞a h·∫øt h·∫°n t·∫°i th·ªùi ƒëi·ªÉm L∆ØU
            typeof t.isDestruction === 'boolean' &&
            typeof t.targetType === 'string' // ƒê·∫£m b·∫£o c√°c tr∆∞·ªùng c·∫ßn thi·∫øt t·ªìn t·∫°i v√† ƒë√∫ng ki·ªÉu
        );
        stateToSave.nextTornadoEventTimestamp = (typeof stateToSave.nextTornadoEventTimestamp === 'number' && stateToSave.nextTornadoEventTimestamp >= 0) ? stateToSave.nextTornadoEventTimestamp : 0; // Ch·ªâ c·∫ßn >= 0

        // 8. Validate Lightning Rods
        if (!Array.isArray(stateToSave.lightningRods)) {
            console.warn("saveGame: gameState.lightningRods kh√¥ng ph·∫£i m·∫£ng, ƒë·∫∑t l·∫°i th√†nh r·ªóng.");
            stateToSave.lightningRods = [];
        } else {
            // L·ªçc b·ªè d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá TR∆Ø·ªöC KHI L∆ØU
            stateToSave.lightningRods = stateToSave.lightningRods.filter(rod =>
               rod && typeof rod === 'object' && // ƒê·∫£m b·∫£o l√† object
               typeof rod.plotId === 'number' && rod.plotId >= 0 && rod.plotId < currentMaxPlotsSave && // D√πng max plot ƒë√£ validate
               typeof rod.health === 'number' && rod.health >= 0 && rod.health <= LIGHTNING_ROD_MAX_HEALTH &&
               typeof rod.repairCost === 'number' && rod.repairCost >= LIGHTNING_ROD_INITIAL_REPAIR_COST
            );
        }
		
		 // === [M·ªöI] VALIDATE V√Ä L√ÄM S·∫†CH dailyQuests v√† lastQuestResetDate ===
           if (!Array.isArray(stateToSave.dailyQuests)) stateToSave.dailyQuests = [];
           // L·ªçc b·ªè c√°c quest kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ ho√†n th√†nh v√† nh·∫≠n th∆∞·ªüng (t√πy ch·ªçn, c√≥ th·ªÉ gi·ªØ l·∫°i ƒë·ªÉ hi·ªÉn th·ªã)
           stateToSave.dailyQuests = stateToSave.dailyQuests.filter(q => q && QUEST_TYPES[q.type?.toUpperCase()]).map(q => ({
               // Ch·ªâ l∆∞u c√°c thu·ªôc t√≠nh c·∫ßn thi·∫øt
               type: q.type,
               description: q.description || 'N/A',
               targetItemId: q.targetItemId || null,
               targetQuantity: Math.max(1, parseInt(q.targetQuantity || 1)),
               rewardCurrency: Math.max(1, parseInt(q.rewardCurrency || 1)),
               currentProgress: Math.max(0, parseInt(q.currentProgress || 0)),
               isCompleted: !!q.isCompleted,
               isClaimed: !!q.isClaimed
           }));
           // ƒê·∫£m b·∫£o c√≥ ƒë√∫ng 10 quest, n·∫øu kh√¥ng th√¨ c√≥ l·ªói -> c√≥ th·ªÉ reset khi load
           if (stateToSave.dailyQuests.length > NUM_DAILY_QUESTS) {
               stateToSave.dailyQuests = stateToSave.dailyQuests.slice(0, NUM_DAILY_QUESTS);
           }

           // Validate date string format (ƒë∆°n gi·∫£n)
           const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
           if (typeof stateToSave.lastQuestResetDate !== 'string' || !dateRegex.test(stateToSave.lastQuestResetDate)) {
               console.warn("saveGame: lastQuestResetDate kh√¥ng h·ª£p l·ªá, ƒë·∫∑t th√†nh null.");
               stateToSave.lastQuestResetDate = null; // S·∫Ω ƒë∆∞·ª£c reset khi load
           }
           // =============================================================
		

		// 9. Validate maxInventoryCapacity
stateToSave.maxInventoryCapacity = (typeof stateToSave.maxInventoryCapacity === 'number' && stateToSave.maxInventoryCapacity >= INITIAL_MAX_INVENTORY_CAPACITY)
                                 ? stateToSave.maxInventoryCapacity
                                 : INITIAL_MAX_INVENTORY_CAPACITY;



        // --- Chuy·ªÉn ƒë·ªïi state ƒë√£ l√†m s·∫°ch th√†nh JSON ---
        const saveData = JSON.stringify(stateToSave);

        // --- L∆∞u v√†o localStorage ---
        localStorage.setItem(GAME_SAVE_KEY, saveData);

        // L∆∞u l·ªãch s·ª≠ h√†nh ƒë·ªông (ri√™ng bi·ªát - l·∫•y t·ª´ gameState g·ªëc v√¨ n√≥ ƒë√£ ƒë∆∞·ª£c gi·ªõi h·∫°n khi th√™m)
        try {
            // L·ªçc l·∫°i l·ªãch s·ª≠ m·ªôt l·∫ßn n·ªØa tr∆∞·ªõc khi l∆∞u ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng c√≥ l·ªói
            const historyToSave = gameState.actionHistory.filter(entry => entry && typeof entry === 'object' && typeof entry.timestamp === 'number');
            const historyData = JSON.stringify(historyToSave);
            localStorage.setItem(HISTORY_SAVE_KEY, historyData);
        } catch (historyError) {
             console.error("L·ªói khi l∆∞u l·ªãch s·ª≠ h√†nh ƒë·ªông:", historyError);
        }

        // console.log("Tr·∫°ng th√°i game (ƒë√£ validate v√† d·ªçn d·∫πp) ƒë√£ l∆∞u.");

    } catch (error) {
        console.error("L·ªói nghi√™m tr·ªçng khi l∆∞u game:", error);
        showMessage("L·ªói: Kh√¥ng th·ªÉ l∆∞u game! D·ªØ li·ªáu c√≥ th·ªÉ kh√¥ng h·ª£p l·ªá.", "error", MESSAGE_DISPLAY_TIME * 1.5);
    }
}


        /** T·∫£i tr·∫°ng th√°i game t·ª´ localStorage v√† th·ª±c hi·ªán m√¥ ph·ªèng offline n·∫øu c·∫ßn. */
       function loadGame() {
    console.log(`ƒêang c·ªë t·∫£i tr·∫°ng th√°i game t·ª´ kh√≥a: ${GAME_SAVE_KEY}`);
    let loadedState = null;
    const nowForLoad = Date.now();

    // --- Tr·∫°ng th√°i m·∫∑c ƒë·ªãnh ƒë·∫ßy ƒë·ªß (cho gameState) ---
    const defaultState = {
        currency: INITIAL_CURRENCY, plots: [], maxUnlockedPlots: INITIAL_PLOT_COUNT,
        inventory: { pesticide: INITIAL_PESTICIDE }, harvestedItems: {},
        lastUpdateTimestamp: nowForLoad, gameStartTime: nowForLoad, totalPlayTime: 0,
        actionHistory: [], currentWeather: WEATHER_DATA[0], // M·∫∑c ƒë·ªãnh l√† ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n
        nextWeatherChangeTimestamp: nowForLoad + WEATHER_CHANGE_INTERVAL_MS,
        currentWeatherStartTime: nowForLoad,
        nextDryCheckTimestamp: nowForLoad + (15 + Math.random() * 30) * 1000,
        activeTornadoes: [], nextTornadoEventTimestamp: 0, lightningRods: [],
		maxInventoryCapacity: INITIAL_MAX_INVENTORY_CAPACITY,
    };
     const defaultPlotStateForLoad = {
        seedId: null, plantTime: null, hasPest: false, health: INITIAL_PLANT_HEALTH,
        fertility: BASE_FERTILITY, causeOfDeath: null, pestDeathClickCount: 0,
        barrenHarvestPenaltyFactor: 1.0, isDry: false
    };

    // --- T·∫£i Tr·∫°ng Th√°i √Çm Thanh T·ª™ LOCALSTORAGE ---
    // ƒê·ªçc gi√° tr·ªã ƒë√£ l∆∞u ho·∫∑c null n·∫øu ch∆∞a c√≥
    const savedMusicEnabled = localStorage.getItem(MUSIC_ENABLED_KEY);
    const savedEffectsEnabled = localStorage.getItem(EFFECTS_ENABLED_KEY);

    // G√°n gi√° tr·ªã cho bi·∫øn to√†n c·ª•c isMusicEnabled
    // N·∫øu ch∆∞a c√≥ g√¨ l∆∞u (null), s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh l√† true (b·∫≠t)
    // N·∫øu c√≥ gi√° tr·ªã l∆∞u, chuy·ªÉn ƒë·ªïi chu·ªói 'true'/'false' th√†nh boolean
    isMusicEnabled = (savedMusicEnabled === null) ? true : (savedMusicEnabled === 'true');

    // G√°n gi√° tr·ªã cho bi·∫øn to√†n c·ª•c areEffectSoundsEnabled t∆∞∆°ng t·ª±
    areEffectSoundsEnabled = (savedEffectsEnabled === null) ? true : (savedEffectsEnabled === 'true');

    // Log gi√° tr·ªã ƒë√£ t·∫£i ƒë·ªÉ ki·ªÉm tra
    console.log(`SOUND LOAD: Music Setting read from localStorage ('${savedMusicEnabled}') => isMusicEnabled = ${isMusicEnabled}`);
    console.log(`SOUND LOAD: Effects Setting read from localStorage ('${savedEffectsEnabled}') => areEffectSoundsEnabled = ${areEffectSoundsEnabled}`);
    // --- K·∫øt th√∫c t·∫£i tr·∫°ng th√°i √¢m thanh ---

    // --- T·∫£i Tr·∫°ng Th√°i Game Ch√≠nh (gameState) ---
    try {
        const savedDataString = localStorage.getItem(GAME_SAVE_KEY);
        if (savedDataString) {
            loadedState = JSON.parse(savedDataString);
            console.log("ƒê√£ t√¨m th·∫•y v√† ph√¢n t√≠ch d·ªØ li·ªáu game ƒë√£ l∆∞u.");

            // --- H·ª£p nh·∫•t tr·∫°ng th√°i game c∆° b·∫£n ---
            gameState.currency = (typeof loadedState.currency === 'number' && loadedState.currency >= 0) ? Math.floor(loadedState.currency) : defaultState.currency;
            gameState.maxUnlockedPlots = (typeof loadedState.maxUnlockedPlots === 'number' && loadedState.maxUnlockedPlots >= INITIAL_PLOT_COUNT) ? loadedState.maxUnlockedPlots : defaultState.maxUnlockedPlots;
            gameState.lastUpdateTimestamp = (typeof loadedState.lastUpdateTimestamp === 'number' && loadedState.lastUpdateTimestamp > 0) ? loadedState.lastUpdateTimestamp : defaultState.lastUpdateTimestamp;
            gameState.gameStartTime = (typeof loadedState.gameStartTime === 'number' && loadedState.gameStartTime > 0) ? loadedState.gameStartTime : defaultState.gameStartTime;
            gameState.totalPlayTime = (typeof loadedState.totalPlayTime === 'number' && loadedState.totalPlayTime >= 0) ? loadedState.totalPlayTime : defaultState.totalPlayTime;

			// <<< T·∫£i maxInventoryCapacity >>>
gameState.maxInventoryCapacity = (typeof loadedState.maxInventoryCapacity === 'number' && loadedState.maxInventoryCapacity >= INITIAL_MAX_INVENTORY_CAPACITY)
                                 ? loadedState.maxInventoryCapacity
                                 : INITIAL_MAX_INVENTORY_CAPACITY;

            // --- T·∫£i Inventory (ƒê√£ Mua) ---
            const loadedInventory = (typeof loadedState.inventory === 'object' && loadedState.inventory !== null) ? loadedState.inventory : {};
            gameState.inventory = {};
            for (const itemId in loadedInventory) {
                if (ITEM_DATA[itemId]) {
                    const quantity = parseInt(loadedInventory[itemId]);
                    if (!isNaN(quantity) && quantity > 0) gameState.inventory[itemId] = quantity;
                }
            }
            if (gameState.inventory.pesticide === undefined && ITEM_DATA['pesticide']) gameState.inventory.pesticide = 0;

             // --- T·∫£i Harvested Items (H·ªó tr·ª£ ƒë·ªãnh d·∫°ng c≈©/m·ªõi) ---
             const loadedHarvested = (typeof loadedState.harvestedItems === 'object' && loadedState.harvestedItems !== null) ? loadedState.harvestedItems : {};
             gameState.harvestedItems = {};
             for (const itemId in loadedHarvested) {
                 if (ITEM_DATA[itemId] && ITEM_DATA[itemId].type === 'seed') {
                     const itemData = loadedHarvested[itemId];
                     // ƒê·ªãnh d·∫°ng M·ªöI
                     if (typeof itemData === 'object' && itemData !== null && (itemData.hasOwnProperty(QUALITY_TIERS.PERFECT) || /*...*/ itemData.hasOwnProperty(QUALITY_TIERS.POOR))) {
                         const newItemQualityData = {
                             [QUALITY_TIERS.PERFECT]: Math.max(0, parseInt(itemData[QUALITY_TIERS.PERFECT] || 0)),
                             [QUALITY_TIERS.GOOD]:    Math.max(0, parseInt(itemData[QUALITY_TIERS.GOOD] || 0)),
                             [QUALITY_TIERS.FAIR]:    Math.max(0, parseInt(itemData[QUALITY_TIERS.FAIR] || 0)),
                             [QUALITY_TIERS.POOR]:    Math.max(0, parseInt(itemData[QUALITY_TIERS.POOR] || 0))
                         };
                         const totalQtyCheck = Object.values(newItemQualityData).reduce((sum, count) => sum + count, 0);
                         if (totalQtyCheck > 0) gameState.harvestedItems[itemId] = newItemQualityData;
                     }
                     // ƒê·ªãnh d·∫°ng C≈®
                     else if (typeof itemData === 'number' || (typeof itemData === 'string' && !isNaN(parseInt(itemData)))) {
                         const quantity = parseInt(itemData);
                         if (!isNaN(quantity) && quantity > 0) {
                             console.warn(`loadGame: Chuy·ªÉn ƒë·ªïi harvestedItem ƒë·ªãnh d·∫°ng c≈© ${itemId} (${quantity}) sang ch·∫•t l∆∞·ª£ng "Th∆∞·ªùng".`);
                             gameState.harvestedItems[itemId] = { [QUALITY_TIERS.PERFECT]: 0, [QUALITY_TIERS.GOOD]: 0, [QUALITY_TIERS.FAIR]: quantity, [QUALITY_TIERS.POOR]: 0 };
                         }
                     }
                 }
             }

            // --- T·∫£i plots ---
            const loadedPlots = Array.isArray(loadedState.plots) ? loadedState.plots : [];
            gameState.plots = [];
            const plotsToLoadCount = Math.min(loadedPlots.length, gameState.maxUnlockedPlots);
            console.log(`S·∫Ω t·∫£i d·ªØ li·ªáu cho ${plotsToLoadCount} √¥ ƒë·∫•t.`);
            for (let i = 0; i < plotsToLoadCount; i++) {
                const savedPlot = loadedPlots[i] || {};
                const newPlot = { id: i, ...JSON.parse(JSON.stringify(defaultPlotStateForLoad)) };
                // G√°n v√† validate t·ª´ng thu·ªôc t√≠nh plot (seedId, plantTime, hasPest, health, fertility, ...)
                newPlot.seedId = (savedPlot.seedId && ITEM_DATA[savedPlot.seedId]) ? savedPlot.seedId : null;
                newPlot.plantTime = (typeof savedPlot.plantTime === 'number' && savedPlot.plantTime > 0 && newPlot.seedId) ? savedPlot.plantTime : null;
                newPlot.hasPest = typeof savedPlot.hasPest === 'boolean' ? savedPlot.hasPest : false;
                newPlot.health = (typeof savedPlot.health === 'number') ? Math.max(0, Math.min(INITIAL_PLANT_HEALTH, savedPlot.health)) : INITIAL_PLANT_HEALTH;
                newPlot.fertility = (typeof savedPlot.fertility === 'number') ? Math.max(0, Math.min(BASE_FERTILITY, savedPlot.fertility)) : BASE_FERTILITY;
                newPlot.causeOfDeath = (typeof savedPlot.causeOfDeath === 'string' || savedPlot.causeOfDeath === null) ? savedPlot.causeOfDeath : null;
                newPlot.pestDeathClickCount = (typeof savedPlot.pestDeathClickCount === 'number' && savedPlot.pestDeathClickCount >= 0) ? savedPlot.pestDeathClickCount : 0;
                newPlot.barrenHarvestPenaltyFactor = (typeof savedPlot.barrenHarvestPenaltyFactor === 'number' && savedPlot.barrenHarvestPenaltyFactor >= 1.0) ? savedPlot.barrenHarvestPenaltyFactor : 1.0;
                newPlot.isDry = typeof savedPlot.isDry === 'boolean' ? savedPlot.isDry : false;
				
				  newPlot.fertilizerProtectUsageCount = (typeof savedPlot.fertilizerProtectUsageCount === 'number' && savedPlot.fertilizerProtectUsageCount >= 0) ? savedPlot.fertilizerProtectUsageCount : 0;
            // Load buff, ƒë·∫£m b·∫£o n√≥ ch·ªâ b·∫≠t n·∫øu c√≥ c√¢y s·ªëng v√† count > 0
            newPlot.hasFertilizerProtectBuff = (typeof savedPlot.hasFertilizerProtectBuff === 'boolean' && newPlot.seedId && newPlot.health > 0 && newPlot.fertilizerProtectUsageCount > 0) ? savedPlot.hasFertilizerProtectBuff : false;
				
				
				// T·∫£i fertilizerGrowthUsageCount
             newPlot.fertilizerGrowthUsageCount = (typeof savedPlot.fertilizerGrowthUsageCount === 'number' && savedPlot.fertilizerGrowthUsageCount >= 0) ? savedPlot.fertilizerGrowthUsageCount : 0;
             //ƒë√£ th√™m/k·∫øt th√∫c c·∫≠p nh·∫≠t
				
				
				// <<< TH√äM: T·∫£i v√† validate fenceData >>>
            if (savedPlot.fenceData && savedPlot.fenceData.id === 'raobaove' && ITEM_DATA.raobaove) {
                 const fenceHealthLoad = parseInt(savedPlot.fenceData.health);
                 if (!isNaN(fenceHealthLoad) && fenceHealthLoad >= 0 && fenceHealthLoad <= ITEM_DATA.raobaove.health) {
                     newPlot.fenceData = { id: 'raobaove', health: fenceHealthLoad };
                 } else {
                      newPlot.fenceData = null;
                 }
            } else {
                 newPlot.fenceData = null;
            }
            // <<< K·∫æT TH√öC: T·∫£i fenceData >>>
				
				
                if (newPlot.seedId === null) { newPlot.plantTime = null; }
                gameState.plots[i] = newPlot;
            }
            // ƒê·∫£m b·∫£o ƒë·ªß s·ªë √¥
            while (gameState.plots.length < gameState.maxUnlockedPlots) {
                 const newIndex = gameState.plots.length;
                 console.warn(`loadGame: Th√™m plot m·∫∑c ƒë·ªãnh cho index ${newIndex} b·ªã thi·∫øu.`);
                 gameState.plots.push({ id: newIndex, ...JSON.parse(JSON.stringify(defaultPlotStateForLoad)) });
            }

            // --- T·∫£i l·ªãch s·ª≠ h√†nh ƒë·ªông ---
            const savedHistoryString = localStorage.getItem(HISTORY_SAVE_KEY);
            if (savedHistoryString) {
                try {
                    gameState.actionHistory = JSON.parse(savedHistoryString);
                    if (!Array.isArray(gameState.actionHistory)) throw new Error("History is not an array");
                    // Gi·ªõi h·∫°n v√† l·ªçc entry kh√¥ng h·ª£p l·ªá
                    if (gameState.actionHistory.length > MAX_HISTORY_ENTRIES * 1.5) gameState.actionHistory = gameState.actionHistory.slice(0, MAX_HISTORY_ENTRIES);
                    gameState.actionHistory = gameState.actionHistory.filter(entry => entry && typeof entry === 'object' && typeof entry.timestamp === 'number');
                } catch (e) { gameState.actionHistory = []; console.warn("L·ªói parse l·ªãch s·ª≠, reset.", e); }
            } else { gameState.actionHistory = []; }

            // --- T·∫£i Th·ªùi Ti·∫øt, Timestamps, Tornadoes, Rods ---
            // Validate v√† g√°n currentWeather
            let weatherSet = false;
            if (typeof loadedState.currentWeather === 'object' && loadedState.currentWeather !== null && loadedState.currentWeather.id) {
                const foundWeather = WEATHER_DATA.find(data => data.id === loadedState.currentWeather.id);
                if (foundWeather) { gameState.currentWeather = JSON.parse(JSON.stringify(foundWeather)); weatherSet = true; }
            }
            if (!weatherSet) { gameState.currentWeather = JSON.parse(JSON.stringify(defaultState.currentWeather)); }
            // Validate v√† g√°n c√°c timestamps
            gameState.nextWeatherChangeTimestamp = (typeof loadedState.nextWeatherChangeTimestamp === 'number' && loadedState.nextWeatherChangeTimestamp > 0) ? loadedState.nextWeatherChangeTimestamp : defaultState.nextWeatherChangeTimestamp;
            gameState.currentWeatherStartTime = (typeof loadedState.currentWeatherStartTime === 'number' && loadedState.currentWeatherStartTime > 0) ? loadedState.currentWeatherStartTime : defaultState.currentWeatherStartTime;
            // ƒêi·ªÅu ch·ªânh startTime n·∫øu kh√¥ng h·ª£p l·ªá
            if (gameState.currentWeatherStartTime > gameState.nextWeatherChangeTimestamp || gameState.currentWeatherStartTime < gameState.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS - 10000) {
                gameState.currentWeatherStartTime = Math.max(1, gameState.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS);
            }
            // Tua nhanh nextWeatherChangeTimestamp n·∫øu ƒë√£ qua
            if(gameState.nextWeatherChangeTimestamp <= gameState.lastUpdateTimestamp){
                 const cyclesPassed = Math.floor((gameState.lastUpdateTimestamp - gameState.nextWeatherChangeTimestamp) / WEATHER_CHANGE_INTERVAL_MS) + 1;
                 gameState.nextWeatherChangeTimestamp += cyclesPassed * WEATHER_CHANGE_INTERVAL_MS;
                 gameState.currentWeatherStartTime = gameState.nextWeatherChangeTimestamp - WEATHER_CHANGE_INTERVAL_MS;
            }
            gameState.nextDryCheckTimestamp = (typeof loadedState.nextDryCheckTimestamp === 'number' && loadedState.nextDryCheckTimestamp > gameState.lastUpdateTimestamp)
                 ? loadedState.nextDryCheckTimestamp : gameState.lastUpdateTimestamp + (15 + Math.random() * 30) * 1000;
            // Validate activeTornadoes
            gameState.activeTornadoes = Array.isArray(loadedState.activeTornadoes) ? loadedState.activeTornadoes : [];
            const currentMaxPlotsTornadoLoad = gameState.maxUnlockedPlots;
            gameState.activeTornadoes = gameState.activeTornadoes.filter(t => t && typeof t.plotId === 'number' && t.plotId >= 0 && t.plotId < currentMaxPlotsTornadoLoad && typeof t.expireTimestamp === 'number' && t.expireTimestamp > nowForLoad && typeof t.isDestruction === 'boolean' && typeof t.targetType === 'string');
            gameState.nextTornadoEventTimestamp = (typeof loadedState.nextTornadoEventTimestamp === 'number' && loadedState.nextTornadoEventTimestamp >= 0) ? loadedState.nextTornadoEventTimestamp : 0;
            // Validate lightningRods
            gameState.lightningRods = Array.isArray(loadedState.lightningRods) ? loadedState.lightningRods : [];
            const currentMaxPlotsRodLoad = gameState.maxUnlockedPlots;
            gameState.lightningRods = gameState.lightningRods.filter(rod => rod && typeof rod.plotId === 'number' && rod.plotId >= 0 && rod.plotId < currentMaxPlotsRodLoad && typeof rod.health === 'number' && rod.health >= 0 && rod.health <= LIGHTNING_ROD_MAX_HEALTH && typeof rod.repairCost === 'number' && rod.repairCost >= LIGHTNING_ROD_INITIAL_REPAIR_COST);

			// === T·∫¢I V√Ä KI·ªÇM TRA NHI·ªÜM V·ª§ H·∫∞NG NG√ÄY ===
            const loadedQuests = Array.isArray(loadedState.dailyQuests) ? loadedState.dailyQuests : [];
            const loadedResetDate = typeof loadedState.lastQuestResetDate === 'string' ? loadedState.lastQuestResetDate : null;
            const currentDateStr = getCurrentDateString();

            if (loadedResetDate !== currentDateStr || loadedQuests.length !== NUM_DAILY_QUESTS) {
                // N·∫øu ng√†y kh√°c HO·∫∂C s·ªë l∆∞·ª£ng quest kh√¥ng ƒë√∫ng -> T·∫°o m·ªõi
                console.log(`Quest reset needed. Saved date: ${loadedResetDate}, Current date: ${currentDateStr}, Quest count: ${loadedQuests.length}`);
                generateDailyQuests(); // H√†m n√†y s·∫Ω c·∫≠p nh·∫≠t gameState.dailyQuests v√† gameState.lastQuestResetDate
            } else {
                // Ng√†y gi·ªëng nhau v√† s·ªë l∆∞·ª£ng ƒë√∫ng -> S·ª≠ d·ª•ng quest ƒë√£ t·∫£i
                console.log(`Quests are up-to-date for ${currentDateStr}. Loading saved quests.`);
                // Validate t·ª´ng quest ƒë√£ t·∫£i (ph√≤ng l·ªói)
                gameState.dailyQuests = loadedQuests.filter(q => q && QUEST_TYPES[q.type?.toUpperCase()]).map(q => ({
                    ...q, // Gi·ªØ l·∫°i c√°c thu·ªôc t√≠nh
                    currentProgress: Math.max(0, parseInt(q.currentProgress || 0)),
                    targetQuantity: Math.max(1, parseInt(q.targetQuantity || 1)),
                    rewardCurrency: Math.max(1, parseInt(q.rewardCurrency || 1)),
                    isCompleted: !!q.isCompleted, // ƒê·∫£m b·∫£o l√† boolean
                    isClaimed: !!q.isClaimed      // ƒê·∫£m b·∫£o l√† boolean
                }));
                 // N·∫øu sau khi l·ªçc kh√¥ng ƒë·ªß 10 quest, t·∫°o l·∫°i t·ª´ ƒë·∫ßu
                 if(gameState.dailyQuests.length < NUM_DAILY_QUESTS) {
                    console.warn("S·ªë l∆∞·ª£ng quest h·ª£p l·ªá sau khi load √≠t h∆°n mong ƒë·ª£i, ƒëang t·∫°o l·∫°i...");
                    generateDailyQuests();
                 } else {
                     gameState.lastQuestResetDate = loadedResetDate; // Gi·ªØ ng√†y ƒë√£ l∆∞u
                 }
            }
            // ==================================================




            // --- M√¥ ph·ªèng Ti·∫øn tr√¨nh Offline ---
            const timeDiff = nowForLoad - gameState.lastUpdateTimestamp;
            let stateChangedByOfflineSim = false;
            if (timeDiff > TICK_INTERVAL * 1.5 && gameState.lastUpdateTimestamp > 0) {
                console.log(`Ph√°t hi·ªán th·ªùi gian offline: ${formatTime(timeDiff)}. B·∫Øt ƒë·∫ßu m√¥ ph·ªèng.`);
                gameState.totalPlayTime += timeDiff; // C·ªông d·ªìn th·ªùi gian offline
                stateChangedByOfflineSim = simulateOfflineProgress(gameState.lastUpdateTimestamp, nowForLoad);
                gameState.lastUpdateTimestamp = nowForLoad; // C·∫≠p nh·∫≠t l·∫°i timestamp sau m√¥ ph·ªèng
            } else { // Th·ªùi gian offline ng·∫Øn ho·∫∑c l·∫ßn ƒë·∫ßu ch∆°i
                 if (timeDiff > 0 && gameState.lastUpdateTimestamp > 0) gameState.totalPlayTime += timeDiff;
                 gameState.lastUpdateTimestamp = nowForLoad; // C·∫≠p nh·∫≠t timestamp
            }

            // --- C·∫≠p nh·∫≠t l·∫°i c√°c timers n·∫øu c·∫ßn sau m√¥ ph·ªèng ---
            if (gameState.nextDryCheckTimestamp <= nowForLoad) { gameState.nextDryCheckTimestamp = nowForLoad + (15 + Math.random() * 30) * 1000; }
            if (gameState.currentWeather.id === 'windy' && gameState.nextTornadoEventTimestamp <= nowForLoad) {
                 const nextInterval = TORNADO_EVENT_MIN_INTERVAL_MS_WINDY + Math.random() * (TORNADO_EVENT_MAX_INTERVAL_MS_WINDY - TORNADO_EVENT_MIN_INTERVAL_MS_WINDY);
                 gameState.nextTornadoEventTimestamp = nowForLoad + nextInterval;
            }
            const tornadoesBeforeFinalFilter = gameState.activeTornadoes.length;
            gameState.activeTornadoes = gameState.activeTornadoes.filter(t => t.expireTimestamp > nowForLoad);
            if (gameState.activeTornadoes.length < tornadoesBeforeFinalFilter) stateChangedByOfflineSim = true;

            if (stateChangedByOfflineSim || weatherUpdateNeeded) {
                 weatherUpdateNeeded = true; // ƒê√°nh d·∫•u c·∫ßn c·∫≠p nh·∫≠t UI th·ªùi ti·∫øt
            }

        } else { // Kh√¥ng t√¨m th·∫•y save game ch√≠nh
            console.log("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu game ƒë√£ l∆∞u. B·∫Øt ƒë·∫ßu game m·ªõi.");
            gameState = JSON.parse(JSON.stringify(defaultState)); // S·ª≠ d·ª•ng default state
            gameState.lastUpdateTimestamp = nowForLoad; gameState.gameStartTime = nowForLoad; // C·∫≠p nh·∫≠t timestamp
            gameState.nextWeatherChangeTimestamp = nowForLoad + WEATHER_CHANGE_INTERVAL_MS; gameState.currentWeatherStartTime = nowForLoad;
            gameState.nextDryCheckTimestamp = nowForLoad + (15 + Math.random() * 30) * 1000;
            localStorage.removeItem(HISTORY_SAVE_KEY); // X√≥a l·ªãch s·ª≠ c≈© n·∫øu c√≥
            weatherUpdateNeeded = true; // C·∫ßn c·∫≠p nh·∫≠t UI th·ªùi ti·∫øt l·∫ßn ƒë·∫ßu
        }
    } catch (error) { // L·ªói khi parse ho·∫∑c x·ª≠ l√Ω save game ch√≠nh
        console.error("L·ªói nghi√™m tr·ªçng khi ph√¢n t√≠ch ho·∫∑c x·ª≠ l√Ω tr·∫°ng th√°i game ƒë√£ l∆∞u:", error);
        showMessage("D·ªØ li·ªáu l∆∞u c·ªßa game b·ªã l·ªói. B·∫Øt ƒë·∫ßu game m·ªõi.", "error", MESSAGE_DISPLAY_TIME * 2);
        localStorage.removeItem(GAME_SAVE_KEY); localStorage.removeItem(HISTORY_SAVE_KEY); // X√≥a d·ªØ li·ªáu l·ªói
        gameState = JSON.parse(JSON.stringify(defaultState)); // Reset v·ªÅ m·∫∑c ƒë·ªãnh
        // C·∫≠p nh·∫≠t timestamp cho game m·ªõi
        gameState.lastUpdateTimestamp = nowForLoad; gameState.gameStartTime = nowForLoad;
        gameState.nextWeatherChangeTimestamp = nowForLoad + WEATHER_CHANGE_INTERVAL_MS; gameState.currentWeatherStartTime = nowForLoad;
        gameState.nextDryCheckTimestamp = nowForLoad + (15 + Math.random() * 30) * 1000;
        weatherUpdateNeeded = true;
    }
    console.log("Qu√° tr√¨nh t·∫£i game ho√†n t·∫•t.");
} // --- K·∫øt th√∫c h√†m loadGame ---
		// C·∫≠p nh·∫≠t: M√¥ ph·ªèng th·ªùi ti·∫øt d√πng object (id, icon, name)
/**
 * M√¥ ph·ªèng ti·∫øn tr√¨nh game trong kho·∫£ng th·ªùi gian offline (t·ª´ startTime ƒë·∫øn endTime).
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i th·ªùi ti·∫øt v√† c√°c √¥ ƒë·∫•t.
 * @param {number} startTime - Timestamp (ms) b·∫Øt ƒë·∫ßu kho·∫£ng th·ªùi gian offline.
 * @param {number} endTime - Timestamp (ms) k·∫øt th√∫c kho·∫£ng th·ªùi gian offline (th·ªùi ƒëi·ªÉm load).
 * @returns {boolean} True n·∫øu tr·∫°ng th√°i game (th·ªùi ti·∫øt ho·∫∑c √¥ ƒë·∫•t) c√≥ thay ƒë·ªïi, False n·∫øu kh√¥ng.
 */

        /** [ƒê∆°n Gi·∫£n H√≥a Req 3] M√¥ ph·ªèng ti·∫øn tr√¨nh game trong kho·∫£ng th·ªùi gian offline */
       function simulateOfflineProgress(startTime, endTime) {
            const durationMs = endTime - startTime;
            const missedTicks = Math.floor(durationMs / TICK_INTERVAL);
            if (missedTicks <= 0) return false;

            console.log(`ƒêang m√¥ ph·ªèng ${missedTicks} tick (${formatTime(durationMs)}) ƒë√£ b·ªã b·ªè l·ª°.`);
            let stateChanged = false;
            let weatherChangedDuringSim = false;

            // --- 1. M√¥ ph·ªèng TH·ªúI TI·∫æT tr∆∞·ªõc ---
            let simWeatherObject = JSON.parse(JSON.stringify(gameState.currentWeather));
            let simNextWeatherChange = gameState.nextWeatherChangeTimestamp;
            let simWeatherStartTime = gameState.currentWeatherStartTime;
            let finalSimWeatherObject = simWeatherObject; // Th·ªùi ti·∫øt cu·ªëi c√πng sau m√¥ ph·ªèng

            // Tua nhanh th·ªùi ti·∫øt n·∫øu c·∫ßn
            while (simNextWeatherChange < endTime) {
                const previousWeatherIdSim = simWeatherObject.id;
                let candidateWeather;
                do { candidateWeather = WEATHER_DATA[Math.floor(Math.random() * WEATHER_DATA.length)]; }
                while (candidateWeather.id === previousWeatherIdSim && WEATHER_DATA.length > 1); // Tr√°nh l·∫∑p l·∫°i th·ªùi ti·∫øt c≈© ngay l·∫≠p t·ª©c
                simWeatherObject = candidateWeather;
                simWeatherStartTime = simNextWeatherChange; // Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa chu k·ª≥ th·ªùi ti·∫øt m·ªõi n√†y
                simNextWeatherChange += WEATHER_CHANGE_INTERVAL_MS; // Th·ªùi ƒëi·ªÉm k·∫øt th√∫c chu k·ª≥ m·ªõi
                weatherChangedDuringSim = true; // ƒê√°nh d·∫•u th·ªùi ti·∫øt ƒë√£ thay ƒë·ªïi
                finalSimWeatherObject = simWeatherObject; // L∆∞u l·∫°i th·ªùi ti·∫øt cu·ªëi c√πng
                console.log(`(Sim Offline) Th·ªùi ti·∫øt ƒë·ªïi th√†nh ${simWeatherObject.name || simWeatherObject.icon} (ID: ${simWeatherObject.id}) v√†o l√∫c m√¥ ph·ªèng ${formatTime(simWeatherStartTime - gameState.gameStartTime)}`);

                // N·∫øu th·ªùi ti·∫øt ƒë·ªïi th√†nh m∆∞a -> L√†m h·∫øt kh√¥ c√°c √¥ ƒëang kh√¥
                const rainyWeatherIdsForDrynessSim = ['rainy', 'thunderstorm', 'rainy_sunny'];
                if (rainyWeatherIdsForDrynessSim.includes(simWeatherObject.id)) {
                    for (let k = 0; k < gameState.maxUnlockedPlots; k++) {
                        if (gameState.plots[k]?.isDry) {
                            gameState.plots[k].isDry = false;
                            stateChanged = true; // ƒê√°nh d·∫•u c√≥ thay ƒë·ªïi tr·∫°ng th√°i plot
                            // console.log(`(Sim Offline) Plot ${k} h·∫øt kh√¥ do th·ªùi ti·∫øt ƒë·ªïi th√†nh m∆∞a.`);
                        }
                    }
                }
            }
            // C·∫≠p nh·∫≠t gameState v·ªõi th·ªùi ti·∫øt cu·ªëi c√πng sau m√¥ ph·ªèng
            gameState.currentWeather = JSON.parse(JSON.stringify(finalSimWeatherObject));
            gameState.nextWeatherChangeTimestamp = simNextWeatherChange;
            gameState.currentWeatherStartTime = simWeatherStartTime;
            if(weatherChangedDuringSim) weatherUpdateNeeded = true; // ƒê√°nh d·∫•u c·∫ßn c·∫≠p nh·∫≠t UI th·ªùi ti·∫øt khi load xong

            // --- 2. M√¥ ph·ªèng √î ƒê·∫§T ---
            const p_no_pest_tick = 1 - PEST_APPEARANCE_CHANCE_PER_TICK_PER_PLOT;
            const p_no_pest_total = Math.pow(p_no_pest_tick, missedTicks);
            const p_get_pest_total = 1 - p_no_pest_total; // X√°c su·∫•t b·ªã s√¢u √≠t nh·∫•t 1 l·∫ßn
            let plotStateChanged = false; // C·ªù ri√™ng cho plot

            // --- T√çNH TO√ÅN KH·∫¢ NƒÇNG X·∫¢Y RA TORNADO OFFLINE ---
            let tornadoEventsOccurredOffline = 0;
            let offlineWindyDuration = 0;
            // Ch·ªâ t√≠nh n·∫øu th·ªùi ti·∫øt *cu·ªëi c√πng* l√† Windy
            if (finalSimWeatherObject.id === 'windy') {
                // T√≠nh th·ªùi gian th·ª±c s·ª± ·ªü tr·∫°ng th√°i Windy trong kho·∫£ng offline
                const lastWindyStartTime = simWeatherStartTime > startTime ? simWeatherStartTime : startTime;
                offlineWindyDuration = endTime - lastWindyStartTime;
                if (offlineWindyDuration > 0) {
                    const avgTornadoInterval = (TORNADO_EVENT_MIN_INTERVAL_MS_WINDY + TORNADO_EVENT_MAX_INTERVAL_MS_WINDY) / 2;
                    const expectedTornadoEvents = offlineWindyDuration / avgTornadoInterval;
                    // L√†m tr√≤n ng·∫´u nhi√™n d·ª±a tr√™n ph·∫ßn th·∫≠p ph√¢n
                    tornadoEventsOccurredOffline = Math.floor(expectedTornadoEvents) + (Math.random() < (expectedTornadoEvents % 1) ? 1 : 0);
                    if (tornadoEventsOccurredOffline > 0) {
                         console.log(`(Sim Offline) ∆Ø·ªõc t√≠nh ${tornadoEventsOccurredOffline} s·ª± ki·ªán tornado ƒë√£ x·∫£y ra trong ${formatTime(offlineWindyDuration)} offline (Weather: ${finalSimWeatherObject.id}).`);
                         plotStateChanged = true; // C√≥ kh·∫£ nƒÉng plot thay ƒë·ªïi
                    }
                }
            }
            // -----------------------------------------------------

            // --- V√≤ng l·∫∑p qua t·ª´ng √¥ ƒë·∫•t ƒë·ªÉ m√¥ ph·ªèng ---
            for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                let plot = gameState.plots[i];
                let plotChangedThisSim = false; // C·ªù thay ƒë·ªïi cho ri√™ng √¥ n√†y
                if (!plot) continue; // B·ªè qua n·∫øu √¥ kh√¥ng c√≥ d·ªØ li·ªáu

                // --- √ÅP D·ª§NG T√ÅC ƒê·ªòNG TORNADO OFFLINE TR∆Ø·ªöC ---
                let hitByOfflineTornado = false;
                 // Ch·ªâ x√©t n·∫øu c√≥ s·ª± ki·ªán tornado x·∫£y ra V√Ä √¥ kh√¥ng c√≥ c·ªôt thu l√¥i
                if (tornadoEventsOccurredOffline > 0 && !isPlotWithRod(i)) {
                    const avgPlotsPerEvent = Math.max(1, Math.min(gameState.maxUnlockedPlots, 5)); // S·ªë plot trung b√¨nh m·ªói event
                    const chancePerEvent = avgPlotsPerEvent / Math.max(1, gameState.maxUnlockedPlots); // X√°c su·∫•t tr√∫ng m·ªói event
                    const probNotHit = Math.pow(1 - chancePerEvent, tornadoEventsOccurredOffline); // X√°c su·∫•t KH√îNG b·ªã tr√∫ng
                    const probHitAtLeastOnce = 1 - probNotHit; // X√°c su·∫•t b·ªã tr√∫ng √çT NH·∫§T 1 l·∫ßn

                    // N·∫øu √¥ n√†y ƒë∆∞·ª£c t√≠nh l√† b·ªã ƒë√°nh tr√∫ng
                    if (Math.random() < probHitAtLeastOnce) {
                        hitByOfflineTornado = true;
                        console.log(`(Sim Offline) Plot ${i} ∆∞·ªõc t√≠nh b·ªã tornado ƒë√°nh tr√∫ng.`);
                        let fenceTookHitSim = false; // C·ªù xem r√†o c√≥ h·ª©ng ch·ªãu kh√¥ng

                        // >>> KI·ªÇM TRA H√ÄNG R√ÄO TR∆Ø·ªöC <<<
                        if (plot.fenceData && plot.fenceData.health > 0 && ITEM_DATA.raobaove) {
                            fenceTookHitSim = true; // R√†o s·∫Ω h·ª©ng ch·ªãu
                            const fenceMaxHealthSim = ITEM_DATA.raobaove.health;
                            // Quy·∫øt ƒë·ªãnh lo·∫°i s√°t th∆∞∆°ng *m·ªôt l·∫ßn* cho to√†n b·ªô th·ªùi gian offline (∆∞·ªõc t√≠nh)
                            const isDestructionOffline = Math.random() < TORNADO_DESTRUCTION_CHANCE;

                            console.log(` -> (Sim Offline) H√†ng r√†o √¥ ${i} h·ª©ng ch·ªãu. Lo·∫°i s·ª± ki·ªán ∆∞·ªõc t√≠nh: ${isDestructionOffline ? 'Ph√° h·ªßy' : 'Thi·ªát h·∫°i n·∫∑ng'}.`);

                            let fenceDamageSim = 0;
                            if (isDestructionOffline) {
                                fenceDamageSim = plot.fenceData.health; // Ph√° h·ªßy ho√†n to√†n m√°u c√≤n l·∫°i
                            } else {
                                // ∆Ø·ªõc t√≠nh thi·ªát h·∫°i % m√°u c√≤n l·∫°i
                                fenceDamageSim = plot.fenceData.health * TORNADO_PARTIAL_DAMAGE_FACTOR;
                            }

                            const oldFenceHealthSim = plot.fenceData.health;
                            plot.fenceData.health = Math.max(0, plot.fenceData.health - fenceDamageSim); // Tr·ª´ m√°u r√†o
                            console.log(`(Sim Offline) M√°u r√†o √¥ ${i} gi·∫£m t·ª´ ${oldFenceHealthSim.toFixed(0)} xu·ªëng ${plot.fenceData.health.toFixed(0)}.`);
                            if (plot.fenceData.health === 0 && oldFenceHealthSim > 0) {
                                console.warn(`(Sim Offline) R√†o b·∫£o v·ªá ·ªü √¥ ${i} ∆∞·ªõc t√≠nh b·ªã ph√° h·ªßy!`);
                                logAction('fence_broken', i, `R√†o b·∫£o v·ªá √¥ ${i + 1} ∆∞·ªõc t√≠nh b·ªã gi√≥ l·ªëc ph√° h·ªèng (offline).`, 'üí•üöß', 'raobaove');
                            }
                            plotChangedThisSim = true; // ƒê√°nh d·∫•u plot n√†y ƒë√£ thay ƒë·ªïi
                        }
                        // >>> K·∫æT TH√öC KI·ªÇM TRA H√ÄNG R√ÄO <<<

                        // >>> CH·ªà T·∫§N C√îNG C√ÇY/ƒê·∫§T N·∫æU H√ÄNG R√ÄO KH√îNG H·ª®NG CH·ªäU <<<
                        if (!fenceTookHitSim) {
                            const isDestructionOffline = Math.random() < TORNADO_DESTRUCTION_CHANCE; // Quy·∫øt ƒë·ªãnh l·∫°i n·∫øu r√†o kh√¥ng ch·ªãu
                            const plantNameSim = plot.seedId ? ITEM_DATA[plot.seedId]?.name : "ƒê·∫•t";
                            console.log(` -> (Sim Offline) C√¢y/ƒê·∫•t √¥ ${i} ch·ªãu s√°t th∆∞∆°ng. Lo·∫°i s·ª± ki·ªán ∆∞·ªõc t√≠nh: ${isDestructionOffline ? 'Ph√° h·ªßy' : 'Thi·ªát h·∫°i n·∫∑ng'}.`);

                            if (isDestructionOffline) {
                                // Logic ph√° h·ªßy c√¢y/ƒë·∫•t (√°p d·ª•ng m·ªôt l·∫ßn cho to√†n b·ªô th·ªùi gian offline)
                                if (plot.seedId && plot.health > 0) {
                                    const oldH = plot.health;
                                    plot.health = 0; plot.causeOfDeath = 'tornado';
                                    plot.hasPest = false; plot.isDry = false; plot.pestDeathClickCount = 0;
                                    if (plot.health !== oldH) plotChangedThisSim = true;
                                    console.warn(`(Sim Offline) ${plantNameSim} ·ªü √¥ ${i} ∆∞·ªõc t√≠nh b·ªã h·ªßy di·ªát.`);
                                    logAction('plant_death', i, `${plantNameSim} √¥ ${i+1} ch·∫øt do gi√≥ l·ªëc (offline).`, 'üíÄüå™Ô∏è', plot.seedId);
                                } else if (!plot.seedId && plot.fertility > 0) {
                                    const oldF = plot.fertility;
                                    plot.fertility = 0; plot.barrenHarvestPenaltyFactor = 1.0; plot.isDry = false;
                                    if (plot.fertility !== oldF) plotChangedThisSim = true;
                                    console.log(`(Sim Offline) ƒê·∫•t tr·ªëng √¥ ${i} ∆∞·ªõc t√≠nh th√†nh c·∫±n c·ªói.`);
                                    logAction('soil_barren', i, `ƒê·∫•t √¥ ${i+1} th√†nh c·∫±n do gi√≥ l·ªëc (offline).`, 'üß±üå™Ô∏è', null);
                                }
                            } else { // Thi·ªát h·∫°i m·ªôt ph·∫ßn
                                // Logic thi·ªát h·∫°i m·ªôt ph·∫ßn c√¢y/ƒë·∫•t (√°p d·ª•ng m·ªôt l·∫ßn)
                                if (plot.seedId && plot.health > 0) {
                                    const damage = plot.health * TORNADO_PARTIAL_DAMAGE_FACTOR;
                                    const oldHealthSim = plot.health;
                                    plot.health = Math.max(0, plot.health - damage); // Tr·ª´ % m√°u hi·ªán t·∫°i
                                    if (plot.health !== oldHealthSim) plotChangedThisSim = true;
                                    console.log(`(Sim Offline) ${plantNameSim} ·ªü √¥ ${i} m·∫•t ${damage.toFixed(0)} HP.`);
                                    if (plot.health === 0 && oldHealthSim > 0) {
                                        plot.causeOfDeath = 'tornado';
                                        plot.hasPest = false; plot.isDry = false; plot.pestDeathClickCount = 0;
                                        console.warn(`(Sim Offline) ${plantNameSim} ·ªü √¥ ${i} ∆∞·ªõc t√≠nh ch·∫øt do thi·ªát h·∫°i n·∫∑ng.`);
                                        logAction('plant_death', i, `${plantNameSim} √¥ ${i+1} ch·∫øt do thi·ªát h·∫°i gi√≥ l·ªëc (offline).`, 'üíÄüå™Ô∏è', plot.seedId);
                                    }
                                } else if (!plot.seedId && plot.fertility > 0) {
                                    const damage = plot.fertility * TORNADO_PARTIAL_DAMAGE_FACTOR;
                                    const oldFertilitySim = plot.fertility;
                                    plot.fertility = Math.max(0, plot.fertility - damage); // Tr·ª´ % ƒë·ªô ph√¨ hi·ªán t·∫°i
                                    if (plot.fertility !== oldFertilitySim) plotChangedThisSim = true;
                                    console.log(`(Sim Offline) ƒê·∫•t √¥ ${i} m·∫•t ${damage.toFixed(0)}% ƒë·ªô ph√¨.`);
                                    if (plot.fertility === 0 && oldFertilitySim > 0) {
                                        plot.barrenHarvestPenaltyFactor = 1.0; plot.isDry = false;
                                        console.log(`(Sim Offline) ƒê·∫•t √¥ ${i} ∆∞·ªõc t√≠nh th√†nh c·∫±n c·ªói do thi·ªát h·∫°i n·∫∑ng.`);
                                        logAction('soil_barren', i, `ƒê·∫•t √¥ ${i+1} th√†nh c·∫±n do thi·ªát h·∫°i gi√≥ l·ªëc (offline).`, 'üß±üå™Ô∏è', null);
                                    }
                                }
                            }
                        }
                        // >>> K·∫æT TH√öC T·∫§N C√îNG C√ÇY/ƒê·∫§T <<<
                    } // end if (Math.random() < probHitAtLeastOnce)
                } // end if (tornadoEventsOccurredOffline > 0)

                // N·∫øu ƒë√£ b·ªã tornado offline, b·ªè qua c√°c x·ª≠ l√Ω kh√°c cho √¥ n√†y
                if (hitByOfflineTornado) {
                    if (plotChangedThisSim) plotStateChanged = true; // C·∫≠p nh·∫≠t c·ªù chung n·∫øu plot n√†y thay ƒë·ªïi
                    continue; // <<<< QUAN TR·ªåNG: Chuy·ªÉn sang √¥ ti·∫øp theo
                }
                // --- K·∫øt th√∫c x·ª≠ l√Ω Tornado Offline ---

                // --- M√¥ ph·ªèng KH√î H·∫†N (d·ª±a tr√™n th·ªùi ti·∫øt cu·ªëi - finalSimWeatherObject) ---
                let becameDryOffline = false;
                // Ch·ªâ b·ªã kh√¥ n·∫øu th·ªùi ti·∫øt cu·ªëi l√† n·∫Øng V√Ä √¥ ch∆∞a kh√¥
                if (finalSimWeatherObject.id === 'sunny' && !plot.isDry) {
                    // X√°c su·∫•t b·ªã kh√¥ tƒÉng theo th·ªùi gian offline (gi·ªõi h·∫°n ·ªü 90%)
                    const dryChanceOffline = Math.min(0.9, 0.0001 * missedTicks); // ƒêi·ªÅu ch·ªânh 0.0001 n·∫øu c·∫ßn
                    if (Math.random() < dryChanceOffline) {
                        plot.isDry = true; becameDryOffline = true; plotChangedThisSim = true;
                        // console.log(`(Sim Offline) Plot ${i} ƒë∆∞·ª£c t√≠nh l√† ƒë√£ b·ªã kh√¥ do n·∫Øng.`);
                    }
                }
                // N·∫øu th·ªùi ti·∫øt cu·ªëi l√† m∆∞a V√Ä √¥ ƒëang kh√¥ -> h·∫øt kh√¥
                const rainyWeatherIdsForDrynessSim = ['rainy', 'thunderstorm', 'rainy_sunny'];
                if (rainyWeatherIdsForDrynessSim.includes(finalSimWeatherObject.id) && plot.isDry) {
                    plot.isDry = false; plotChangedThisSim = true;
                    // console.log(`(Sim Offline) Plot ${i} ƒë∆∞·ª£c t√≠nh l√† ƒë√£ h·∫øt kh√¥ do m∆∞a.`);
                }

                // --- M√¥ ph·ªèng c√¢y tr·ªìng (ch·ªâ ch·∫°y n·∫øu kh√¥ng b·ªã tornado) ---
                if (plot.seedId && plot.plantTime) {
                    const seedInfo = ITEM_DATA[plot.seedId];
                    if (!seedInfo) continue; // B·ªè qua n·∫øu d·ªØ li·ªáu h·∫°t gi·ªëng l·ªói

                    // T√≠nh to√°n ti·∫øn tr√¨nh v√† tr·∫°ng th√°i tr∆∞·ªüng th√†nh CU·ªêI C√ôNG
                    const effectiveGrowthTimeSec = getEffectiveGrowthTime(plot);
                    const totalGrowthTimeMs = effectiveGrowthTimeSec * 1000;
                    const finalElapsedTime = endTime - plot.plantTime;
                    const finalGrowthProgress = totalGrowthTimeMs > 0 ? Math.min(1, finalElapsedTime / totalGrowthTimeMs) : 1;
                    const isMatureEstimate = finalGrowthProgress >= 1.0 - 0.0001;

                    // M√¥ ph·ªèng s√¢u xu·∫•t hi·ªán
                    let pestAppearedOffline = false;
                    const noPestWeatherIdsSim = ['sunny', 'cloudy', 'windy', 'lightning']; // Th·ªùi ti·∫øt kh√¥ng c√≥ s√¢u
                    // Ch·ªâ xu·∫•t hi·ªán n·∫øu th·ªùi ti·∫øt cu·ªëi kh√¥ng n·∫±m trong danh s√°ch noPest, c√¢y c√≤n s·ªëng, ch∆∞a c√≥ s√¢u
                    if (!noPestWeatherIdsSim.includes(finalSimWeatherObject.id) && plot.health > 0 && !plot.hasPest) {
                        // X√°c su·∫•t b·ªã s√¢u tƒÉng theo th·ªùi gian offline
                        if (Math.random() < p_get_pest_total) {
                            plot.hasPest = true; pestAppearedOffline = true; plotChangedThisSim = true;
                            console.log(`(Sim Offline) S√¢u ƒë∆∞·ª£c t√≠nh l√† ƒë√£ xu·∫•t hi·ªán tr√™n √¥ ${i} (${seedInfo.name}).`);
                            logAction('pest_appear_offline', i, `S√¢u xu·∫•t hi·ªán tr√™n ${seedInfo.name} (offline).`, 'üêõ<0xF0><0x9F><0xAA><0xB2>', seedInfo.id);
                        }
                    }

                    // M√¥ ph·ªèng s√°t th∆∞∆°ng s√¢u (n·∫øu c√¢y ƒëang c√≥ s√¢u)
                    if (plot.hasPest && plot.health > 0) {
                        // S·ªë tick b·ªã s√¢u t·∫•n c√¥ng (∆∞·ªõc t√≠nh b·∫±ng 1/2 n·∫øu s√¢u v·ª´a xu·∫•t hi·ªán offline)
                        let damageTicks = pestAppearedOffline ? Math.floor(missedTicks / 2) : missedTicks;
                        // S√°t th∆∞∆°ng m·ªói tick (gi·∫£m n·∫øu c√¢y tr∆∞·ªüng th√†nh)
                        let damagePerTickSim = PEST_DAMAGE_PER_TICK * (isMatureEstimate ? PEST_DAMAGE_MATURE_REDUCTION_FACTOR : 1);
                        let totalDamageSim = damagePerTickSim * damageTicks; // T·ªïng s√°t th∆∞∆°ng ∆∞·ªõc t√≠nh
                        const oldHealth = plot.health;

                        // Gi·∫£m m√°u, nh∆∞ng kh√¥ng ƒë·ªÉ ch·∫øt ho√†n to√†n (tr√°nh tr∆∞·ªùng h·ª£p ch·∫øt h√†ng lo·∫°t qu√° d·ªÖ)
                        // ƒê·∫∑t m√°u v·ªÅ m·ªôt m·ª©c ng·∫´u nhi√™n th·∫•p n·∫øu s√°t th∆∞∆°ng l√†m ch·∫øt
                        const potentialHpAfterDamage = plot.health - totalDamageSim;
                        if (potentialHpAfterDamage <= 0) {
                            // M√°u ng·∫´u nhi√™n t·ª´ 1 ƒë·∫øn 20
                            plot.health = 1 + Math.random() * 19;
                            console.warn(`(Sim Offline) √î ${i} (${seedInfo.name}) m√°u r·∫•t th·∫•p do s√¢u (∆∞·ªõc t√≠nh ${plot.health.toFixed(0)} HP).`);
                        } else {
                            plot.health = potentialHpAfterDamage;
                        }
                        // ƒê·∫£m b·∫£o m√°u kh√¥ng v∆∞·ª£t qu√° gi·ªõi h·∫°n
                        plot.health = Math.max(1, Math.min(INITIAL_PLANT_HEALTH, plot.health));

                        if (plot.health !== oldHealth) { plotChangedThisSim = true; }
                    }

                    // M√¥ ph·ªèng h·ªìi m√°u (n·∫øu kh√¥ng s√¢u, ch∆∞a max m√°u, kh√¥ng kh√¥)
                    if (!plot.hasPest && plot.health > 0 && plot.health < INITIAL_PLANT_HEALTH && !plot.isDry) {
                        const totalRegen = HEALTH_REGEN_PER_TICK * missedTicks;
                        const oldHealth = plot.health;
                        plot.health = Math.min(INITIAL_PLANT_HEALTH, plot.health + totalRegen);
                        if (plot.health !== oldHealth) plotChangedThisSim = true;
                    }

                    // M√¥ ph·ªèng gi·∫£m m√°u/ch·∫øt do KH√î H·∫†N (n·∫øu ƒëang kh√¥)
                    if (plot.isDry && plot.health > 0) {
                        let changedByDrynessSim = false;
                        const healthDrainSim = DRY_HEALTH_DRAIN_PER_TICK * missedTicks;
                        const oldHealthSim = plot.health;
                        plot.health = Math.max(0, plot.health - healthDrainSim); // Gi·∫£m m√°u do kh√¥
                        if (plot.health === 0 && oldHealthSim > 0) { // N·∫øu ch·∫øt do kh√¥
                            plot.causeOfDeath = 'dryness'; // ƒê·∫∑t nguy√™n nh√¢n ch·∫øt
                            plot.hasPest = false;         // S√¢u bi·∫øn m·∫•t
                            plot.isDry = false;           // H·∫øt kh√¥ khi ch·∫øt
                            console.warn(`(Sim Offline) √î ${i} (${seedInfo.name}) ƒë∆∞·ª£c t√≠nh l√† CH·∫æT v√¨ kh√¥ h·∫°n.`);
                            logAction('plant_death', i, `${seedInfo.name} √¥ ${i+1} ch·∫øt do kh√¥ h·∫°n (offline).`, 'üíÄüèúÔ∏è', seedInfo.id);
                            changedByDrynessSim = true;
                        } else if (plot.health !== oldHealthSim) { // N·∫øu ch·ªâ gi·∫£m m√°u
                            changedByDrynessSim = true;
                        }
                        if(changedByDrynessSim) plotChangedThisSim = true; // ƒê√°nh d·∫•u plot thay ƒë·ªïi
                    }

                    // M√¥ ph·ªèng gi·∫£m ƒë·ªô ph√¨ nhi√™u do c√¢y l·ªõn (ch·ªâ khi c√¢y ƒëang l·ªõn)
                    if (!isMatureEstimate && plot.health > 0 && seedInfo.fertilityCost > 0 && seedInfo.growthTime > 0 && plot.fertility > 0) {
                        const baseGrowthTime = seedInfo.growthTime;
                        // T√≠nh l∆∞·ª£ng ph√¨ gi·∫£m m·ªói tick khi c√¢y l·ªõn
                        const fertilityDecreasePerTick = (seedInfo.fertilityCost * BASE_FERTILITY) / baseGrowthTime;
                        const totalFertilityDecrease = fertilityDecreasePerTick * missedTicks; // T·ªïng l∆∞·ª£ng gi·∫£m
                        if (totalFertilityDecrease > 0) {
                            const oldFertility = plot.fertility;
                            plot.fertility = Math.max(0, plot.fertility - totalFertilityDecrease); // Gi·∫£m ƒë·ªô ph√¨
                            if (plot.fertility !== oldFertility) plotChangedThisSim = true; // ƒê√°nh d·∫•u thay ƒë·ªïi
                            // X·ª≠ l√Ω n·∫øu ƒë·∫•t th√†nh c·∫±n do c√¢y l·ªõn
                            if (oldFertility > 0 && plot.fertility <= 0) {
                                plot.barrenHarvestPenaltyFactor = 1.0; // Reset penalty
                                console.log(`(Sim Offline) Plot ${i} became barren due to plant growth.`);
                            }
                        }
                    }

                    // Ki·ªÉm tra xem c√¢y c√≥ tr∆∞·ªüng th√†nh trong th·ªùi gian offline kh√¥ng
                    // Ch·ªâ ki·ªÉm tra n·∫øu c√¢y c√≤n s·ªëng v√† kh√¥ng c√≥ s√¢u
                    if (plot.health > 0 && !plot.hasPest) {
                        const stageInfoBefore = getPlantStageInfo(plot, startTime); // Tr·∫°ng th√°i tr∆∞·ªõc offline
                        // N·∫øu tr∆∞·ªõc ƒë√≥ ch∆∞a tr∆∞·ªüng th√†nh V√Ä b√¢y gi·ªù ƒë√£ tr∆∞·ªüng th√†nh
                        if (stageInfoBefore && !stageInfoBefore.isMature && isMatureEstimate) {
                            console.log(`(Sim Offline) √î ${plot.id} (${seedInfo.name}) ƒë∆∞·ª£c t√≠nh l√† ƒë√£ tr∆∞·ªüng th√†nh.`);
                            plotChangedThisSim = true; // ƒê√°nh d·∫•u thay ƒë·ªïi
                        }
                    }

                } else if (plot.isDry && !plot.seedId && plot.fertility > 0) { // ƒê·∫•t tr·ªëng b·ªã kh√¥
                    const fertilityDrainSim = DRY_FERTILITY_DRAIN_PER_TICK * missedTicks; // L∆∞·ª£ng ph√¨ m·∫•t
                    const oldFertilitySim = plot.fertility;
                    plot.fertility = Math.max(0, plot.fertility - fertilityDrainSim); // Gi·∫£m ƒë·ªô ph√¨
                    if (plot.fertility !== oldFertilitySim) { // N·∫øu c√≥ thay ƒë·ªïi
                        plotChangedThisSim = true;
                        // N·∫øu ƒë·∫•t th√†nh c·∫±n do kh√¥ h·∫°n
                        if(plot.fertility === 0 && oldFertilitySim > 0) {
                            plot.barrenHarvestPenaltyFactor = 1.0; // Reset penalty
                            console.log(`(Sim Offline) Plot ${i} (tr·ªëng) tr·ªü n√™n c·∫±n c·ªói do kh√¥ h·∫°n.`);
                        }
                    }
                }

                // --- C·∫≠p nh·∫≠t c·ªù tr·∫°ng th√°i chung ---
                if(plotChangedThisSim) plotStateChanged = true; // C·∫≠p nh·∫≠t c·ªù chung n·∫øu plot n√†y thay ƒë·ªïi

            } // K·∫øt th√∫c v√≤ng l·∫∑p for c√°c √¥ ƒë·∫•t

            // --- M√¥ ph·ªèng TƒÉng Ph√¨ Nhi√™u Do Th·ªùi Ti·∫øt M∆∞a ---
            const fertilityBoostingWeatherIdsSim = ['rainy', 'thunderstorm', 'rainy_sunny'];
            // Ch·ªâ tƒÉng n·∫øu th·ªùi ti·∫øt *cu·ªëi c√πng* l√† m∆∞a
            if (fertilityBoostingWeatherIdsSim.includes(finalSimWeatherObject.id)) {
                // Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa chu k·ª≥ m∆∞a cu·ªëi c√πng trong kho·∫£ng offline
                const lastRainStartTime = simWeatherStartTime > startTime ? simWeatherStartTime : startTime;
                const rainDurationMs = endTime - lastRainStartTime; // Th·ªùi gian m∆∞a trong kho·∫£ng offline
                const numberOfRainBoosts = Math.floor(rainDurationMs / 15000); // S·ªë l·∫ßn boost (1% m·ªói 15s)
                if (numberOfRainBoosts > 0) {
                    console.log(`(Sim Offline) Applying ${numberOfRainBoosts} fertility boosts (Weather: ${finalSimWeatherObject.id}).`);
                    let rainBoostChangedStateSim = false; // C·ªù xem c√≥ thay ƒë·ªïi kh√¥ng
                    for (let i = 0; i < gameState.maxUnlockedPlots; i++) {
                         let plot = gameState.plots[i];
                         // B·ªè qua n·∫øu √¥ ƒë√£ b·ªã h·ªßy di·ªát b·ªüi tornado offline ho·∫∑c c√≥ rod
                         let wasDestroyedByOfflineTornado = false;
                         if(hitByOfflineTornado && plot && plot.causeOfDeath === 'tornado' && plot.health <= 0) {
                            wasDestroyedByOfflineTornado = true;
                         }
                         if(wasDestroyedByOfflineTornado || isPlotWithRod(i)) continue;

                         // Ch·ªâ tƒÉng n·∫øu ƒë·∫•t ch∆∞a max ph√¨ nhi√™u
                         if (plot && plot.fertility < BASE_FERTILITY) {
                            const oldFertilitySim = plot.fertility;
                            plot.fertility = Math.min(BASE_FERTILITY, plot.fertility + numberOfRainBoosts * 1); // TƒÉng 1% m·ªói l·∫ßn boost
                            if (plot.fertility !== oldFertilitySim) {
                                rainBoostChangedStateSim = true; // ƒê√°nh d·∫•u c√≥ thay ƒë·ªïi
                                // Reset penalty n·∫øu ƒë·∫•t h·∫øt c·∫±n nh·ªù m∆∞a
                                if (oldFertilitySim <= 0 && plot.fertility > 0) {
                                    plot.barrenHarvestPenaltyFactor = 1.0;
                                }
                            }
                         }
                    }
                    if (rainBoostChangedStateSim) { plotStateChanged = true; } // C·∫≠p nh·∫≠t c·ªù chung
                }
            }

            // C·∫≠p nh·∫≠t stateChanged cu·ªëi c√πng
            stateChanged = weatherChangedDuringSim || plotStateChanged;
            console.log(`M√¥ ph·ªèng offline ho√†n t·∫•t. Tr·∫°ng th√°i ${stateChanged ? 'ƒê√É' : 'KH√îNG'} thay ƒë·ªïi.`);
            return stateChanged;
        } // --- K·∫øt th√∫c h√†m simulateOfflineProgress ---


        /** Hi·ªÉn th·ªã m·ªôt tin nh·∫Øn t·∫°m th·ªùi */
        function showMessage(text, type = 'info', duration = MESSAGE_DISPLAY_TIME, position = 'bottom') {
    if (messageTimeout) clearTimeout(messageTimeout);
    messageArea.textContent = text;
    const isMultiline = text.includes('\n');
    // Th√™m class v·ªã tr√≠ v√†o className
    messageArea.className = `show ${type} ${isMultiline ? 'multiline' : ''} position-${position}`;

    // ƒê·∫∑t l·∫°i v·ªã tr√≠ top/bottom r√µ r√†ng ƒë·ªÉ tr√°nh xung ƒë·ªôt
    if (position === 'top') {
        messageArea.style.bottom = 'auto'; // X√≥a thu·ªôc t√≠nh bottom
        messageArea.style.top = '15px';   // ƒê·∫∑t v·ªã tr√≠ ban ƒë·∫ßu (·∫©n) cho top
    } else {
        messageArea.style.top = 'auto';    // X√≥a thu·ªôc t√≠nh top
        messageArea.style.bottom = '15px'; // ƒê·∫∑t v·ªã tr√≠ ban ƒë·∫ßu (·∫©n) cho bottom
    }

    // Bu·ªôc tr√¨nh duy·ªát t√≠nh to√°n l·∫°i layout tr∆∞·ªõc khi th√™m class 'show' ƒë·ªÉ animation ho·∫°t ƒë·ªông
    void messageArea.offsetWidth;

    // Th√™m class 'show' ƒë·ªÉ k√≠ch ho·∫°t animation v√† hi·ªÉn th·ªã
    messageArea.classList.add('show'); // Class 'show' s·∫Ω ƒëi·ªÅu khi·ªÉn v·ªã tr√≠ cu·ªëi c√πng v√† opacity

    messageTimeout = setTimeout(() => {
        messageArea.classList.remove('show');
        // Delay nh·ªè tr∆∞·ªõc khi x√≥a class ƒë·ªÉ ho√†n t·∫•t transition
        setTimeout(() => {
            if (!messageArea.classList.contains('show')) {
                messageArea.className = ''; // X√≥a h·∫øt class
                // Reset style ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng l·∫ßn hi·ªÉn th·ªã sau
                messageArea.style.top = '';
                messageArea.style.bottom = '';
                messageArea.style.transform = '';
            }
        }, 500); // Th·ªùi gian n√†y n√™n kh·ªõp v·ªõi transition duration
    }, duration);
}

        /** M·ªü m·ªôt h·ªôp tho·∫°i modal b·∫±ng ID */
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) { modal.style.display = 'block';
                // T·ª± ƒë·ªông focus v√†o ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n c√≥ th·ªÉ focus trong modal
                const focusable = modal.querySelector('button:not(:disabled), [href], input:not(:disabled), select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]), .close-button');
                if (focusable) { setTimeout(() => focusable.focus(), 50); } // Delay nh·ªè ƒë·ªÉ ƒë·∫£m b·∫£o modal ƒë√£ hi·ªán
            } else { console.error(`Modal ID "${modalId}" kh√¥ng t·ªìn t·∫°i.`); }
        }

        /** ƒê√≥ng m·ªôt h·ªôp tho·∫°i modal b·∫±ng ID */
        function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal && modal.style.display === 'block') {
         modal.style.display = 'none';
         // N·∫øu ƒë√≥ng popup H·∫°t Ng·ªçc Tr·ªùi ban ƒë·∫ßu qua h√†m n√†y (kh√¥ng n√™n, nh∆∞ng ƒë·ªÉ ph√≤ng ng·ª´a)
         if (modalId === 'hat-ngoc-troi-popup') {
             // Kh√¥ng n√™n t·ª± ƒë·ªông m·ªü popup th∆∞·ªüng t·ª´ ƒë√¢y, logic ch√≠nh l√† ·ªü closeHatNgocTroiPopup()
             console.warn("Popup H·∫°t Ng·ªçc Tr·ªùi ban ƒë·∫ßu b·ªã ƒë√≥ng qua closeModal(), c√≥ th·ªÉ kh√¥ng nh·∫≠n th∆∞·ªüng.");
             // C√≥ th·ªÉ g·ªçi startHatNgocTroiTimer() ·ªü ƒë√¢y ƒë·ªÉ ƒë·∫£m b·∫£o timer ch·∫°y l·∫°i n·∫øu c√≥ l·ªói
             startHatNgocTroiTimer();
         }
         // N·∫øu ƒë√≥ng popup TH∆Ø·ªûNG H·∫°t Ng·ªçc Tr·ªùi qua h√†m n√†y (v√≠ d·ª•: l·ªói click n·ªÅn kh√¥ng ch·∫°y ƒë√∫ng handler)
         else if (modalId === 'hat-ngoc-troi-reward-popup') {
             console.warn("Popup th∆∞·ªüng H·∫°t Ng·ªçc Tr·ªùi b·ªã ƒë√≥ng qua closeModal(). ƒê·∫£m b·∫£o v·∫≠t ph·∫©m ƒë√£ ƒë∆∞·ª£c trao.");
             // Kh√¥ng n√™n t·ª± ƒë·ªông trao th∆∞·ªüng t·ª´ ƒë√¢y, n√∫t x√°c nh·∫≠n l√† logic ch√≠nh.
             // N√™n kh·ªüi ƒë·ªông l·∫°i timer ·ªü ƒë√¢y ƒë·ªÉ kh√¥ng b·ªã k·∫πt
             startHatNgocTroiTimer();
         }
    }
}
        /** ƒê√≥ng t·∫•t c·∫£ c√°c modal ƒëang m·ªü */
        function closeAllModals() {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => closeModal(modal.id));
            // Reset c√°c bi·∫øn tr·∫°ng th√°i li√™n quan ƒë·∫øn modal
            currentPlantingPlotId = null;
            currentActionPlotId = null;
        }


        /** X·ª≠ l√Ω click b√™n ngo√†i n·ªôi dung modal ƒë·ªÉ ƒë√≥ng */
      function handleModalBackgroundClick(event) {
    // ƒê√≥ng popup menu n·∫øu click n·ªÅn c·ªßa n√≥
    if (event.target === menuPopup) { closeMenuPopup(); }
    // ƒê√≥ng popup √¥ kh√≥a n·∫øu click n·ªÅn c·ªßa n√≥
    else if (event.target === lockedPlotPopup) { closeLockedPlotPopup(); }
    // ƒê√≥ng popup x√°c nh·∫≠n b√°n h·∫øt n·∫øu click n·ªÅn
    else if (event.target === confirmSellAllModal) { closeConfirmSellAllModal(); }
    // <<< TH√äM: ƒê√≥ng popup H·∫°t Ng·ªçc Tr·ªùi n·∫øu click n·ªÅn >>>
    else if (event.target === hatNgocTroiPopup) { closeHatNgocTroiPopup(); }
    // ƒê√≥ng c√°c modal kh√°c n·∫øu click n·ªÅn c·ªßa ch√∫ng
    else if (event.target.classList.contains('modal') && event.target !== menuPopup && event.target !== lockedPlotPopup && event.target !== confirmSellAllModal && event.target !== hatNgocTroiPopup) {
        const modalId = event.target.id;
        closeModal(modalId);
        if (modalId === 'seed-selection-modal') currentPlantingPlotId = null;
        if (modalId === 'fertilizer-selection-modal' || modalId === 'plant-action-modal' || modalId === 'empty-plot-action-modal') currentActionPlotId = null;
    }
}

        /** C·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c n√∫t mua trong c·ª≠a h√†ng d·ª±a tr√™n ti·ªÅn hi·ªán c√≥ */
         function updateShopButtons() {
    // Ki·ªÉm tra c√°c ph·∫ßn t·ª≠ list c√≥ t·ªìn t·∫°i kh√¥ng
    if (!shopSeedList || !shopToolList) {
        console.warn("updateShopButtons: Kh√¥ng t√¨m th·∫•y shopSeedList ho·∫∑c shopToolList.");
        return;
    }

    const currentCurrency = gameState.currency;
    const currentInventoryCapacity = gameState.maxInventoryCapacity; // L·∫•y s·ª©c ch·ª©a hi·ªán t·∫°i

    // --- C·∫≠p nh·∫≠t n√∫t mua h·∫°t gi·ªëng v√† c√¥ng c·ª• th√¥ng th∆∞·ªùng ---
    // S·ª≠ d·ª•ng h√†m updateSeedTotalCost ƒë√£ c√≥ v√¨ n√≥ ki·ªÉm tra ti·ªÅn v√† s·ªë l∆∞·ª£ng
    shopSeedList.querySelectorAll('.item-card').forEach(card => {
        const itemId = card.dataset.itemId;
        const item = ITEM_DATA[itemId];
        if (item && (item.type === 'seed')) { // Ch·ªâ g·ªçi cho seed ·ªü list n√†y
            try {
                updateSeedTotalCost(itemId, card);
            } catch (e) {
                console.error(`L·ªói khi c·∫≠p nh·∫≠t n√∫t mua h·∫°t gi·ªëng ${itemId}:`, e);
            }
        }
    });

    shopToolList.querySelectorAll('.item-card').forEach(card => {
        const itemId = card.dataset.itemId;
        const item = ITEM_DATA[itemId];
        if (!item) return; // B·ªè qua n·∫øu kh√¥ng t√¨m th·∫•y item

        // X·ª≠ l√Ω n√∫t cho C√îNG C·ª§ (c√≥ input s·ªë l∆∞·ª£ng)
        if (item.type === 'tool') {
            try {
                updateSeedTotalCost(itemId, card); // D√πng h√†m chung ƒë·ªÉ c·∫≠p nh·∫≠t n√∫t mua tool
            } catch (e) {
                console.error(`L·ªói khi c·∫≠p nh·∫≠t n√∫t mua c√¥ng c·ª• ${itemId}:`, e);
            }
        }
        // X·ª≠ l√Ω n√∫t cho N√ÇNG C·∫§P KHO ƒê·ªí (KH√îNG c√≥ input s·ªë l∆∞·ª£ng)
        else if (item.type === 'upgrade') {
            const buyButton = card.querySelector('.buy-upgrade-button'); // N√∫t ri√™ng cho n√¢ng c·∫•p
            if (!buyButton) {
                console.warn(`Kh√¥ng t√¨m th·∫•y n√∫t '.buy-upgrade-button' cho n√¢ng c·∫•p ${itemId}`);
                return; // B·ªè qua n·∫øu kh√¥ng t√¨m th·∫•y n√∫t
            }

            const cost = item.price || 0;
            const upgradeInfo = item.upgradeCapacity; // { from: number, to: number }

            // --- Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán ƒë·ªÉ b·∫≠t/t·∫Øt n√∫t MUA N√ÇNG C·∫§P ---
            let disabled = false;
            let buttonText = `Mua (${cost}üí∞)`; // VƒÉn b·∫£n m·∫∑c ƒë·ªãnh
            let buttonTitle = `N√¢ng c·∫•p kho l√™n ${upgradeInfo?.to || '?'} ch·ªó (T·ªën ${cost}üí∞)`;

            // 1. Ki·ªÉm tra th√¥ng tin n√¢ng c·∫•p c√≥ h·ª£p l·ªá kh√¥ng
            if (!upgradeInfo || typeof upgradeInfo.from !== 'number' || typeof upgradeInfo.to !== 'number') {
                disabled = true;
                buttonText = "L·ªói d·ªØ li·ªáu";
                buttonTitle = "V·∫≠t ph·∫©m n√¢ng c·∫•p n√†y b·ªã l·ªói d·ªØ li·ªáu.";
                console.error(`L·ªói d·ªØ li·ªáu n√¢ng c·∫•p cho v·∫≠t ph·∫©m: ${itemId}`);
            }
            // 2. Ki·ªÉm tra xem ƒë√£ s·ªü h·ªØu n√¢ng c·∫•p n√†y ho·∫∑c cao h∆°n ch∆∞a
            else if (currentInventoryCapacity >= upgradeInfo.to) {
                disabled = true;
                buttonText = "ƒê√£ s·ªü h·ªØu";
                buttonTitle = `B·∫°n ƒë√£ c√≥ kho ${currentInventoryCapacity} ch·ªó (ƒë√£ n√¢ng c·∫•p ho·∫∑c cao h∆°n).`;
            }
            // 3. Ki·ªÉm tra xem c√≥ ƒë√°p ·ª©ng y√™u c·∫ßu s·ª©c ch·ª©a t·ªëi thi·ªÉu kh√¥ng
            else if (currentInventoryCapacity !== upgradeInfo.from) {
                disabled = true;
                buttonText = `Y√™u c·∫ßu kho ${upgradeInfo.from}`;
                buttonTitle = `C·∫ßn c√≥ kho ${upgradeInfo.from} ch·ªó ƒë·ªÉ mua n√¢ng c·∫•p n√†y. Kho hi·ªán t·∫°i: ${currentInventoryCapacity}.`;
            }
            // 4. Ki·ªÉm tra xem c√≥ ƒë·ªß ti·ªÅn kh√¥ng (ch·ªâ ki·ªÉm tra n·∫øu c√°c ƒëi·ªÅu ki·ªán tr√™n ƒë√£ pass)
            else if (currentCurrency < cost) {
                disabled = true;
                buttonText = `Thi·∫øu ${cost - currentCurrency}üí∞`;
                buttonTitle = `Kh√¥ng ƒë·ªß ti·ªÅn. C·∫ßn ${cost}üí∞, b·∫°n c√≥ ${currentCurrency}üí∞.`;
            }
            // 5. N·∫øu t·∫•t c·∫£ ƒëi·ªÅu ki·ªán OK -> N√∫t ƒë∆∞·ª£c b·∫≠t
            else {
                disabled = false;
                // buttonText v√† buttonTitle gi·ªØ nguy√™n gi√° tr·ªã m·∫∑c ƒë·ªãnh
            }

            // --- C·∫≠p nh·∫≠t tr·∫°ng th√°i v√† n·ªôi dung n√∫t ---
            buyButton.disabled = disabled;
            buyButton.textContent = buttonText;
            buyButton.title = buttonTitle;
        }
    });
    // console.log("Shop buttons updated."); // B·ªè comment n·∫øu c·∫ßn debug
}

        /** ƒê·ªãnh d·∫°ng mili gi√¢y th√†nh chu·ªói th·ªùi gian ƒë·ªçc ƒë∆∞·ª£c */
        function formatTime(ms, short = false) {
            if (isNaN(ms) || ms <= 0) return short ? "0s" : "0 gi√¢y";
            const totalSeconds = Math.max(0, Math.round(ms / 1000));
            const d = Math.floor(totalSeconds / 86400); const h = Math.floor((totalSeconds % 86400) / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60); const s = totalSeconds % 60;
            const dStr = short ? "ng" : " ng√†y"; const hStr = short ? "g" : " gi·ªù";
            const mStr = short ? "ph" : " ph√∫t"; const sStr = short ? "s" : " gi√¢y"; const sep = short ? "" : " ";
            let parts = [];
            if (d > 0) parts.push(`${d}${dStr}`); if (h > 0) parts.push(`${h}${hStr}`);
            if (m > 0) parts.push(`${m}${mStr}`);
            // Hi·ªÉn th·ªã gi√¢y n·∫øu l√† ƒë·ªãnh d·∫°ng ng·∫Øn, ho·∫∑c n·∫øu t·ªïng th·ªùi gian < 1 ph√∫t, ho·∫∑c n·∫øu kh√¥ng c√≥ ph·∫ßn n√†o kh√°c
            if (s > 0 || parts.length === 0 || totalSeconds < 60 || short) {
                // Tr√°nh hi·ªÉn th·ªã "X ph√∫t 0 gi√¢y" ·ªü ƒë·ªãnh d·∫°ng d√†i
                if (!(!short && parts.length > 0 && s === 0 && totalSeconds >= 60)) {
                    parts.push(`${s}${sStr}`);
                }
            }
            // Gi·ªõi h·∫°n ·ªü 2 ph·∫ßn ch√≠nh cho ƒë·ªãnh d·∫°ng d√†i
            if (!short && parts.length > 2) parts = parts.slice(0, 2);
            return parts.length > 0 ? parts.join(sep) : (short ? "0s" : "0 gi√¢y");
        }


        // --- X·ª≠ L√Ω Tab ---
        // =================

        /** Chuy·ªÉn tab c·ª≠a h√†ng */
        function switchShopTab(tabToShow) {
            if (!shopTabsContainer || !shopSeedList || !shopToolList) return;
            shopTabsContainer.querySelectorAll('.shop-tab-button').forEach(btn => { btn.classList.toggle('active', btn.dataset.tab === tabToShow); });
            const seedsActive = tabToShow === 'seeds';
            shopSeedList.classList.toggle('active-list', seedsActive); shopToolList.classList.toggle('active-list', !seedsActive);
            // D√πng display grid/none ƒë·ªÉ ƒë·∫£m b·∫£o ·∫©n/hi·ªán ƒë√∫ng c√°ch
            shopSeedList.style.display = seedsActive ? 'grid' : 'none';
            shopToolList.style.display = !seedsActive ? 'grid' : 'none';
        }
        /** X·ª≠ l√Ω click tab c·ª≠a h√†ng */
        function handleShopTabClick(event) {
            const tabButton = event.target.closest('.shop-tab-button[data-tab]');
            if (tabButton) { const selectedTab = tabButton.dataset.tab; if (selectedTab) switchShopTab(selectedTab); }
        }

        /** Chuy·ªÉn tab kho ƒë·ªì */
        function switchInventoryTab(tabToShow) {
             if (!inventoryTabsContainer || !inventoryHarvestedList || !inventoryPurchasedList) return;
             inventoryTabsContainer.querySelectorAll('.inventory-tab-button').forEach(btn => {
                 btn.classList.toggle('active', btn.dataset.tab === tabToShow);
             });
             const harvestedActive = tabToShow === 'harvested';
             inventoryHarvestedList.classList.toggle('active-list', harvestedActive);
             inventoryPurchasedList.classList.toggle('active-list', !harvestedActive);
             // Ki·ªÉm tra xem list c√≥ r·ªóng kh√¥ng tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh display
             const harvestedHasItems = inventoryHarvestedList.querySelector('.item-card');
             const purchasedHasItems = inventoryPurchasedList.querySelector('.item-card');
             inventoryHarvestedList.style.display = (harvestedActive && harvestedHasItems) ? 'grid' : 'none';
             inventoryPurchasedList.style.display = (!harvestedActive && purchasedHasItems) ? 'grid' : 'none';
             // Hi·ªÉn th·ªã th√¥ng b√°o tr·ªëng n·∫øu tab active kh√¥ng c√≥ item
             inventoryHarvestedEmptyMessage.style.display = (harvestedActive && !harvestedHasItems) ? 'block' : 'none';
             inventoryPurchasedEmptyMessage.style.display = (!harvestedActive && !purchasedHasItems) ? 'block' : 'none';
        }
        /** X·ª≠ l√Ω click tab kho ƒë·ªì */
        function handleInventoryTabClick(event) {
             const tabButton = event.target.closest('.inventory-tab-button[data-tab]');
             if (tabButton) {
                 const selectedTab = tabButton.dataset.tab;
                 if (selectedTab) switchInventoryTab(selectedTab);
             }
        }


        // --- C√°c H√†m Tooltip ---
        // =======================
        function showTooltip(text, targetElement) {
            if (!text || !targetElement) return; clearTimeout(tooltipTimeout); clearTimeout(tooltipHideTimeout);
            tooltipTimeout = setTimeout(() => { tooltipElement.innerHTML = text.replace(/\n/g, '<br>'); currentTooltipTarget = targetElement; positionTooltip(); tooltipElement.classList.add('visible'); }, TOOLTIP_DELAY);
        }
        function hideTooltip(delay = 0) {
             clearTimeout(tooltipTimeout); clearTimeout(tooltipHideTimeout);
             tooltipHideTimeout = setTimeout(() => { tooltipElement.classList.remove('visible'); currentTooltipTarget = null; setTimeout(() => { if (!tooltipElement.classList.contains('visible')) { tooltipElement.style.left = '-9999px'; tooltipElement.style.top = '-9999px'; } }, 200); }, delay);
        }
        function positionTooltip() {
            if (!tooltipElement.classList.contains('visible') || !currentTooltipTarget) return;
            const targetRect = currentTooltipTarget.getBoundingClientRect();
            // T·∫°m ·∫©n ƒë·ªÉ l·∫•y k√≠ch th∆∞·ªõc ƒë√∫ng
            tooltipElement.style.visibility = 'hidden';
            tooltipElement.style.display = 'block';
            const tooltipRect = tooltipElement.getBoundingClientRect();
            // Hi·ªán l·∫°i
            tooltipElement.style.visibility = '';
            tooltipElement.style.display = '';

            const vpWidth = window.innerWidth; const vpHeight = window.innerHeight; const offset = 8;
            let x = targetRect.left + targetRect.width / 2 - tooltipRect.width / 2;
            let y = targetRect.top - tooltipRect.height - offset; // M·∫∑c ƒë·ªãnh ·ªü tr√™n

            // N·∫øu kh√¥ng ƒë·ªß ch·ªó ·ªü tr√™n, th·ª≠ ·ªü d∆∞·ªõi
            if (y < offset) {
                y = targetRect.bottom + offset;
                // N·∫øu ·ªü d∆∞·ªõi c≈©ng kh√¥ng ƒë·ªß, ƒë·∫∑t ·ªü v·ªã tr√≠ cao nh·∫•t c√≥ th·ªÉ trong viewport
                if (y + tooltipRect.height > vpHeight - offset) {
                    y = vpHeight - tooltipRect.height - offset;
                }
            }
            // ƒê·∫£m b·∫£o kh√¥ng tr√†n tr√°i/ph·∫£i
            if (x < offset) { x = offset; }
            else if (x + tooltipRect.width > vpWidth - offset) { x = vpWidth - tooltipRect.width - offset; }

            tooltipElement.style.left = `${Math.round(x)}px`;
            tooltipElement.style.top = `${Math.round(y)}px`;
        }
        /** X·ª≠ l√Ω hover √¥ v∆∞·ªùn -> hi·ªÉn th·ªã tooltip */
        function handlePlotMouseover(event) {
            const plotElement = event.target.closest('.plot');
            if (!plotElement) return;
            const plotId = parseInt(plotElement.dataset.plotId);
            if (isNaN(plotId)) return;

            let tooltipText = '';
            const isLocked = plotElement.classList.contains('locked');

            if (isLocked) {
                 const cost = calculatePlotCost(plotId);
                 tooltipText = `üîí √î ƒê·∫•t B·ªã Kh√≥a\nClick ƒë·ªÉ mua (Gi√°: ${cost}üí∞)`;
            } else if (isPlotWithRod(plotId)) { // N·∫øu l√† √¥ c√≥ c·ªôt thu l√¥i
                 const rodData = getRodData(plotId);
                 if (rodData) {
                     tooltipText = `‚ö° C·ªôt Thu L√¥i (√î ${plotId + 1})\nS·ª©c kh·ªèe: ${rodData.health}/${LIGHTNING_ROD_MAX_HEALTH}`;
                     if (rodData.health <= 0) tooltipText += ` (H·ªèng!)`;
                     tooltipText += `\nClick ƒë·ªÉ xem chi ti·∫øt.`;
                 } else {
                     tooltipText = `L·ªói: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu c·ªôt thu l√¥i √¥ ${plotId + 1}.`;
                 }
            } else { // √î b√¨nh th∆∞·ªùng (kh√¥ng kh√≥a, kh√¥ng rod)
                 const plotData = gameState.plots[plotId];
                 if (!plotData) return; // Th√™m ki·ªÉm tra plotData t·ªìn t·∫°i

                 const now = Date.now();
                 const stageInfo = getPlantStageInfo(plotData, now);
                 const seedInfo = plotData.seedId ? ITEM_DATA[plotData.seedId] : null;
                 const isBarren = plotData.fertility <= 0;
                 const penaltyFactor = plotData.barrenHarvestPenaltyFactor || 1.0;
                 const itemProtectTip = ITEM_DATA['fertilizer_protect']; // L·∫•y th√¥ng tin item b·∫£o v·ªá

                 // Chu·∫©n b·ªã c√°c ph·∫ßn th√¥ng tin cho tooltip
                 const fertilityInfoTip = isBarren ? `ƒê·∫•t: C·∫∞N 0%` : `ƒê·∫•t: ${Math.round(plotData.fertility)}%`;
                 const dryTextTip = plotData.isDry ? ' (Kh√¥!)' : '';
                 const pestTextTip = plotData.hasPest ? ' (C√≥ s√¢u!)' : '';
                 const fenceTextTip = plotData.fenceData ? (plotData.fenceData.health > 0 ? ` | üöß(${Math.round(plotData.fenceData.health)}%)` : ' | üöß(H·ªèng!)') : '';
                 let barrenPenaltyTextTip = '';
                 if (isBarren && penaltyFactor > 1.0) {
                      barrenPenaltyTextTip = `\n(M·ªçc ch·∫≠m x${penaltyFactor.toFixed(2)})`;
                 }
                 // --- TH√äM KI·ªÇM TRA BUFF V√ÄO TOOLTIP ---
                 let protectTextTip = '';
                 if (plotData.hasFertilizerProtectBuff && itemProtectTip) { // Ki·ªÉm tra c·∫£ itemProtectTip t·ªìn t·∫°i
                     const limitTip = itemProtectTip.usageLimitPerPlant || 3;
                     protectTextTip = `\nüõ°Ô∏è ƒê∆∞·ª£c b·∫£o v·ªá (${plotData.fertilizerProtectUsageCount}/${limitTip})`;
                 }
                 // --- K·∫æT TH√öC TH√äM ---

                 // X√¢y d·ª±ng n·ªôi dung tooltip d·ª±a tr√™n tr·∫°ng th√°i
                 if (plotData.fenceData && plotData.fenceData.health <= 0) { // ∆Øu ti√™n hi·ªÉn th·ªã R√ÄO H·ªéNG
                    const removeCostTip = ITEM_DATA.raobaove?.removeCost || 5;
                    tooltipText = `üöß R√†o H·ªèng!${fenceTextTip}\n(${fertilityInfoTip}${dryTextTip})${barrenPenaltyTextTip}\nClick M·ªü H√†nh ƒê·ªông (G·ª°: ${removeCostTip}üí∞).${protectTextTip}`; // Th√™m protectTextTip
                 } else if (plotData.seedId && stageInfo.isDead) { // C√¢y ch·∫øt (r√†o kh√¥ng h·ªèng ho·∫∑c kh√¥ng c√≥)
                      const plantNameDead = seedInfo?.name || 'C√¢y';
                      let cleanupCostText = "(Mi·ªÖn ph√≠)";
                      if(plotData.causeOfDeath === 'pest') {
                          const hasEnoughMoney = gameState.currency >= DEAD_PEST_CLEANUP_COST;
                          if (hasEnoughMoney) cleanupCostText = `(${DEAD_PEST_CLEANUP_COST}üí∞)`;
                          else cleanupCostText = `(Click ${DEAD_PEST_FREE_CLEANUP_CLICKS - (plotData.pestDeathClickCount||0)} l·∫ßn)`;
                      }
                      tooltipText = `üíÄ ${plantNameDead} ch·∫øt.${pestTextTip}\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick ƒë·ªÉ d·ªçn ${cleanupCostText}.${protectTextTip}`; // Th√™m protectTextTip
                 } else if (plotData.hasPest) { // C√≥ s√¢u (c√¢y s·ªëng, r√†o kh√¥ng h·ªèng)
                      const plantNamePest = seedInfo?.name || 'C√¢y';
                      tooltipText = `üêõ S√ÇU B·ªÜNH!${pestTextTip}\n(${plantNamePest} - HP: ${Math.round(plotData.health)}%)\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick M·ªü H√†nh ƒê·ªông.${protectTextTip}`; // Th√™m protectTextTip
                 } else if (plotData.seedId && seedInfo && !stageInfo.isError) { // C√¢y s·ªëng, kh√¥ng s√¢u (r√†o kh√¥ng h·ªèng)
                      if (stageInfo.isMature) { // C√¢y tr∆∞·ªüng th√†nh
                           // S·ª≠a l·ªói t√≠nh sellValue: ph·∫£i l·∫•y baseYield t·ª´ seedInfo
                           const baseYieldTip = seedInfo.harvestYield || 0;
                           const sellValue = Math.round(1 * (plotData.health / 100) * baseYieldTip);
                           tooltipText = `‚úÖ ${seedInfo.name} ƒë√£ ch√≠n!\n(HP ${Math.round(plotData.health)}% - B√°n: ${sellValue}üí∞)\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick M·ªü H√†nh ƒê·ªông.${protectTextTip}`; // Th√™m protectTextTip
                      } else { // C√¢y ƒëang l·ªõn
                         const effectiveGrowthTimeMs = stageInfo.effectiveGrowthTimeSec * 1000;
                         const timeRemainingMs = Math.max(0, effectiveGrowthTimeMs - (now - plotData.plantTime));
                         tooltipText = `${seedInfo.name}: ${Math.round(stageInfo.growthProgress * 100)}% l·ªõn\n(HP ${Math.round(plotData.health)}% - C√≤n ${formatTime(timeRemainingMs, true)})\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick M·ªü H√†nh ƒê·ªông.${protectTextTip}`; // Th√™m protectTextTip
                      }
                 } else { // √î tr·ªëng (kh√¥ng rod, r√†o kh√¥ng h·ªèng)
                      tooltipText = `√î ƒë·∫•t tr·ªëng\n(${fertilityInfoTip}${dryTextTip}${fenceTextTip})${barrenPenaltyTextTip}\nClick M·ªü H√†nh ƒê·ªông.${protectTextTip}`; // Th√™m protectTextTip
                 }
            }
            showTooltip(tooltipText, plotElement);
        } // --- K·∫øt th√∫c h√†m handlePlotMouseover ---
        function handlePlotMousemove(event) { if (tooltipElement.classList.contains('visible')) { positionTooltip(); } }
        function handlePlotMouseout(event) { hideTooltip(50); } // ·∫®n nhanh khi r·ªùi chu·ªôt

        // --- C√°c B·ªô X·ª≠ L√Ω S·ª± Ki·ªán To√†n C·ª•c & V√≤ng ƒê·ªùi Game ---
        // ======================================================
        function handlePageUnload(event) { console.log("S·ª± ki·ªán 'beforeunload': L∆∞u game l·∫ßn cu·ªëi..."); if (gameLoopInterval) stopGameLoop(); saveGame(); }
       function handleVisibilityChange() {
    const now = Date.now();
    if (document.hidden) {
        console.log("Tr·∫°ng th√°i trang: ·∫®n. L∆∞u game, d·ª´ng v√≤ng l·∫∑p v√† timer H·∫°t Ng·ªçc Tr·ªùi.");
        clearTimeout(hatNgocTroiTimeout);
        hatNgocTroiTimeout = null;
        // D·ª´ng √¢m thanh n·ªÅn v√† hi·ªáu ·ª©ng (KH√îNG thay ƒë·ªïi isMusicEnabled/areEffectSoundsEnabled)
        if (backgroundMusic && !backgroundMusic.paused) { backgroundMusic.pause(); }
        if (rainSound && !rainSound.paused) { rainSound.pause(); }
        if (rainySunnySound && !rainySunnySound.paused) { rainySunnySound.pause(); }
        if (lightningSound && !lightningSound.paused) { lightningSound.pause(); lightningSound.currentTime = 0;} // D·ª´ng c·∫£ s√©t n·∫øu ƒëang ƒë√°nh

        if (gameLoopInterval) stopGameLoop(); // D·ª´ng game loop (bao g·ªìm save)

    } else {
        console.log("Tr·∫°ng th√°i trang: Hi·ªÉn th·ªã. M√¥ ph·ªèng offline (n·∫øu c·∫ßn), kh·ªüi ƒë·ªông l·∫°i.");
        // ... (Ph·∫ßn m√¥ ph·ªèng offline gi·ªØ nguy√™n) ...
        const timeWasHidden = now - gameState.lastUpdateTimestamp;
        let stateChangedSim = false;
        if (timeWasHidden > TICK_INTERVAL * 1.5 && gameState.lastUpdateTimestamp > 0) {
           stateChangedSim = simulateOfflineProgress(gameState.lastUpdateTimestamp, now);
           gameState.totalPlayTime += timeWasHidden;
           gameState.lastUpdateTimestamp = now;
        } else if (timeWasHidden > 0 && gameState.lastUpdateTimestamp > 0){
           gameState.totalPlayTime += timeWasHidden;
           gameState.lastUpdateTimestamp = now;
        } else {
           gameState.lastUpdateTimestamp = now;
        }

         if (stateChangedSim) {
            renderGarden(); renderUI(); updateShopButtons(); if(inventoryModal.style.display === 'block') renderInventory();
            weatherUpdateNeeded = true;
        }

        // Kh·ªüi ƒë·ªông l·∫°i v√≤ng l·∫∑p game.
        startGameLoop(); // H√†m n√†y s·∫Ω g·ªçi gameTick v√† startHatNgocTroiTimer

        // *** C·∫≠p nh·∫≠t: Ch·ªâ ph√°t l·∫°i √¢m thanh n·∫øu tr·∫°ng th√°i t∆∞∆°ng ·ª©ng l√† B·∫¨T ***
        if (isMusicEnabled && backgroundMusic && backgroundMusic.paused) {
             backgroundMusic.play().catch(e => console.warn("Resume background music error:", e));
        }
        if (areEffectSoundsEnabled && gameState.currentWeather) {
            if (rainSound && gameState.currentWeather.id === 'rainy' && rainSound.paused) {
                rainSound.play().catch(e => console.warn("Resume rain sound error:", e));
            }
            if (rainySunnySound && gameState.currentWeather.id === 'rainy_sunny' && rainySunnySound.paused) {
                 rainySunnySound.play().catch(e => console.warn("Resume rainy/sunny sound error:", e));
            }
        }
    }
}
		function openMenuPopup() {
         if (menuPopup) {
            menuPopup.style.display = 'block'; // Ho·∫∑c 'flex' n·∫øu CSS d√πng flex ƒë·ªÉ cƒÉn gi·ªØa
			showDarkOverlay();
            // T√πy ch·ªçn: Focus v√†o n√∫t l·ªãch s·ª≠ (n√∫t c√≤n l·∫°i) ho·∫∑c n√∫t ƒë√≥ng
            const focusTarget = plantingHistoryBtn || closeMenuPopupBtn; // ∆Øu ti√™n focus n√∫t l·ªãch s·ª≠
            if (focusTarget) {
                setTimeout(() => focusTarget.focus(), 50);
            }
        } else {
            console.error("Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ DOM c·ªßa menu popup!");
        }
    }

    /** ƒê√≥ng Popup Menu Ch√≠nh */
    function closeMenuPopup() {
        if (menuPopup) {
            menuPopup.style.display = 'none';
			hideDarkOverlay();
        }
    }
	function populateShop() {
        console.log("[V10 Buy Fix populateShop] Populating shop items...");
        // Ki·ªÉm tra c√°c ph·∫ßn t·ª≠ DOM c·∫ßn thi·∫øt ngay t·ª´ ƒë·∫ßu
        if (!shopSeedList || !shopToolList || !shopSeedsEmptyMessage || !shopToolsEmptyMessage) {
            console.error("[V10 Buy Fix populateShop] FATAL ERROR: Shop list elements not found in DOM!");
            loadingIndicator.textContent = "L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ t·∫£i giao di·ªán c·ª≠a h√†ng.";
            return; // Kh√¥ng th·ªÉ ti·∫øp t·ª•c n·∫øu thi·∫øu c√°c list ch√≠nh
        }

        // X√≥a n·ªôi dung c≈© m·ªôt c√°ch an to√†n
        shopSeedList.innerHTML = '';
        shopToolList.innerHTML = '';
        let seedsAvailable = false;
        let toolsAndUpgradesAvailable = false;

        // S·∫Øp x·∫øp Item IDs (Logic s·∫Øp x·∫øp gi·ªØ nguy√™n nh∆∞ tr∆∞·ªõc)
        const sortedItemIds = Object.keys(ITEM_DATA).sort((a, b) => {
            const itemA = ITEM_DATA[a]; const itemB = ITEM_DATA[b];
            if (!itemA) return 1; if (!itemB) return -1; // ƒê·∫©y item l·ªói xu·ªëng cu·ªëi
            const typeOrder = { 'seed': 1, 'tool': 2, 'upgrade': 3 };
            const orderA = typeOrder[itemA.type] || 99;
            const orderB = typeOrder[itemB.type] || 99;
            if (orderA !== orderB) return orderA - orderB;
            if (itemA.type === 'tool' || itemA.type === 'upgrade') {
                if (itemA.id === 'pesticide') return -1; if (itemB.id === 'pesticide') return 1;
                return (itemA.price || 0) - (itemB.price || 0);
            }
            return (itemA.price || 0) - (itemB.price || 0);
        });
         console.log("[V10 Buy Fix populateShop] Sorted Item IDs:", sortedItemIds);

        // L·∫∑p qua c√°c v·∫≠t ph·∫©m ƒë√£ s·∫Øp x·∫øp
        sortedItemIds.forEach(itemId => {
            const item = ITEM_DATA[itemId];
            // Ki·ªÉm tra xem item c√≥ t·ªìn t·∫°i kh√¥ng
            if (!item) {
                console.warn(`[V10 Buy Fix populateShop] Skipping non-existent item ID: ${itemId}`);
                return;
            }
             console.log(`[V10 Buy Fix populateShop] Processing item: ${itemId} (${item.name}), Type: ${item.type}`);

            const itemCard = document.createElement('div');
            itemCard.classList.add('item-card');
            itemCard.dataset.itemId = itemId; // Quan tr·ªçng: G·∫Øn itemId v√†o th·∫ª cha

            let iconHtml = '';
            let detailsHtml = '';
            let buySectionHtml = '';
            let targetList = null; // List s·∫Ω th√™m th·∫ª item v√†o

            // --- L·∫•y Icon (an to√†n h∆°n) ---
            let iconSrc = 'Hinhanh/Caychet.png'; // Fallback
            try {
                if (item.type === 'seed' && item.imageFolder) {
                    iconSrc = `Hinhanh/${item.imageFolder}/pic_hatgiong_giaidoan${PLANT_GROWTH_STAGES}.png`;
                } else if ((item.type === 'tool' || item.type === 'upgrade') && item.imageFolder && item.imageFile) {
                    iconSrc = `${item.imageFolder}/${item.imageFile}`;
                }
            } catch (e) {
                 console.error(`[V10 Buy Fix populateShop] Error getting icon source for ${itemId}:`, e);
            }
            const imgTag = `<img src="${iconSrc}" alt="${item.name || 'Item'}" loading="lazy" onerror="this.onerror=null; this.src='Hinhanh/Caychet.png';">`;
            iconHtml = `<span class="item-icon">${imgTag}</span>`;

            // --- X·ª≠ l√Ω theo lo·∫°i v·∫≠t ph·∫©m ---
            if (item.type === 'seed') {
                seedsAvailable = true;
                targetList = shopSeedList;
                detailsHtml = `
                    <div class="item-details">
                        <div>üß∫ B√°n ƒë∆∞·ª£c: ${item.harvestYield || 0}üí∞/c√¢y</div>
                        <div>‚è∞ L·ªõn: ${formatTime((item.growthTime || 0) * 1000, true)}</div>
                        <div>üí© Hao ƒë·∫•t: -${((item.fertilityCost || 0) * 100).toFixed(0)}%</div>
                    </div>`;
                // N√∫t mua v√† input s·ªë l∆∞·ª£ng (ƒê·∫£m b·∫£o ID l√† duy nh·∫•t)
                buySectionHtml = `
                    <div class="seed-quantity-selector">
                        <label for="qty-${itemId}" style="font-size:0.8rem; margin-right: 5px;">SL:</label>
                        <input type="number" id="qty-${itemId}" class="seed-quantity-input" value="1" min="1" max="99" step="1" data-item-id="${itemId}" aria-label="S·ªë l∆∞·ª£ng ${item.name}">
                    </div>
                    <div class="total-seed-cost" id="total-${itemId}">Gi√° b√°n: ${item.price || 0}üí∞</div>
                    <button class="buy-button buy-seed-button" data-item-id="${itemId}">Mua</button> <!-- B·ªè disabled ban ƒë·∫ßu, ƒë·ªÉ updateSeedTotalCost x·ª≠ l√Ω -->
                `;
                 console.log(`[V10 Buy Fix populateShop] Prepared SEED card for ${itemId}`);

            } else if (item.type === 'tool') {
                toolsAndUpgradesAvailable = true;
                targetList = shopToolList;
                let toolDescHtml = '';
                if (item.description) toolDescHtml += `<div>${item.description}</div>`;
                if (typeof item.fertilityBoost === 'number') toolDescHtml += `<div>üí© Ph√¨ nhi√™u: +${(item.fertilityBoost * 100).toFixed(0)}%</div>`;
                if (item.id === 'raobaove' && typeof item.health === 'number') toolDescHtml += `<div>‚ù§Ô∏è S·ª©c kh·ªèe: ${item.health}</div>`;
                if (item.id === 'cotthuloi' && typeof LIGHTNING_ROD_MAX_HEALTH === 'number') toolDescHtml += `<div>‚ù§Ô∏è Ch·ªãu ƒë∆∞·ª£c: ${LIGHTNING_ROD_MAX_HEALTH} l·∫ßn s√©t</div>`;
                detailsHtml = `<div class="item-details">${toolDescHtml || 'C√¥ng c·ª• h·ªØu √≠ch'}</div>`;
                // N√∫t mua v√† input s·ªë l∆∞·ª£ng
                buySectionHtml = `
                    <div class="seed-quantity-selector">
                        <label for="qty-${itemId}" style="font-size:0.8rem; margin-right: 5px;">SL:</label>
                        <input type="number" id="qty-${itemId}" class="seed-quantity-input" value="1" min="1" max="99" step="1" data-item-id="${itemId}" aria-label="S·ªë l∆∞·ª£ng ${item.name}">
                    </div>
                    <div class="total-seed-cost" id="total-${itemId}">Gi√° b√°n: ${item.price || 0}üí∞</div>
                    <button class="buy-button buy-seed-button" data-item-id="${itemId}">Mua</button> <!-- B·ªè disabled ban ƒë·∫ßu -->
                `;
                 console.log(`[V10 Buy Fix populateShop] Prepared TOOL card for ${itemId}`);

            } else if (item.type === 'upgrade') {
                toolsAndUpgradesAvailable = true;
                targetList = shopToolList;
                const requiredCapacity = item.upgradeCapacity?.from;
                const targetCapacity = item.upgradeCapacity?.to;
                let upgradeDesc = item.description || 'N√¢ng c·∫•p quan tr·ªçng.';
                if (typeof requiredCapacity === 'number') {
                    upgradeDesc += `<br>Y√™u c·∫ßu: Kho hi·ªán t·∫°i ${requiredCapacity} ch·ªó.`;
                }
                detailsHtml = `<div class="item-details">${upgradeDesc}</div>`;
                // N√∫t mua n√¢ng c·∫•p (kh√¥ng c√≥ input s·ªë l∆∞·ª£ng)
                buySectionHtml = `
                    <div class="item-price" style="font-weight: bold; margin-bottom: 10px;">Gi√°: ${item.price || 0}üí∞</div>
                    <button class="buy-button buy-upgrade-button" data-item-id="${itemId}">Ki·ªÉm tra ƒêK</button> <!-- Text v√† disabled s·∫Ω ƒë∆∞·ª£c set b·ªüi updateShopButtons -->
                `;
                 console.log(`[V10 Buy Fix populateShop] Prepared UPGRADE card for ${itemId}`);
            }

            // Th√™m th·∫ª item v√†o danh s√°ch t∆∞∆°ng ·ª©ng n·∫øu c√≥ targetList
            if (targetList) {
                itemCard.innerHTML = `
                    ${iconHtml}
                    <div class="item-name">${item.name || 'L·ªói T√™n'}</div>
                    ${detailsHtml}
                    ${buySectionHtml}
                `;
                targetList.appendChild(itemCard);
                 console.log(`[V10 Buy Fix populateShop] Appended card for ${itemId} to target list.`);
                // Quan tr·ªçng: G·ªçi updateSeedTotalCost NGAY SAU KHI TH√äM ƒë·ªÉ t√≠nh to√°n ban ƒë·∫ßu v√† set tr·∫°ng th√°i n√∫t
                 if (item.type === 'seed' || item.type === 'tool') {
                    try {
                        updateSeedTotalCost(itemId, itemCard);
                         console.log(`[V10 Buy Fix populateShop] Initial cost/button state updated for ${itemId}.`);
                    } catch (e) {
                         console.error(`[V10 Buy Fix populateShop] Error calling updateSeedTotalCost for ${itemId} after append:`, e);
                    }
                 }
                 // C·∫≠p nh·∫≠t n√∫t N√¢ng c·∫•p ri√™ng bi·ªát (trong updateShopButtons)
            } else {
                 console.warn(`[V10 Buy Fix populateShop] No target list determined for item ${itemId} (Type: ${item.type})`);
            }
        });

        // Hi·ªÉn th·ªã/·∫©n th√¥ng b√°o tr·ªëng
        shopSeedsEmptyMessage.classList.toggle('hidden', seedsAvailable);
        shopToolList.style.display = toolsAndUpgradesAvailable ? 'grid' : 'none'; // ƒê·∫£m b·∫£o list hi·ªán ra n·∫øu c√≥ ƒë·ªì
        shopSeedsEmptyMessage.style.display = seedsAvailable ? 'none' : 'block'; // Hi·ªán/·∫©n message d·ª±a tr√™n c·ªù
        shopToolList.style.display = toolsAndUpgradesAvailable ? 'grid' : 'none';
        shopToolsEmptyMessage.style.display = toolsAndUpgradesAvailable ? 'none' : 'block';

         console.log(`[V10 Buy Fix populateShop] Seeds available: ${seedsAvailable}, Tools/Upgrades available: ${toolsAndUpgradesAvailable}`);


        // C·∫≠p nh·∫≠t tr·∫°ng th√°i t·∫•t c·∫£ c√°c n√∫t mua m·ªôt l·∫ßn cu·ªëi sau khi ƒëi·ªÅn xong
        // updateShopButtons ƒë∆∞·ª£c g·ªçi ri√™ng sau populateShop trong initGame/openModal n√™n kh√¥ng c·∫ßn g·ªçi l·∫°i ·ªü ƒë√¢y n·ªØa.
        console.log("[V10 Buy Fix populateShop] Finished populating shop.");
    }
	
	
	
        // --- B·∫Øt ƒê·∫ßu Game ---
        // =====================
        document.addEventListener('DOMContentLoaded', initGame);
        console.log("Script V∆∞·ªùn C√¢y (v9.2) ƒë√£ ƒë∆∞·ª£c t·∫£i. ƒêang ch·ªù DOMContentLoaded...");

    </script>

</body>
</html>
